{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Placa de expansi\u00f3n BEE \u00b6 Descripci\u00f3n general \u00b6 La BEE es una placa de expansi\u00f3n, dise\u00f1ada inicialmente para la primera versi\u00f3n de la Raspberry Pi , pero que pude ser utilizada con cualquiera de las versiones de este computador de una sola placa . Este complemento convierte a la Raspberry Pi en una suerte de entrenador econ\u00f3mico para estudiar distintas tem\u00e1ticas de varias titulaciones universitarias del \u00e1mbito de las TIC y la Electr\u00f3nica. Este equipo se ha utilizado con gran \u00e9xito para montar los puestos de laboratorio para varias asignaturas de distintas titulaciones del Departamento de Arquitectura de Computadores y Autom\u00e1tica de la Universidad Complutense de Madrid, limitando tanto el precio que el Departamento ha podido montar un puesto para cada estudiante, permitiendo que puedan llevarse a casa el material durante el curso para completar sus pr\u00e1cticas y/o profundizar en las materias implicadas. El uso de este material fue crucial para que los estudiantes pudi\u00e9sen realizar sus pr\u00e1cticas durante la pandemia de covid de 2019 y 2020. La placa BEE incorpora una serie de perif\u00e9ricos que son f\u00e1cilmente conectables a los pines GPIO de la raspberry pi. En lugar de proporcionar una conexi\u00f3n fija entre los perif\u00e9ricos y los GPIOS de del microcontrolador, es el usuario el que debe conectar cada uno de los perif\u00e9ricos a los pines deseados usando cables de puente dupont hembra-hembra o jumpers . Los pines de la raspberry pi se han dejado disponibles en distintas tiras de pines sobre la propia placa de expansi\u00f3n. En algunos casos se han colocado junto a los circuitos de algun perif\u00e9rico, debido a que la funcionalidad adicional de estos pines est\u00e1 relacionada con dicho perif\u00e9rico. Por ejemplo, los pines que proporcionan conexiones a los controladores hardware de PWM se han colocado junto al circuito del zumbador. Para esos casos la conexi\u00f3n entre el perif\u00e9rico y la raspberry pi puede hacerse de forma c\u00f3moda y sencilla usando jumpers. En todo momento se ha evitado que un pin pueda ser conectado a m\u00e1s de un dispositivo externo, para evitar cortocircuitos provocados por los estudiantes menos cuidadosos. Se han desarrollado hasta el momento dos versiones de la placa BEE. La primera versi\u00f3n (v1) es m\u00e1s peque\u00f1a y econ\u00f3mica, y contiene un conjunto m\u00e1s reducido de dispositivos pensados inicialmente para dar servicio a los laboratorios de un par de asignaturas del Grado de Ingenier\u00eda Electr\u00f3nica de Comunicaciones del Master de Nuevas Tecnolog\u00edas Electr\u00f3nicas y fot\u00f3nicas de la Facultad de CC. F\u00edsicas de la Universidad Complutense de Madrid. La segunda versi\u00f3n (v2) extiende el conjunto de dispositivos incluidos para ampliar el espectro de asignaturas que pueden sacar provecho de esta econ\u00f3mica y vers\u00e1til placa de expansi\u00f3n. Esta segunda versi\u00f3n ha empezado a utilizarse tambi\u00e9n en la Facultad de Inform\u00e1tica de la Universidad Complutense de Madrid en asignaturas de Rob\u00f3tica y Arquitectura Interna de Linux y Android. En ambas versiones, los pines etiquetados como Bx en la placa BEE, tanto en el esquem\u00e1tico como en la serigraf\u00eda sobre la propia pcb, se corresponden con los pines BCMx de la documentaci\u00f3n de Broadcom, tambi\u00e9n denotados como GPIOx en algunos sitios web, como por ejemplo en https://pinout.xyz/ . Los detalles de estos dos modelos se presentan en las pr\u00f3ximas secciones. BEE v1 \u00b6 La primera versi\u00f3n de la BEE incluye el siguiente conjunto b\u00e1sico de dispositivos: Un MCP3008. Se trata de un conversor anal\u00f3gico digital (ADC) de 10 bits con 8 canales. Su interfaz digital SPI puede ser conectada mediante 5 jumpers a los pines SPI de la Raspberry Pi por el canal CE0. Sockets para la conexi\u00f3n r\u00e1pida de sensores anal\u00f3gicos, que pueden ser conectados a las entradas de los canales del ADC mediante jumpers . Estos sensores pueden ser polarizados haciendo uso de la red de resistencias montada en la placa, escogi\u00e9ndose una alimentaci\u00f3n de 3.3 V o 5 V mediante un jumper . Un MCP4911. Se trata de un conversor digital anal\u00f3gico (DAC) de 10 bits, que tambi\u00e9n puede ser conectado al controlador SPI usando los mismos 5 jumpers , quedando conectado al canal CE1. 3 circuitos simples de pulsador, que pueden ser conectados a pines digitales de entrada del microcontrolador para recibir acciones de usuario. 3 circuitos simples de led polarizado, que pueden ser conectados a un pin GPIO del microntorlador para controlar el estado del led por software. Un conector para cables FTDI-232-R con conexi\u00f3n directa a los pines del puerto serie de la raspberry pi. Facilita la comunicaci\u00f3n serie desde un PC con la raspberry pi. Un conector para JTAG est\u00e1ndar de 20 pines, conectado a los pines de depuraci\u00f3n en circuito de la raspberry pi. 1 Zumbador piezoel\u00e9ctrico que puede ser conectado con jumpers a algunos de los pines pwm de la Raspberry PI. Estos dispositivos est\u00e1n incluidos para dar soporte al desarrollo de pr\u00e1cticas de las siguientes asignaturas del departamento de Arquitectura de Computadores y Autom\u00e1tica de la Universidad Complutense de Madrid: Estructura de Computadores: en la que se realizan pr\u00e1cticas de programaci\u00f3n de entrada salida bare-metal , usando pines digitales de entrada y salida, conectados a leds y pulsadores, manejo de puerto serie y conexi\u00f3n a dispositivos por SPI o I2C. Rob\u00f3tica: se utilizan sensores anal\u00f3gicos y digitales, ADC, DAC y controladores PWM. Rob\u00f3tica y Mecatr\u00f3nica: igual que en rob\u00f3tica, se usan sensores anal\u00f3gicos y digitales, ADC, DAC, motores, etc. Programaci\u00f3n de Nodos Sensores para Internet de las Cosas: se utilizan tambi\u00e9n sensores anal\u00f3gicos, temporizadores, controladores PWM, etc. Las siguientes im\u00e1genes muestran un modelo 3D de la BEE v1, una foto aislada de un montaje real de la placa y su conexi\u00f3n a la Raspberry Pi en el montaje utilizado el laboratorio del Grado de Ingenier\u00eda Electr\u00f3nica de Comunicaciones de la Universidad Complutense de Madrid: Como vemos, la BEE se conecta a la Raspberry Pi a trav\u00e9s de la tira de 2x20 pines J1, mediante un cable plano. La totalidad de los pines de la Raspberry quedan entonces accesibles al usuario a trav\u00e9s de otras tiras de pines. Los pines quedan distribuidos seg\u00fan su uso entre varias tiras de pines adicionales, algunas de ellas pr\u00f3ximas a los circuitos de perif\u00e9ricos que generalmente necesitar\u00e1n de dichos pines para su manejo y control. En estos casos la conexi\u00f3n entre el perif\u00e9rico y la raspberry pi se puede hacer de forma c\u00f3moda y sencilla utilizando jumpers. La siguiente figura muestra la disposici\u00f3n de las tiras de pines en la BEE v1, marcando en rojo las tiras que exponen los pines de la raspberry pi (etiquetados como Bx en la serigraf\u00eda). Como \u00fanica excepci\u00f3n, los pines B4, B22-B25 y B27, que deben usarse en el caso de realizar una depuraci\u00f3n en circuito con el controlador JTAG, est\u00e1n disponibles en la tira etiquetada en azul como JTAG. La siguiente figura muestra el esquem\u00e1tico de la primera versi\u00f3n de la placa BEE: Cada uno de los bloques de perif\u00e9ricos se explica y documenta m\u00e1s abajo, en las secciones correspondientes a cada uno de ellos. BEE v2 \u00b6 La segunda versi\u00f3n de la placa extiende los dispositivos incluidos para dar soporte a un mayor n\u00famero de asignaturas del Departamento de Arquitectura de Computadores y Autom\u00e1tica de la UCM, como por ejemplo Arquitectura Interna Linux y Android, d\u00f3nde se programan drivers para varios tipos de dispositivos en estos sistemas. Asimismo se incorpora una red de polarizaci\u00f3n mucho m\u00e1s vers\u00e1til, con el objetivo de facilitar la polarizaci\u00f3n de sensores anal\u00f3gicos que se quieran conectar a las entradas del ADC, proporcionando las resistencias de polarizaci\u00f3n m\u00e1s habituales, con posibilidad de combinarlas en serie o en paralelo, y microinterruptores para polarizar el conjunto a Gnd o Vcc. Concretamente, en esta versi\u00f3n de la placa se han a\u00f1adido a los dispositivos incluidos en la versi\u00f3n 1 la siguiente lista de perif\u00e9ricos: Un desplazador con buffer conectado a un display de 7 segmentos (con punto decimal), permite escribir en el display 7 segmentos desde la raspberry-pi usando pines gen\u00e9ricos de entrada y salida. Un led RGB polarizado, que puede ser operado desde la raspberry pi con pines gen\u00e9ricos de entrada salida. Una red de polarizaci\u00f3n de sensores, con micro interruptores y resistencias habituales para una polarizaci\u00f3n de sensores anal\u00f3gicos que quieran conectarse a las entradas del ADC. La siguiente imagen muestra un modelo 3D de la segunda iteraci\u00f3n de la placa: La siguiente figura muestra el esquem\u00e1tico de la primera versi\u00f3n de la placa BEE: Los bloques de perif\u00e9ricos se explican y documentan en las siguientes secciones. Alimentaci\u00f3n de perif\u00e9ricos \u00b6 Los perif\u00e9ricos con interfaz anal\u00f3gica (ADC y DAC) tienen una l\u00ednea de alimentaci\u00f3n separada del resto de componentes, Vdd, que puede ser conectada tanto a 3.3 V como a 5 V colocando un jumper en la tira de pines J14: Por ejemplo, si se van a manejar se\u00f1ales entre 0 y 3.3 V, nos interesar\u00e1 conectar Vdd a 3.3 V para usar los 10 bits del ADC para discretizar el rango de 0 a 3.3V, teniendo as\u00ed mayor precisi\u00f3n que si lo aliment\u00e1semos a 5 V. Del mismo modo, la tira J18 permite escoger 3.3 V o 5 V para la se\u00f1al Vcc, disponible para la polarizaci\u00f3n de sensores anal\u00f3gicos. Interruptores y leds \u00b6 La siguiente figura muestra el esquem\u00e1tico de este sencillo bloque de perif\u00e9ricos, que es com\u00fan para las dos versiones de la placa. Por un lado tenemos tres leds (D1-D3) con el c\u00e1todo conectado a GND. El \u00e1nodo de cada uno de ellos se conecta a una resistencia de polarizaci\u00f3n de 220 Ohmios, que tiene el otro terminal accesible en uno de los pines de la tira J4. Podemos as\u00ed usar un cable de puente dupont para conectar este terminal a un GPIO de la raspberry pi para controla por software el estado del led: si ponemos el pin a 1 (Vdd) pasar\u00e1 por el led una corriente de unos 7 mA ((3.3 - 1.8)/220 = 7 mA) y el led se encender\u00e1. Por otro lado, tenemos tres pulsadores de bot\u00f3n (SW1-SW3), con un terminal conectado a GND y el otro conectado a una resistencia que a su vez conecta a la alimentaci\u00f3n (3.3 V). El punto entre la resistencia y el pulsador se conecta a uno de los pines de la tira J4. Podemos conectar estos a un GPIO de la raspberry pi haciendo uso de nuevo de un cable dupont hembra-hembra. Si dicho GPIO se configura como entrada podremos usarlo para ver si el pulsador est\u00e1 pulsado (el valor le\u00eddo ser\u00e1 0) o sin pulsar (el valor le\u00eddo ser\u00e1 1). Siempre habr\u00e1 que tener en cuenta que en los cambios de estado se producir\u00e1n rebotes, debido principalmente a las oscilaciones mec\u00e1nicas del muelle incluido en el pulsador. Estos rebotes pueden ser filtrados con ayuda del controlador GPIO de la raspberry pi, y si es necesario, por software. Led RGB \u00b6 Este perif\u00e9rico s\u00f3lo est\u00e1 disponible en la BEE v2, su circuito se muestra a continuaci\u00f3n: Se trata de un led rgb , conectado en c\u00e1todo com\u00fan a tierra, mientras que los terminales de los 3 \u00e1nodos se conectan cada uno a una resistencia, cuyo otro terminal se expone a trav\u00e9s de la tira de pines J21. Podemos usar cables de puente dupont para conectar estos terminales a pines GPIO de la raspberry pi con el fin de controlar la intensidad de los canales Rojo Verde y Azul del led desde el microcontrolador (habitualmente generando se\u00f1ales PWM). Zumbador (Buzzer) \u00b6 Las dos versiones montan el mismo zumbador piezoel\u00e9ctrico ( datasheet ), pero el circuito completo cambia lig\u00e9ramente de una verisi\u00f3n a la otra. La siguiente figura muestra el esquem\u00e1tico del circuito en la versi\u00f3n 1 de la placa BEE. Como vemos, los terminales del zumbador se conectan a los dos pines centrales de una tira de pines 2x3 (J3), estando el resto de pines de la tira conectados a tierra (2) o a los GPIOS 18 (1), 13 (5) y 12 (6) de la raspberry pi. Como indica la web pinout.xyz , estos pines adicionales pueden configurarse con las funciones PWM0, PWM1 y PWM0 respectivamente, pudiendo as\u00ed polarizar el zumbador utilizando jumpers , como se explica m\u00e1s abajo. Este circuito se modific\u00f3 en la versi\u00f3n 2 de la placa, como muestra la siguiente figura. En este caso los terminales del zumbador se han conectado dir\u00e9ctamente a tierra y al terminal central de una tira de pines 1x3 (J3). Los pines restantes de esta tira se han conectado a los GPIOs 12 (PWM0) y 13 (PWM1) de la raspberry pi. En ambos versiones puede usarse un jumper para conectar el zumbador al pin 12 (PWM0) o el 13 (PWM1), y probar as\u00ed el uso del zumbador con se\u00f1ales PWM generadas con los cotroladores internos del microcontrolador. En la versi\u00f3n 1 de la placa deberemos usar otro jumper para conectar el otro extremo a tierra. Conversor Anal\u00f3gico Digital (ADC) \u00b6 En ambas versiones de la placa se monta un conversor anal\u00f3gico digital MCP3008 , con las siguientes caracter\u00edsticas: 10 bits de resoluci\u00f3n 8 canales de entrada Interfaz SPI Entrada independiente para el voltaje de referencia Los esquem\u00e1ticos de la conexi\u00f3n del ADC en las dos versiones de la placa se muestran y explican a continuaci\u00f3n. S\u00f3lo difieren en la conexi\u00f3n de las entradas anal\u00f3gicas, debido a la modificaci\u00f3n que se realiz\u00f3 en la red de polarizaci\u00f3n de sensores. En ambos casos, se debe conectar un voltaje de referencia al ADC antes de usarlo. Si no se dispone de un voltaje de precisi\u00f3n, la placa proporciona una forma sencilla de conectar la entrada Vref a la alimentaci\u00f3n Vdd del ADC. En la primera versi\u00f3n de la placa las entradas anal\u00f3gicas del ADC se conectan a una tira de pines 2x8 (J8), que por el otro lado est\u00e1 conectada a un socket 2x8 (J7), por el lado en el que se conectan unas resistencias de pull down de 220, 10 k, 15 k y 47 k ohmios. Por el otro lado del socket J7 los pines se conectan a la alimentaci\u00f3n anal\u00f3gica (Vcc). De esta forma, podemos conectar un sensor anal\u00f3gico de dos patas en el socket J7, quedando uno de sus terminales conectado a la tira J8 y a una resistencia de pull-down, y el otro a Vcc. Podemos entonces utilizar un jumper en J8 para conectar la salida del sensor a la entrada anal\u00f3gica correspondiente del ADC. Aunque este circuito permite conectar f\u00e1cilmente muchos sensores anal\u00f3gicos al ADC, tenemos ciertas limitaciones: S\u00f3lo podemos usar configuraciones que requieran una resistencia de pull-down. S\u00f3lo podemos escoger 4 valores para la resistencia de pull-down. Para salvar estas limitaciones se modific\u00f3 este circuito en la segunda versi\u00f3n de la placa. Se redefini\u00f3 la red de polarizaci\u00f3n para facilitar la conexi\u00f3n serie o paralelo de las resistencias incluidas, as\u00ed como su conexi\u00f3n como conjuto de pull-down o pull-up. Adem\u00e1s, el nuevo circuito de polarizaci\u00f3n introduce dos potenci\u00f3metros que nos permiten obtener resistencias de polarizaci\u00f3n m\u00e1s especiales. El esqum\u00e1tico se muestra a continuaci\u00f3n: Este circuito est\u00e1 pensado para conectar f\u00e1cilmente al ADC sensores anal\u00f3gicos de dos terminales, en los que uno de ellos debe ir conectado directamente a GND o Vcc, y el otro a una resistencia de pull up o pull down. La salida del sensor se toma entonces del terminal conectado a la resistencia. En estos casos, el sensor se conecta al socket J7, escogiendo la posici\u00f3n que lleve a la resistencia que necesitamos, y usando los micro interruptores de U3 y U4 para conectar a GND o VCC tanto el sensor como la resistencia seleccionada. La salida del sensor estar\u00e1 entonces disponible en la tira de pines J15, y podemos usar un cable dupont hembra-hembra para conectarla a la entrada del ADC deseada, disponible en J8. Si ninguna de las resistencias que hay en el circuito es la resistencia que necesitamos, tenemos dos opciones: Conectar dos (o m\u00e1s) de las resistencias disponibles en serie o paralelo para obtener la resistencia deseada. Para ello podemos usar las tiras de pines J15 y J20, y en alg\u00fan caso un cable dupont. Usar los potenci\u00f3metros incluidos en la red de polarizaci\u00f3n, utilizando un destornillador peque\u00f1o para ajustarlo y un mult\u00edmetro para medir su valor. En ambas placas el interfaz digital del ADC est\u00e1 conectado a la tira de pines J2, que permite conectar con jumpers el ADC (y/o el DAC) a la raspberry pi, usando los GPIOs que corresponden al controlador SPI (el software debe configurar dichos gpios para esta funcionalidad). La siguiente figura muestra el esquem\u00e1tico de este conector: Conversor Digital Anal\u00f3gico (DAC) \u00b6 La placa BEE incorpora tambi\u00e9n un MCP4911 , un Conversor Digital Anal\u00f3gico (DAC) de 10 bits, que puede ser conectado tambi\u00e9n al controlador SPI a trav\u00e9s de la tira de pines J2 usando jumpers. El DAC queda conectado entonces al canal CE1. El esquem\u00e1tico es id\u00e9ntico en ambas versiones de la placa: Como pasaba con el ADC, debemos conectar un voltaje de referencia al DAC. Podemos colocar un jumper en J10 para conectar la entrada Vref a la tensi\u00f3n de alimentaci\u00f3n del DAC (VDD) si no tenemos una referencia de mayor precisi\u00f3n. Asimismo, el DAC dispone de una entrada LDAC, que debe ponerse a 0 V para cargar un nuevo valor en el registro de salida del DAC (consultar el Datasheet del componente). La placa BEE conecta esta entrada a la tira J9, de modo que puede usarse un jumper para conectarlo a 0 permanentemente o utilizar otro GPIO para activarlo por software cuando sea apropiado. El voltaje de salida del DAC est\u00e1 disponible en uno de los pines de la tira J12, estando el otro pin de la tira conectado a GND. Esto facilita la conexi\u00f3n de cualquier dispositivo que deba ser alimentado con la tensi\u00f3n generada con el DAC. Finalmente, como sucede con el ADC, el interfaz digital del DAC se puede conectar mediante jumpers a los GPIOs del controlador SPI de la raspberry pi utilizando el conector J2 (el software debe configurar dichos GPIOs para esta funcionalidad). Driver de display 7 segmentos \u00b6 Este perif\u00e9rico s\u00f3lo est\u00e1 disponible en la versi\u00f3n 2 de la placa BEE, su circuito es el siguiente: Como vemos, se compone principalmente de dos componentes: Un registro de desplazamiento 74AHC_AHCT595 Un display de 7 segmentos (m\u00e1s un punto decimal). El 74AHC595 utiliza doble buffer. Tiene un registro de desplazamiento que permite cargar en 8 ciclos de la se\u00f1al SRCLK un valor de 8 bits enviado en serie por la entrada serie (SER), y un registro de salida, que mantiene inalterado un valor de 8 bits mientras se carga un nuevo valor en el registro de desplazamiento. El valor almacenado en el registro de salida (QA-QH) se conecta a las entradas del display 7 segmentos (A-G, DP) a trav\u00e9s de 8 resistencias de 220 ohmios para limitar la corriente. El display mostrar\u00e1 el digito codificado en estos 8 bits (cada bit indica si se debe encender o no uno de los segmentos). El display es activo en alta, es decir, que un 1 en la entrada A indica que debe encenderse el segmento A (ve el s\u00edmbolo del esquem\u00e1tico), mientras que un 0 en dicha entrada indicar\u00eda que debe apagarse dicho segmento. Como la entrada de habilitaci\u00f3n de la salida (nOE) est\u00e1 conectada a GND, la salida est\u00e1 permanentemente habilitada. La se\u00f1al nSRCLR (nMR en el datasheet) permite resetear los biestables del registro de desplazamiento. Est\u00e1 conectada permanentemente a 1 (no se pueden resetear). El resto de se\u00f1ales (SER, SRCLK y RCLK) se conectan a la tira de pines J6, y podemos usar cables de puente dupont para conectarlos a los pines GPIO que queramos. El funcionamiento del dispositivo es como sigue. Los bits se van cargando en serie en el registro de desplazamiento. Cuando generamos un pulso en la se\u00f1al SRCLK, el valor en la entrada serie SER se carge en el biestable 0, el biestable 1 cargar\u00e1 el valor que ten\u00eda antes el biestable 0, el biestable 2 el valor que ten\u00eda antes el 1 y as\u00ed sucesivamente. La salida QH' nos permite conectar en serie otro 74H595 para almacenar valores de m\u00e1s de 8 bits. Cuando tengamos el valor completo cargado (8 bits), podemos generar un pulso en la se\u00f1al RCLK para cargar los biestables del registro de salida con el contenido almacenado en el registro de desplazamiento. Esto nos permite ir cargando un nuevo valor sin alterar lo que se est\u00e1 mostrando en el display 7 segmentos, mostrando de golpe el nuevo valor cuando se hayan cargado los 8 nuevos bits. Conector UART \u00b6 Se trata de una tira de pines (J13) con la configuraci\u00f3n adecuada para que podamos conectar un cable FTDI-232-R y usar el puerto serie de la mini-uart que incorpora la raspberry pi, ideal para proporcionar un terminal serie a cualquier aplicaci\u00f3n que corra en el microcontrolador. Conector JTAG \u00b6 Se trata de una tira de pines compatible un conector JTAG de 20 pines. La raspberry pi incorpora un controlado JTAG de depuraci\u00f3n en circuito. Se puede usar este controlador si se configura correctamente la funcionalidad de los pines BCM4, BCM22-25 y BCM27, que est\u00e1n rutados a las posiciones adecuadas de la tira de pines J5. Para usar el depurador debemos conectar un dongle JTAG de depuraci\u00f3n a J5, y usar un software como OpenOCD para establecer una sesi\u00f3n de depuraci\u00f3n.","title":"Placa de expansi\u00f3n BEE"},{"location":"#placa-de-expansion-bee","text":"","title":"Placa de expansi\u00f3n BEE"},{"location":"#descripcion-general","text":"La BEE es una placa de expansi\u00f3n, dise\u00f1ada inicialmente para la primera versi\u00f3n de la Raspberry Pi , pero que pude ser utilizada con cualquiera de las versiones de este computador de una sola placa . Este complemento convierte a la Raspberry Pi en una suerte de entrenador econ\u00f3mico para estudiar distintas tem\u00e1ticas de varias titulaciones universitarias del \u00e1mbito de las TIC y la Electr\u00f3nica. Este equipo se ha utilizado con gran \u00e9xito para montar los puestos de laboratorio para varias asignaturas de distintas titulaciones del Departamento de Arquitectura de Computadores y Autom\u00e1tica de la Universidad Complutense de Madrid, limitando tanto el precio que el Departamento ha podido montar un puesto para cada estudiante, permitiendo que puedan llevarse a casa el material durante el curso para completar sus pr\u00e1cticas y/o profundizar en las materias implicadas. El uso de este material fue crucial para que los estudiantes pudi\u00e9sen realizar sus pr\u00e1cticas durante la pandemia de covid de 2019 y 2020. La placa BEE incorpora una serie de perif\u00e9ricos que son f\u00e1cilmente conectables a los pines GPIO de la raspberry pi. En lugar de proporcionar una conexi\u00f3n fija entre los perif\u00e9ricos y los GPIOS de del microcontrolador, es el usuario el que debe conectar cada uno de los perif\u00e9ricos a los pines deseados usando cables de puente dupont hembra-hembra o jumpers . Los pines de la raspberry pi se han dejado disponibles en distintas tiras de pines sobre la propia placa de expansi\u00f3n. En algunos casos se han colocado junto a los circuitos de algun perif\u00e9rico, debido a que la funcionalidad adicional de estos pines est\u00e1 relacionada con dicho perif\u00e9rico. Por ejemplo, los pines que proporcionan conexiones a los controladores hardware de PWM se han colocado junto al circuito del zumbador. Para esos casos la conexi\u00f3n entre el perif\u00e9rico y la raspberry pi puede hacerse de forma c\u00f3moda y sencilla usando jumpers. En todo momento se ha evitado que un pin pueda ser conectado a m\u00e1s de un dispositivo externo, para evitar cortocircuitos provocados por los estudiantes menos cuidadosos. Se han desarrollado hasta el momento dos versiones de la placa BEE. La primera versi\u00f3n (v1) es m\u00e1s peque\u00f1a y econ\u00f3mica, y contiene un conjunto m\u00e1s reducido de dispositivos pensados inicialmente para dar servicio a los laboratorios de un par de asignaturas del Grado de Ingenier\u00eda Electr\u00f3nica de Comunicaciones del Master de Nuevas Tecnolog\u00edas Electr\u00f3nicas y fot\u00f3nicas de la Facultad de CC. F\u00edsicas de la Universidad Complutense de Madrid. La segunda versi\u00f3n (v2) extiende el conjunto de dispositivos incluidos para ampliar el espectro de asignaturas que pueden sacar provecho de esta econ\u00f3mica y vers\u00e1til placa de expansi\u00f3n. Esta segunda versi\u00f3n ha empezado a utilizarse tambi\u00e9n en la Facultad de Inform\u00e1tica de la Universidad Complutense de Madrid en asignaturas de Rob\u00f3tica y Arquitectura Interna de Linux y Android. En ambas versiones, los pines etiquetados como Bx en la placa BEE, tanto en el esquem\u00e1tico como en la serigraf\u00eda sobre la propia pcb, se corresponden con los pines BCMx de la documentaci\u00f3n de Broadcom, tambi\u00e9n denotados como GPIOx en algunos sitios web, como por ejemplo en https://pinout.xyz/ . Los detalles de estos dos modelos se presentan en las pr\u00f3ximas secciones.","title":"Descripci\u00f3n general"},{"location":"#bee-v1","text":"La primera versi\u00f3n de la BEE incluye el siguiente conjunto b\u00e1sico de dispositivos: Un MCP3008. Se trata de un conversor anal\u00f3gico digital (ADC) de 10 bits con 8 canales. Su interfaz digital SPI puede ser conectada mediante 5 jumpers a los pines SPI de la Raspberry Pi por el canal CE0. Sockets para la conexi\u00f3n r\u00e1pida de sensores anal\u00f3gicos, que pueden ser conectados a las entradas de los canales del ADC mediante jumpers . Estos sensores pueden ser polarizados haciendo uso de la red de resistencias montada en la placa, escogi\u00e9ndose una alimentaci\u00f3n de 3.3 V o 5 V mediante un jumper . Un MCP4911. Se trata de un conversor digital anal\u00f3gico (DAC) de 10 bits, que tambi\u00e9n puede ser conectado al controlador SPI usando los mismos 5 jumpers , quedando conectado al canal CE1. 3 circuitos simples de pulsador, que pueden ser conectados a pines digitales de entrada del microcontrolador para recibir acciones de usuario. 3 circuitos simples de led polarizado, que pueden ser conectados a un pin GPIO del microntorlador para controlar el estado del led por software. Un conector para cables FTDI-232-R con conexi\u00f3n directa a los pines del puerto serie de la raspberry pi. Facilita la comunicaci\u00f3n serie desde un PC con la raspberry pi. Un conector para JTAG est\u00e1ndar de 20 pines, conectado a los pines de depuraci\u00f3n en circuito de la raspberry pi. 1 Zumbador piezoel\u00e9ctrico que puede ser conectado con jumpers a algunos de los pines pwm de la Raspberry PI. Estos dispositivos est\u00e1n incluidos para dar soporte al desarrollo de pr\u00e1cticas de las siguientes asignaturas del departamento de Arquitectura de Computadores y Autom\u00e1tica de la Universidad Complutense de Madrid: Estructura de Computadores: en la que se realizan pr\u00e1cticas de programaci\u00f3n de entrada salida bare-metal , usando pines digitales de entrada y salida, conectados a leds y pulsadores, manejo de puerto serie y conexi\u00f3n a dispositivos por SPI o I2C. Rob\u00f3tica: se utilizan sensores anal\u00f3gicos y digitales, ADC, DAC y controladores PWM. Rob\u00f3tica y Mecatr\u00f3nica: igual que en rob\u00f3tica, se usan sensores anal\u00f3gicos y digitales, ADC, DAC, motores, etc. Programaci\u00f3n de Nodos Sensores para Internet de las Cosas: se utilizan tambi\u00e9n sensores anal\u00f3gicos, temporizadores, controladores PWM, etc. Las siguientes im\u00e1genes muestran un modelo 3D de la BEE v1, una foto aislada de un montaje real de la placa y su conexi\u00f3n a la Raspberry Pi en el montaje utilizado el laboratorio del Grado de Ingenier\u00eda Electr\u00f3nica de Comunicaciones de la Universidad Complutense de Madrid: Como vemos, la BEE se conecta a la Raspberry Pi a trav\u00e9s de la tira de 2x20 pines J1, mediante un cable plano. La totalidad de los pines de la Raspberry quedan entonces accesibles al usuario a trav\u00e9s de otras tiras de pines. Los pines quedan distribuidos seg\u00fan su uso entre varias tiras de pines adicionales, algunas de ellas pr\u00f3ximas a los circuitos de perif\u00e9ricos que generalmente necesitar\u00e1n de dichos pines para su manejo y control. En estos casos la conexi\u00f3n entre el perif\u00e9rico y la raspberry pi se puede hacer de forma c\u00f3moda y sencilla utilizando jumpers. La siguiente figura muestra la disposici\u00f3n de las tiras de pines en la BEE v1, marcando en rojo las tiras que exponen los pines de la raspberry pi (etiquetados como Bx en la serigraf\u00eda). Como \u00fanica excepci\u00f3n, los pines B4, B22-B25 y B27, que deben usarse en el caso de realizar una depuraci\u00f3n en circuito con el controlador JTAG, est\u00e1n disponibles en la tira etiquetada en azul como JTAG. La siguiente figura muestra el esquem\u00e1tico de la primera versi\u00f3n de la placa BEE: Cada uno de los bloques de perif\u00e9ricos se explica y documenta m\u00e1s abajo, en las secciones correspondientes a cada uno de ellos.","title":"BEE v1"},{"location":"#bee-v2","text":"La segunda versi\u00f3n de la placa extiende los dispositivos incluidos para dar soporte a un mayor n\u00famero de asignaturas del Departamento de Arquitectura de Computadores y Autom\u00e1tica de la UCM, como por ejemplo Arquitectura Interna Linux y Android, d\u00f3nde se programan drivers para varios tipos de dispositivos en estos sistemas. Asimismo se incorpora una red de polarizaci\u00f3n mucho m\u00e1s vers\u00e1til, con el objetivo de facilitar la polarizaci\u00f3n de sensores anal\u00f3gicos que se quieran conectar a las entradas del ADC, proporcionando las resistencias de polarizaci\u00f3n m\u00e1s habituales, con posibilidad de combinarlas en serie o en paralelo, y microinterruptores para polarizar el conjunto a Gnd o Vcc. Concretamente, en esta versi\u00f3n de la placa se han a\u00f1adido a los dispositivos incluidos en la versi\u00f3n 1 la siguiente lista de perif\u00e9ricos: Un desplazador con buffer conectado a un display de 7 segmentos (con punto decimal), permite escribir en el display 7 segmentos desde la raspberry-pi usando pines gen\u00e9ricos de entrada y salida. Un led RGB polarizado, que puede ser operado desde la raspberry pi con pines gen\u00e9ricos de entrada salida. Una red de polarizaci\u00f3n de sensores, con micro interruptores y resistencias habituales para una polarizaci\u00f3n de sensores anal\u00f3gicos que quieran conectarse a las entradas del ADC. La siguiente imagen muestra un modelo 3D de la segunda iteraci\u00f3n de la placa: La siguiente figura muestra el esquem\u00e1tico de la primera versi\u00f3n de la placa BEE: Los bloques de perif\u00e9ricos se explican y documentan en las siguientes secciones.","title":"BEE v2"},{"location":"#alimentacion-de-perifericos","text":"Los perif\u00e9ricos con interfaz anal\u00f3gica (ADC y DAC) tienen una l\u00ednea de alimentaci\u00f3n separada del resto de componentes, Vdd, que puede ser conectada tanto a 3.3 V como a 5 V colocando un jumper en la tira de pines J14: Por ejemplo, si se van a manejar se\u00f1ales entre 0 y 3.3 V, nos interesar\u00e1 conectar Vdd a 3.3 V para usar los 10 bits del ADC para discretizar el rango de 0 a 3.3V, teniendo as\u00ed mayor precisi\u00f3n que si lo aliment\u00e1semos a 5 V. Del mismo modo, la tira J18 permite escoger 3.3 V o 5 V para la se\u00f1al Vcc, disponible para la polarizaci\u00f3n de sensores anal\u00f3gicos.","title":"Alimentaci\u00f3n de perif\u00e9ricos"},{"location":"#interruptores-y-leds","text":"La siguiente figura muestra el esquem\u00e1tico de este sencillo bloque de perif\u00e9ricos, que es com\u00fan para las dos versiones de la placa. Por un lado tenemos tres leds (D1-D3) con el c\u00e1todo conectado a GND. El \u00e1nodo de cada uno de ellos se conecta a una resistencia de polarizaci\u00f3n de 220 Ohmios, que tiene el otro terminal accesible en uno de los pines de la tira J4. Podemos as\u00ed usar un cable de puente dupont para conectar este terminal a un GPIO de la raspberry pi para controla por software el estado del led: si ponemos el pin a 1 (Vdd) pasar\u00e1 por el led una corriente de unos 7 mA ((3.3 - 1.8)/220 = 7 mA) y el led se encender\u00e1. Por otro lado, tenemos tres pulsadores de bot\u00f3n (SW1-SW3), con un terminal conectado a GND y el otro conectado a una resistencia que a su vez conecta a la alimentaci\u00f3n (3.3 V). El punto entre la resistencia y el pulsador se conecta a uno de los pines de la tira J4. Podemos conectar estos a un GPIO de la raspberry pi haciendo uso de nuevo de un cable dupont hembra-hembra. Si dicho GPIO se configura como entrada podremos usarlo para ver si el pulsador est\u00e1 pulsado (el valor le\u00eddo ser\u00e1 0) o sin pulsar (el valor le\u00eddo ser\u00e1 1). Siempre habr\u00e1 que tener en cuenta que en los cambios de estado se producir\u00e1n rebotes, debido principalmente a las oscilaciones mec\u00e1nicas del muelle incluido en el pulsador. Estos rebotes pueden ser filtrados con ayuda del controlador GPIO de la raspberry pi, y si es necesario, por software.","title":"Interruptores y leds"},{"location":"#led-rgb","text":"Este perif\u00e9rico s\u00f3lo est\u00e1 disponible en la BEE v2, su circuito se muestra a continuaci\u00f3n: Se trata de un led rgb , conectado en c\u00e1todo com\u00fan a tierra, mientras que los terminales de los 3 \u00e1nodos se conectan cada uno a una resistencia, cuyo otro terminal se expone a trav\u00e9s de la tira de pines J21. Podemos usar cables de puente dupont para conectar estos terminales a pines GPIO de la raspberry pi con el fin de controlar la intensidad de los canales Rojo Verde y Azul del led desde el microcontrolador (habitualmente generando se\u00f1ales PWM).","title":"Led RGB"},{"location":"#zumbador-buzzer","text":"Las dos versiones montan el mismo zumbador piezoel\u00e9ctrico ( datasheet ), pero el circuito completo cambia lig\u00e9ramente de una verisi\u00f3n a la otra. La siguiente figura muestra el esquem\u00e1tico del circuito en la versi\u00f3n 1 de la placa BEE. Como vemos, los terminales del zumbador se conectan a los dos pines centrales de una tira de pines 2x3 (J3), estando el resto de pines de la tira conectados a tierra (2) o a los GPIOS 18 (1), 13 (5) y 12 (6) de la raspberry pi. Como indica la web pinout.xyz , estos pines adicionales pueden configurarse con las funciones PWM0, PWM1 y PWM0 respectivamente, pudiendo as\u00ed polarizar el zumbador utilizando jumpers , como se explica m\u00e1s abajo. Este circuito se modific\u00f3 en la versi\u00f3n 2 de la placa, como muestra la siguiente figura. En este caso los terminales del zumbador se han conectado dir\u00e9ctamente a tierra y al terminal central de una tira de pines 1x3 (J3). Los pines restantes de esta tira se han conectado a los GPIOs 12 (PWM0) y 13 (PWM1) de la raspberry pi. En ambos versiones puede usarse un jumper para conectar el zumbador al pin 12 (PWM0) o el 13 (PWM1), y probar as\u00ed el uso del zumbador con se\u00f1ales PWM generadas con los cotroladores internos del microcontrolador. En la versi\u00f3n 1 de la placa deberemos usar otro jumper para conectar el otro extremo a tierra.","title":"Zumbador (Buzzer)"},{"location":"#conversor-analogico-digital-adc","text":"En ambas versiones de la placa se monta un conversor anal\u00f3gico digital MCP3008 , con las siguientes caracter\u00edsticas: 10 bits de resoluci\u00f3n 8 canales de entrada Interfaz SPI Entrada independiente para el voltaje de referencia Los esquem\u00e1ticos de la conexi\u00f3n del ADC en las dos versiones de la placa se muestran y explican a continuaci\u00f3n. S\u00f3lo difieren en la conexi\u00f3n de las entradas anal\u00f3gicas, debido a la modificaci\u00f3n que se realiz\u00f3 en la red de polarizaci\u00f3n de sensores. En ambos casos, se debe conectar un voltaje de referencia al ADC antes de usarlo. Si no se dispone de un voltaje de precisi\u00f3n, la placa proporciona una forma sencilla de conectar la entrada Vref a la alimentaci\u00f3n Vdd del ADC. En la primera versi\u00f3n de la placa las entradas anal\u00f3gicas del ADC se conectan a una tira de pines 2x8 (J8), que por el otro lado est\u00e1 conectada a un socket 2x8 (J7), por el lado en el que se conectan unas resistencias de pull down de 220, 10 k, 15 k y 47 k ohmios. Por el otro lado del socket J7 los pines se conectan a la alimentaci\u00f3n anal\u00f3gica (Vcc). De esta forma, podemos conectar un sensor anal\u00f3gico de dos patas en el socket J7, quedando uno de sus terminales conectado a la tira J8 y a una resistencia de pull-down, y el otro a Vcc. Podemos entonces utilizar un jumper en J8 para conectar la salida del sensor a la entrada anal\u00f3gica correspondiente del ADC. Aunque este circuito permite conectar f\u00e1cilmente muchos sensores anal\u00f3gicos al ADC, tenemos ciertas limitaciones: S\u00f3lo podemos usar configuraciones que requieran una resistencia de pull-down. S\u00f3lo podemos escoger 4 valores para la resistencia de pull-down. Para salvar estas limitaciones se modific\u00f3 este circuito en la segunda versi\u00f3n de la placa. Se redefini\u00f3 la red de polarizaci\u00f3n para facilitar la conexi\u00f3n serie o paralelo de las resistencias incluidas, as\u00ed como su conexi\u00f3n como conjuto de pull-down o pull-up. Adem\u00e1s, el nuevo circuito de polarizaci\u00f3n introduce dos potenci\u00f3metros que nos permiten obtener resistencias de polarizaci\u00f3n m\u00e1s especiales. El esqum\u00e1tico se muestra a continuaci\u00f3n: Este circuito est\u00e1 pensado para conectar f\u00e1cilmente al ADC sensores anal\u00f3gicos de dos terminales, en los que uno de ellos debe ir conectado directamente a GND o Vcc, y el otro a una resistencia de pull up o pull down. La salida del sensor se toma entonces del terminal conectado a la resistencia. En estos casos, el sensor se conecta al socket J7, escogiendo la posici\u00f3n que lleve a la resistencia que necesitamos, y usando los micro interruptores de U3 y U4 para conectar a GND o VCC tanto el sensor como la resistencia seleccionada. La salida del sensor estar\u00e1 entonces disponible en la tira de pines J15, y podemos usar un cable dupont hembra-hembra para conectarla a la entrada del ADC deseada, disponible en J8. Si ninguna de las resistencias que hay en el circuito es la resistencia que necesitamos, tenemos dos opciones: Conectar dos (o m\u00e1s) de las resistencias disponibles en serie o paralelo para obtener la resistencia deseada. Para ello podemos usar las tiras de pines J15 y J20, y en alg\u00fan caso un cable dupont. Usar los potenci\u00f3metros incluidos en la red de polarizaci\u00f3n, utilizando un destornillador peque\u00f1o para ajustarlo y un mult\u00edmetro para medir su valor. En ambas placas el interfaz digital del ADC est\u00e1 conectado a la tira de pines J2, que permite conectar con jumpers el ADC (y/o el DAC) a la raspberry pi, usando los GPIOs que corresponden al controlador SPI (el software debe configurar dichos gpios para esta funcionalidad). La siguiente figura muestra el esquem\u00e1tico de este conector:","title":"Conversor Anal\u00f3gico Digital (ADC)"},{"location":"#conversor-digital-analogico-dac","text":"La placa BEE incorpora tambi\u00e9n un MCP4911 , un Conversor Digital Anal\u00f3gico (DAC) de 10 bits, que puede ser conectado tambi\u00e9n al controlador SPI a trav\u00e9s de la tira de pines J2 usando jumpers. El DAC queda conectado entonces al canal CE1. El esquem\u00e1tico es id\u00e9ntico en ambas versiones de la placa: Como pasaba con el ADC, debemos conectar un voltaje de referencia al DAC. Podemos colocar un jumper en J10 para conectar la entrada Vref a la tensi\u00f3n de alimentaci\u00f3n del DAC (VDD) si no tenemos una referencia de mayor precisi\u00f3n. Asimismo, el DAC dispone de una entrada LDAC, que debe ponerse a 0 V para cargar un nuevo valor en el registro de salida del DAC (consultar el Datasheet del componente). La placa BEE conecta esta entrada a la tira J9, de modo que puede usarse un jumper para conectarlo a 0 permanentemente o utilizar otro GPIO para activarlo por software cuando sea apropiado. El voltaje de salida del DAC est\u00e1 disponible en uno de los pines de la tira J12, estando el otro pin de la tira conectado a GND. Esto facilita la conexi\u00f3n de cualquier dispositivo que deba ser alimentado con la tensi\u00f3n generada con el DAC. Finalmente, como sucede con el ADC, el interfaz digital del DAC se puede conectar mediante jumpers a los GPIOs del controlador SPI de la raspberry pi utilizando el conector J2 (el software debe configurar dichos GPIOs para esta funcionalidad).","title":"Conversor Digital Anal\u00f3gico (DAC)"},{"location":"#driver-de-display-7-segmentos","text":"Este perif\u00e9rico s\u00f3lo est\u00e1 disponible en la versi\u00f3n 2 de la placa BEE, su circuito es el siguiente: Como vemos, se compone principalmente de dos componentes: Un registro de desplazamiento 74AHC_AHCT595 Un display de 7 segmentos (m\u00e1s un punto decimal). El 74AHC595 utiliza doble buffer. Tiene un registro de desplazamiento que permite cargar en 8 ciclos de la se\u00f1al SRCLK un valor de 8 bits enviado en serie por la entrada serie (SER), y un registro de salida, que mantiene inalterado un valor de 8 bits mientras se carga un nuevo valor en el registro de desplazamiento. El valor almacenado en el registro de salida (QA-QH) se conecta a las entradas del display 7 segmentos (A-G, DP) a trav\u00e9s de 8 resistencias de 220 ohmios para limitar la corriente. El display mostrar\u00e1 el digito codificado en estos 8 bits (cada bit indica si se debe encender o no uno de los segmentos). El display es activo en alta, es decir, que un 1 en la entrada A indica que debe encenderse el segmento A (ve el s\u00edmbolo del esquem\u00e1tico), mientras que un 0 en dicha entrada indicar\u00eda que debe apagarse dicho segmento. Como la entrada de habilitaci\u00f3n de la salida (nOE) est\u00e1 conectada a GND, la salida est\u00e1 permanentemente habilitada. La se\u00f1al nSRCLR (nMR en el datasheet) permite resetear los biestables del registro de desplazamiento. Est\u00e1 conectada permanentemente a 1 (no se pueden resetear). El resto de se\u00f1ales (SER, SRCLK y RCLK) se conectan a la tira de pines J6, y podemos usar cables de puente dupont para conectarlos a los pines GPIO que queramos. El funcionamiento del dispositivo es como sigue. Los bits se van cargando en serie en el registro de desplazamiento. Cuando generamos un pulso en la se\u00f1al SRCLK, el valor en la entrada serie SER se carge en el biestable 0, el biestable 1 cargar\u00e1 el valor que ten\u00eda antes el biestable 0, el biestable 2 el valor que ten\u00eda antes el 1 y as\u00ed sucesivamente. La salida QH' nos permite conectar en serie otro 74H595 para almacenar valores de m\u00e1s de 8 bits. Cuando tengamos el valor completo cargado (8 bits), podemos generar un pulso en la se\u00f1al RCLK para cargar los biestables del registro de salida con el contenido almacenado en el registro de desplazamiento. Esto nos permite ir cargando un nuevo valor sin alterar lo que se est\u00e1 mostrando en el display 7 segmentos, mostrando de golpe el nuevo valor cuando se hayan cargado los 8 nuevos bits.","title":"Driver de display 7 segmentos"},{"location":"#conector-uart","text":"Se trata de una tira de pines (J13) con la configuraci\u00f3n adecuada para que podamos conectar un cable FTDI-232-R y usar el puerto serie de la mini-uart que incorpora la raspberry pi, ideal para proporcionar un terminal serie a cualquier aplicaci\u00f3n que corra en el microcontrolador.","title":"Conector UART"},{"location":"#conector-jtag","text":"Se trata de una tira de pines compatible un conector JTAG de 20 pines. La raspberry pi incorpora un controlado JTAG de depuraci\u00f3n en circuito. Se puede usar este controlador si se configura correctamente la funcionalidad de los pines BCM4, BCM22-25 y BCM27, que est\u00e1n rutados a las posiciones adecuadas de la tira de pines J5. Para usar el depurador debemos conectar un dongle JTAG de depuraci\u00f3n a J5, y usar un software como OpenOCD para establecer una sesi\u00f3n de depuraci\u00f3n.","title":"Conector JTAG"},{"location":"control_servomotores/","text":"Control de servomotores con PWM \u00b6 En esta pr\u00e1ctica vamos a aprender como controlar un servomotor usando el generador de PWM de la Raspberry Pi, la placa BEE y la librer\u00eda wiringpi. Esta pr\u00e1ctica es parte de la asignatura de Rob\u00f3tica y Mecatr\u00f3nica del M\u00e1ster en Nuevas Tecnolog\u00edas Electr\u00f3nicas y Fot\u00f3nicas de la Universidad Complutense de Madrid. Es parte de un proyecto donde los alumnos crean desde cero su propia plataforma rob\u00f3tica m\u00f3vil. Servomotores \u00b6 Para la elecci\u00f3n de los servomotores se elegir\u00e1n dos servomotores del tipo Parallax Continous Rotation Servo. Estos servomotores tienen una velocidad m\u00e1xima de 50rpm son bidireccionales y de sencilla implementaci\u00f3n. La informaci\u00f3n proporcionada por el fabricante se puede consultar en la hoja de referencia disponible online ( Aqui ). Se\u00f1al PWM \u00b6 Existen dos posibilidades de generar una se\u00f1al PWM usando la Raspberry Pi. La primera consiste en utilizar implementaciones software de librer\u00edas como WiringPi en donde el sistema operativo de la raspberry se utiliza para generar pulsos PWM. Este m\u00e9todo es propenso a errores de precisi\u00f3n debido a que el proceso debe compartir recursos con el resto de procesos de la Raspberry Pi. La segunda se basa en utilizar la implementaci\u00f3n hardware de la se\u00f1al PWM de la que dispone la Raspberry Pi. Este m\u00e9todo consiste en el uso de un reloj externo espec\u00edfico para la generaci\u00f3n de esta se\u00f1al. Al no depender del sistema operativo este m\u00e9todo suele ser mucho m\u00e1s preciso y el que se recomienda usar para el control de motores. En esta pr\u00e1ctica explicaremos la implementaci\u00f3n de la se\u00f1al usando el PWM hardware. PWM hardware \u00b6 Lo primero que hay que saber para trabajar con la se\u00f1al de PWM, es que el reloj disponible en la Raspberry Pi funciona a una frecuencia constante de 19.2 Mhz. Nuestro primero objetivo es adaptar esta frecuencia a la frecuencia de trabajo de nuestros servos. En nuestro caso, echando un vistazo al dataseet de los motores, vemos que el fabricante recomienda un periodo entre pulsos de 20ms. Esto equivale a una frecuencia de trabajo aproximada de 50Hz. Para definir esta frecuencia en la Raspberry Pi disponemos de dos par\u00e1metros: el divisor y el rango. El divisor nos permite escalar la frecuencia de trabajo del reloj. El rango nos define la resoluci\u00f3n de cada periodo de PWM y por lo tanto tambi\u00e9n la frecuencia m\u00e1xima que podremos conseguir. Configuraci\u00f3n de la Frecuencia PWM \u00b6 Para ajustar la frecuencia de la se\u00f1al PWM, utilizamos dos par\u00e1metros: Divisor ( D ) : Reduce la frecuencia del reloj de 19.2 MHz. Rango ( R ) : Define la resoluci\u00f3n del ciclo de trabajo y afecta la frecuencia resultante. La ecuaci\u00f3n para calcular la frecuencia PWM es: f_PWM = 19.2 MHz / (D \u00d7 R) Ejemplo para obtener 50 Hz : Divisor ( D ) = 1920 Rango ( R ) = 200 C\u00e1lculo: f_PWM = 19.2 MHz / (192 \u00d7 2000) = 50 Hz C\u00f3digo \u00b6 Para implementar la se\u00f1al PWM con la frecuencia indicada en el apartado anterior se puede utilizar el siguiente c\u00f3digo base. Este c\u00f3digo utiliza la biblioteca WiringPi para generar se\u00f1ales PWM y controlar la intensidad de giro de dos motores conectados a la Raspberry Pi. C\u00f3digo en C: \u00b6 #include <wiringPi.h> #include <stdio.h> #include <stdlib.h> // Definici\u00f3n de pines PWM seg\u00fan WiringPi const int PWM_pin_izda = 1 ; // Rueda izquierda (GPIO1 rasPi, BCM18/PWM0 en BEE) const int PWM_pin_dcha = 23 ; // Rueda derecha (GPIO23 raspi, BCM13/PWM1 en BEE) int main ( void ) { int intensidad ; int rango = 200 ; // Rango del PWM (valor m\u00e1ximo de duty cycle) int divisor = 1920 ; // Factor de divisi\u00f3n del reloj PWM // Inicializaci\u00f3n de WiringPi if ( wiringPiSetup () == -1 ) exit ( 1 ); // Configuraci\u00f3n del pin de salida PWM pinMode ( PWM_pin_dcha , PWM_OUTPUT ); pinMode ( PWM_pin_izda , PWM_OUTPUT ); // Configuraci\u00f3n del PWM por hardware pwmSetRange ( rango ); pwmSetClock ( divisor ); pwmSetMode ( PWM_MODE_MS ); while ( 1 ) { // Secuencia de movimiento con diferentes valores de PWM pwmWrite ( PWM_pin_dcha , 13 ); pwmWrite ( PWM_pin_izda , 17 ); printf ( \"Moviendo a 17 \\n \" ); getchar (); pwmWrite ( PWM_pin_dcha , 8 ); pwmWrite ( PWM_pin_izda , 80 ); printf ( \"Moviendo a 80 \\n \" ); getchar (); pwmWrite ( PWM_pin_dcha , 6 ); pwmWrite ( PWM_pin_izda , 130 ); printf ( \"Moviendo a 130 \\n \" ); getchar (); pwmWrite ( PWM_pin_dcha , 1 ); pwmWrite ( PWM_pin_izda , 190 ); printf ( \"Moviendo a 190 \\n \" ); getchar (); // Detener motores pwmWrite ( PWM_pin_dcha , 0 ); pwmWrite ( PWM_pin_izda , 0 ); getchar (); // Variaci\u00f3n gradual de la intensidad de PWM for ( intensidad = 0 ; intensidad < rango ; ++ intensidad ) { pwmWrite ( PWM_pin_dcha , intensidad ); delay ( 100 ); printf ( \"Intensidad: %d \\n \" , intensidad ); } delay ( 1 ); for ( intensidad = rango ; intensidad >= 0 ; -- intensidad ) { pwmWrite ( PWM_pin_dcha , intensidad ); delay ( 100 ); printf ( \"Intensidad: %d \\n \" , intensidad ); } delay ( 1 ); } } En este c\u00f3digo se realizan los siguientes pasos: 1. Se configura WiringPi para utilizar PWM por hardware. 2. Se definen los pines PWM para controlar dos ruedas. 3. Se establece un rango de 200 y un divisor de reloj de 1920. 4. En el bucle principal, se generan diferentes valores de PWM para simular movimientos de los motores cambiando cada valor con una pulsaci\u00f3n de teclado. 5. Luego, se realiza una variaci\u00f3n gradual de la intensidad de la se\u00f1al PWM. Conexiones con la placa BEE \u00b6 Una vez tenemos implementado el c\u00f3digo lo \u00fanico que nos quedar\u00eda ser\u00eda realizar las conexiones correspondientes entre la placa BEE y los servomotores para probar el movimiento de los mismos. La Raspberry Pi dispone de dos salidas PWM hardware correspondientes con los pines GPIO 1 y GPIO 23. Estos pines se corresponden en la placa BEE con los pines BCM18/PWM0 (rojo en la imagen de abajo) y BCM13/PWM1 (verde en la imagen de abajo) correspondientemente. A estos pines deberemos conectar el cable de control (cable blanco) de cada motor. Siguiendo lo especificado en el c\u00f3digo el motor izquierdo deber\u00e1 conectarse al PWM0 y el derecho al PWM1. Una vez hecho esto solo nos quedar\u00eda alimentar los servomotores a 5V siguiendo lo especificado por el fabricante. Para ello podemos usar una placa entrenador y una fuente de alimentaci\u00f3n externa (por ejemplo una power bank). De esta forma podemos crear una v\u00eda de alimentaci\u00f3n en en el entrenador en donde conectaremos nuestros motores. Por \u00faltimo, seguiremos el mismo procedimiento para las tierras. En este caso tendremos que asegurarnos que las tierras de ambos motores y la tierra de la placa BEE (conector azul en la imagen, entre otros) est\u00e1n conectadas al mismo punto para tener una referencia com\u00fan.","title":"Control de servomotores con PWM"},{"location":"control_servomotores/#control-de-servomotores-con-pwm","text":"En esta pr\u00e1ctica vamos a aprender como controlar un servomotor usando el generador de PWM de la Raspberry Pi, la placa BEE y la librer\u00eda wiringpi. Esta pr\u00e1ctica es parte de la asignatura de Rob\u00f3tica y Mecatr\u00f3nica del M\u00e1ster en Nuevas Tecnolog\u00edas Electr\u00f3nicas y Fot\u00f3nicas de la Universidad Complutense de Madrid. Es parte de un proyecto donde los alumnos crean desde cero su propia plataforma rob\u00f3tica m\u00f3vil.","title":"Control de servomotores con PWM"},{"location":"control_servomotores/#servomotores","text":"Para la elecci\u00f3n de los servomotores se elegir\u00e1n dos servomotores del tipo Parallax Continous Rotation Servo. Estos servomotores tienen una velocidad m\u00e1xima de 50rpm son bidireccionales y de sencilla implementaci\u00f3n. La informaci\u00f3n proporcionada por el fabricante se puede consultar en la hoja de referencia disponible online ( Aqui ).","title":"Servomotores"},{"location":"control_servomotores/#senal-pwm","text":"Existen dos posibilidades de generar una se\u00f1al PWM usando la Raspberry Pi. La primera consiste en utilizar implementaciones software de librer\u00edas como WiringPi en donde el sistema operativo de la raspberry se utiliza para generar pulsos PWM. Este m\u00e9todo es propenso a errores de precisi\u00f3n debido a que el proceso debe compartir recursos con el resto de procesos de la Raspberry Pi. La segunda se basa en utilizar la implementaci\u00f3n hardware de la se\u00f1al PWM de la que dispone la Raspberry Pi. Este m\u00e9todo consiste en el uso de un reloj externo espec\u00edfico para la generaci\u00f3n de esta se\u00f1al. Al no depender del sistema operativo este m\u00e9todo suele ser mucho m\u00e1s preciso y el que se recomienda usar para el control de motores. En esta pr\u00e1ctica explicaremos la implementaci\u00f3n de la se\u00f1al usando el PWM hardware.","title":"Se\u00f1al PWM"},{"location":"control_servomotores/#pwm-hardware","text":"Lo primero que hay que saber para trabajar con la se\u00f1al de PWM, es que el reloj disponible en la Raspberry Pi funciona a una frecuencia constante de 19.2 Mhz. Nuestro primero objetivo es adaptar esta frecuencia a la frecuencia de trabajo de nuestros servos. En nuestro caso, echando un vistazo al dataseet de los motores, vemos que el fabricante recomienda un periodo entre pulsos de 20ms. Esto equivale a una frecuencia de trabajo aproximada de 50Hz. Para definir esta frecuencia en la Raspberry Pi disponemos de dos par\u00e1metros: el divisor y el rango. El divisor nos permite escalar la frecuencia de trabajo del reloj. El rango nos define la resoluci\u00f3n de cada periodo de PWM y por lo tanto tambi\u00e9n la frecuencia m\u00e1xima que podremos conseguir.","title":"PWM hardware"},{"location":"control_servomotores/#configuracion-de-la-frecuencia-pwm","text":"Para ajustar la frecuencia de la se\u00f1al PWM, utilizamos dos par\u00e1metros: Divisor ( D ) : Reduce la frecuencia del reloj de 19.2 MHz. Rango ( R ) : Define la resoluci\u00f3n del ciclo de trabajo y afecta la frecuencia resultante. La ecuaci\u00f3n para calcular la frecuencia PWM es: f_PWM = 19.2 MHz / (D \u00d7 R) Ejemplo para obtener 50 Hz : Divisor ( D ) = 1920 Rango ( R ) = 200 C\u00e1lculo: f_PWM = 19.2 MHz / (192 \u00d7 2000) = 50 Hz","title":"Configuraci\u00f3n de la Frecuencia PWM"},{"location":"control_servomotores/#codigo","text":"Para implementar la se\u00f1al PWM con la frecuencia indicada en el apartado anterior se puede utilizar el siguiente c\u00f3digo base. Este c\u00f3digo utiliza la biblioteca WiringPi para generar se\u00f1ales PWM y controlar la intensidad de giro de dos motores conectados a la Raspberry Pi.","title":"C\u00f3digo"},{"location":"control_servomotores/#conexiones-con-la-placa-bee","text":"Una vez tenemos implementado el c\u00f3digo lo \u00fanico que nos quedar\u00eda ser\u00eda realizar las conexiones correspondientes entre la placa BEE y los servomotores para probar el movimiento de los mismos. La Raspberry Pi dispone de dos salidas PWM hardware correspondientes con los pines GPIO 1 y GPIO 23. Estos pines se corresponden en la placa BEE con los pines BCM18/PWM0 (rojo en la imagen de abajo) y BCM13/PWM1 (verde en la imagen de abajo) correspondientemente. A estos pines deberemos conectar el cable de control (cable blanco) de cada motor. Siguiendo lo especificado en el c\u00f3digo el motor izquierdo deber\u00e1 conectarse al PWM0 y el derecho al PWM1. Una vez hecho esto solo nos quedar\u00eda alimentar los servomotores a 5V siguiendo lo especificado por el fabricante. Para ello podemos usar una placa entrenador y una fuente de alimentaci\u00f3n externa (por ejemplo una power bank). De esta forma podemos crear una v\u00eda de alimentaci\u00f3n en en el entrenador en donde conectaremos nuestros motores. Por \u00faltimo, seguiremos el mismo procedimiento para las tierras. En este caso tendremos que asegurarnos que las tierras de ambos motores y la tierra de la placa BEE (conector azul en la imagen, entre otros) est\u00e1n conectadas al mismo punto para tener una referencia com\u00fan.","title":"Conexiones con la placa BEE"},{"location":"gpio_linux/","text":"Control GPIO en Linux \u00b6 En esta pr\u00e1ctica utilizaremos los drivers que proporciona linux para controlar el GPIO. Puedes hacer esta pr\u00e1ctica si tienes una raspberry-pi con Raspbian, consiguiendo manejar dispositivos sencillos, como los pulsadores y los leds que incorpora la placa BEE, desde un programa de usuario escrito en C. Introducci\u00f3n \u00b6 Linux expone los controladores del GPIO como dispositivos orientados a caracteres /dev/gpiochip# . Usar estos dispositivos ofrece las siguientes ventajas: Portabilidad: el c\u00f3digo es pr\u00e1cticamente independiente del hardware, a excepci\u00f3n de los GPIOS/pines que hay que usar No requiere privilegios de root Ofrece un mecanismo para tratar eventos hw desde el espacio de usuario Mantiene la sem\u00e1ntica UNIX tradicional de todo es un fichero Como con cualquier otro dispositivo, podemos trabajar con el gpio como si fuese un fichero, utilizando las llamadas al sistema open() , read() , write() , ioctl() , close() . En esta pr\u00e1ctica usaremos la versi\u00f3n 2 del ABI, la 1 se considera obsoleta ( deprecated ). La fuente m\u00e1s fiable de referencia/documentaci\u00f3n es el propio fichero de cabecera /usr/include/linux/gpio.h . Utilidades de l\u00ednea de comandos \u00b6 La librer\u00eda libgpiod nos ofrece unos programas de ejemplo que podemos utilizar como utilidades de l\u00ednea de comandos para interactuar con los controladores de GPIO. Para disponer de estas herramientas debemos instalar algunos paquetes de raspbian: sudo apt install gpiod libgpiod-dev libgpiod-doc Una vez instalados estos paquetes tendremos disponibles las utilidades descritas en las siguientes secciones. gpiodetect \u00b6 Esta utilidad nos da una lista de los dispositivos de caracteres para control del gpio disponibles en nuestra plataforma: pi@raspberrypi:~ $ gpiodetect gpiochip0 [ pinctrl-bcm2835 ] ( 54 lines ) gpiochip1 [ brcmvirt-gpio ] ( 2 lines ) gpiochip2 [ raspberrypi-exp-gpio ] ( 8 lines ) pi@raspberrypi:~ $ gpioinfo \u00b6 Esta utilidad lista los pines controlados por uno de los controladores: pi@raspberrypi:~ $ gpioinfo gpiochip0 gpiochip0 - 54 lines: line 0 : unnamed unused input active-high line 1 : unnamed unused input active-high line 2 : unnamed unused input active-high line 3 : unnamed unused input active-high ... pi@raspberrypi:~ $ gpiofind \u00b6 Utilidad que nos da el n\u00famero de l\u00ednea de gpio para l\u00edneas identificadas con un nombre en el device-tree gpioset \u00b6 Utilidad que permite asignar un valor a un conjunto de l\u00edneas del gpio mientras ejecuta el comando. Con -m modo podemos configurar lo que hace el comando tras dar el valor a las l\u00edneas. Los posibles modos son: wait: espera a que el usuario pulse enter exit: termina inmediatamente time: duerme por el periodo de tiempo especificado con el flag -s o el flag -u signal: espera hasta recibir SIGINT o SIGTERM Por ejemplo, para encender 3 leds conectados a los pines 20, 21 y 26, hasta que el usuario pulse enter: pi@raspberrypi:~ $ gpioset -m wait 0 20 = 1 21 = 1 26 = 1 pi@raspberrypi:~ $ El siguiente script es un ejemplo de uso de gpioset que hace oscilar una luz entre tres leds. #!/bin/bash ini = 0x01 dir = 0 while true do bit26 = $(( ( ini & 0 x4 ) >> 2 )) bit21 = $(( ( ini & 0 x2 ) >> 1 )) bit20 = $(( ini & 0 x1 )) gpioset -m time -s 1 0 26 = $bit26 21 = $bit21 20 = $bit20 if [ $dir -eq 0 ] ; then ini = $(( ( ini << 1) & 0x7)) else ini=$(((ini >> 1 ) & 0 x7 )) fi if [ $ini -eq 0 ] ; then dir = $(( ( dir + 1 ) & 1 )) ini = 0x2 fi done gpioget \u00b6 Esta utilidad nos da el estado actual de las l\u00edneas solicitadas en el chip de control indicado en la linea de comandos gpiomon \u00b6 Esta utilidad nos permite monitorizar el estado de unos pines. Usa la llamada al sistema poll , con las siguientes opciones: -n NUM: termina despu\u00e9s de \\texttt{NUM} eventos -s: no imprime informaci\u00f3n de evento -r: procesa s\u00f3lo eventos de flanco de subida -f: procesa s\u00f3lo eventos de flanco de bajada -F FMT: especifica el formato de salida (consulta la p\u00e1gina de manual) Por ejemplo, para monitorizar tres pulsadores conectados a las l\u00edneas 19, 6 y 5: pi@raspberrypi:~ $ gpiomon -f 0 19 6 5 event: FALLING EDGE offset: 19 timestamp: [ 2740 .887807571 ] event: FALLING EDGE offset: 6 timestamp: [ 2742 .291116096 ] event: FALLING EDGE offset: 5 timestamp: [ 2744 .609921761 ] ^Cpi@raspberrypi:~ $ Driver GPIO \u00b6 Vamos a ver c\u00f3mo podemos manejar los pines del GPIO desde un programa de usuario escrito en C utilizando el driver de GPIO proporcionado por Linux. Para ello debemos comprender qu\u00e9 son las operaciones ioctl en el est\u00e1ndar POSIX, que ser\u00e1n vitales para la comunicaci\u00f3n con el driver. Luego iremos viendo como podemos utilizar estas operaciones para interactuar con el controlador GPIO. Operaciones ioctl \u00b6 En los sistemas POSIX las operaciones sobre un dispositivo que no sean read o write se realizan con la llamada al sistema ioctl , cuyo prototipo es: int ioctl ( int fd , unsigned long request , void * argp ); d\u00f3nde: fd : descriptor de fichero devuelto por open request : petici\u00f3n de operaci\u00f3n, dependiente del dispositivo. argp : direcci\u00f3n a un buffer que depende del tipo de operaci\u00f3n. No hay un est\u00e1ndar para los c\u00f3digos de las peticiones, pero un convenio que es ampliamente usado es el siguiente: Dos bits para indicar la direcci\u00f3n: 00 (nada), 01 (lectura), 10 (escritura) y 11 (lectura y escritura). 14 bits que indican el tama\u00f1o del dato pasado como argumento 8 bits de tipo de operaci\u00f3n 8 bits de n\u00famero de operaci\u00f3n El sistema define unas macros para ayudar a la codificaci\u00f3n de estas peticiones: _IOR(type, nr, arg), _IOW(type, nr, arg), _IOWR(type, nr, arg) e _IO(type, nr). Obtener informaci\u00f3n del controlador GPIO \u00b6 Para obtener informaci\u00f3n del controlador podemos utilizar la petici\u00f3n ioctl GPIO_GET_CHIP_INFO, que requiere como par\u00e1metro adicional la direcci\u00f3n de una estructura del siguiente tipo: struct gpiochip_info { char name [ 32 ]; /* Nombre del controlador en el kernel */ char label [ 32 ]; /* Nombre funcional, de producto */ __u32 lines ; /* n\u00famero de l\u00edneas que maneja */ }; Un ejemplo de uso ser\u00eda el siguiente: int fd ; struct gpiochip_info info ; fd = open ( \"/dev/gpiochip0\" , O_RDONLY ); ioctl ( fd , GPIO_GET_CHIPINFO_IOCTL , & info ); close ( fd ); printf ( \"label: %s \\n \" , info . label ); printf ( \"name: %s \\n \" , info . name ); printf ( \"number of lines: %u \\n \" , info . lines ); Examinar el ejemplo gpio_info y comprobar su funcionamiento. Pines de entrada y salida \u00b6 El driver de GPIO nos permite agrupar pines en l\u00edneas , que pueden recibir un nombre l\u00f3gico definido por el programador(por ejemplo sevenseg). Para crear una de estas l\u00edneas de pines , una vez abierto el dispositivo, debemos hacer una petici\u00f3n ioctl de tipo line_request : struct gpio_v2_line_request req ; ioctl ( fd , GPIO_V2_GET_LINE_IOCTL , & req ); El registro req tiene la siguiente estructura: struct gpio_v2_line_request { __u32 offsets [ GPIO_V2_LINES_MAX ]; //pines a manejar (in) char consumer [ GPIO_MAX_NAME_SIZE ]; //nombre por usuario (in) struct gpio_v2_line_config config ; //configuraci\u00f3n (in) __u32 num_lines ; //num pines en offsets (in) __u32 event_buffer_size ; //para eventos (in) __u32 padding [ 5 ]; //no usado __s32 fd ; //fd de salida (out) }; El campo offsets debe contener los n\u00fameros de los pines que pertenecen a la l\u00ednea, indicando el n\u00famero total de pines de la l\u00ednea en num_lines . El campo config se utiliza para indicar la configuraci\u00f3n de cada uno de los pines que pertenecen a la l\u00ednea. El campo fd es de salida, en el retorno de la llamada ioctl contendr\u00e1 un nuevo descriptor de fichero que podemos usar para operar sobre los pines de la l\u00ednea (leer, escribir, etc). El campo config tiene la siguiente estructura: struct gpio_v2_line_config { __aligned_u64 flags ; // flags por defecto para los pines __u32 num_attrs ; // n\u00famero de atributos en attrs __u32 padding [ 5 ]; // no usado struct gpio_v2_line_config_attribute attrs [ GPIO_V2_LINE_NUM_ATTRS_MAX ]; // array de atributos }; El campo flags permite establecer una configuraci\u00f3n por defecto para los pines de la l\u00ednes. Se trata de una m\u00e1scara de bits a la que se le debe asignar una combinaci\u00f3n, con or a nivel de bit (operadores bitwise ), de las siguientes macros: GPIO_V2_LINE_FLAG_USED GPIO_V2_LINE_FLAG_ACTIVE_LOW GPIO_V2_LINE_FLAG_INPUT GPIO_V2_LINE_FLAG_OUTPUT GPIO_V2_LINE_FLAG_EDGE_RISING GPIO_V2_LINE_FLAG_EDGE_FALLING GPIO_V2_LINE_FLAG_OPEN_DRAIN GPIO_V2_LINE_FLAG_OPEN_SOURCE GPIO_V2_LINE_FLAG_BIAS_PULL_UP GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN GPIO_V2_LINE_FLAG_BIAS_DISABLED Los atributos de la l\u00ednea nos permiten cambiar la configuraci\u00f3n de un subconjunto de los pines de la l\u00ednea o indicar informaci\u00f3n complementaria a los flags necesaria para completar su configuraci\u00f3n (por ejemplo valor del pin en pines de salida). El campo attrs es un array de atributos definidos para la l\u00ednea, indicando el n\u00famero de atributos definidos en el campo num_attrs . Cada atributo se define con la siguiente estructura: struct gpio_v2_line_config_attribute { struct gpio_v2_line_attribute attr ; //atributo __aligned_u64 mask ; //pines a los que aplica }; El campo mask indica los pines de la linea afectados por el atributo, d\u00f3nde cada bit corresponde a un \u00edndice del array de offsets de la estructura struct gpio_v2_line_request . El campo attr se representa con la siguiente estructura: struct gpio_v2_line_attribute { __u32 id ; //GPIO_V2_LINE_ATTR_ID_{FLAGS,OUTPUT_VALUES,DEBOUNCE} __u32 padding ; union { __aligned_u64 flags ; // flag __aligned_u64 values ; // valor ini. 1-activo, 0-inactivo __u32 debounce_period_us ; // tiempo de debounce }; }; El campo id indica el tipo de atributo, y su valor determina el campo de la uni\u00f3n que contiene la informaci\u00f3n correspondiente: GPIO_V2_LINE_ATTR_ID_FLAGS : aplicable a cualquier grupo de pines. El campo flags de la uni\u00f3n indica una configuraci\u00f3n alternativa para este grupo de pines. GPIO_V2_LINE_ATTR_ID_OUTPUT : aplicable a grupos de pines configurados como salida (por defecto o con atributos anteriores). El campo values de la uni\u00f3n indica el valor que se asigna a los pines afectados. GPIO_V2_LINE_ATTR_ID_DEBOUNCE : aplicable a pines configurados como entrada (por defecto o con atributos anteriores). El campo debounce_period_us de la uni\u00f3n indica el periodo en microsegundos con el que se muestrea el pin para eliminar rebotes (cualquier cambio m\u00e1s r\u00e1pido es filtrado). Para leer o escribir en los pines de la l\u00ednea debemos realizaremos nuevas operaciones ioctl sobre el descriptor de fichero inicializado en la operaci\u00f3n ioctl line_request . Para escribir un valor en pines configurados como salida usaremos la operaci\u00f3n ioctl GPIO_V2_LINE_SET_VALUES_IOCTL : struct gpio_v2_line_values values ; ... ioctl ( req . fd , GPIO_V2_LINE_SET_VALUES_IOCTL , & values ); mientras que para leer utilizaremos la operaci\u00f3n GPIO_V2_LINE_GET_VALUES_IOCTL : struct gpio_v2_line_values values ; ... ioctl ( req . fd , GPIO_V2_LINE_GET_VALUES_IOCTL , & values ); En ambos casos values tiene la siguiente estructura: struct gpio_v2_line_values { __aligned_u64 bits ; //m\u00e1scara de bits con el valor los pines __aligned_u64 mask ; //m\u00e1scara de bits que leer/escribir }; Cada bit de ambos campos se refiere a una de las posiciones del campo offsets de la l\u00ednea. Veamos un ejemplo. El programa gpio_blink_v2.c usa el driver de caracteres del GPIO para hacer parpadear los leds que se indican por la l\u00ednea de comandos, con un periodo de 0.5Hz (1 s encendidos, 1 s apagados). Podemos probar este programa en la raspberry, conectando tres pines a los tres leds de la placa BEE. Como ejercicio, se propone al estudiante modificar el c\u00f3digo del programa anterior para que de la sensaci\u00f3n de que una luz va pasando de un led a otro, dando la vuelta cuando llegue a los extremos. Eventos en pines de entrada \u00b6 El driver del GPIO convierte las interrupciones en los pines del GPIO en eventos software que se insertan en el descriptor de fichero (fd) asociado a la linea. Esto permite: Usar programaci\u00f3n multihilo, destiando un hilo a atender los eventos de entrada de la l\u00ednea. Usar mecanismos de multiplexaci\u00f3n de entrada/salida para monitorizar varios descriptores/l\u00edneas (uando select, poll o epoll). La detecci\u00f3n de eventos debe ser habilitada en los pines de entrada, a\u00f1adiendo uno los flags GPIO_V2_LINE_FLAG_EDGE_RISING y/o GPIO_V2_LINE_FLAG_EDGE_FALLING . Adem\u00e1s, se puede utilizar el atributo GPIO_V2_LINE_ATTR_ID_DEBOUNCE para configurar en el pin una eliminaci\u00f3n de rebotes. Por cada evento podremos leer del descriptor de fichero una estructura del tipo: struct gpio_v2_line_event { __aligned_u64 timestamp_ns ; //Marca de tiempo del evento __u32 id ; //Tipo de evento __u32 offset ; //offset del pin correspondiente __u32 seqno ; //n\u00fam. de secuencia global __u32 line_seqno ; //n\u00fam. de secuencia en este pin __u32 padding [ 6 ]; //reservado }; d\u00f3nde el campo id nos identifica el evento detectado mientras que offset identifica el pin en el que se producido el evento. El campo seqno nos indica el \u00f3rden global en el que el evento se ha detectado, mientras que line_seqno nos indica el \u00f3rden entre los eventos de la l\u00ednea. El programa de ejemplo gpio_toggle.c usa el driver GPIO para controlar el estado de unos leds con unos pulsadores. El programa recibe como par\u00e1metros una lista con un n\u00famero par de pines. La primera mitad se configuran como pines entradas, activando la detecci\u00f3n de eventos por flancos de bajada, con un debounce de 10 ms. La segunda mitad se configuran como pines de salida, inicialmente activos (a 1). El programa se queda esperando por eventos de flanco de bajada en las entradas. Cuando se recibe un evento, se conmuta el estado del pin de salida correspondiente. El programa puede probarse conectando los 3 leds de la placa de expansi\u00f3n a 3 gpios (salidas) y los pulsadores a otros 3 gpios (entradas). Como ejercicio se propone al estudiante modificar el programa para que los pulsadores determinen si los leds parpadean o no. Es decir, inicialmente estar\u00e1n los 3 leds parpadeando a una frecuencia fija (por ejemplo 0.5 Hz), si se pulsa uno de los pulsadores el led correspondiente se quedar\u00e1 apagado. Si se vuelve a pulsar, el led volver\u00e1 a parpadear s\u00edncronamente con el resto. El dispositivo de caracteres GPIO soporta algunas operaciones ioctl adicionales: GPIO_V2_GET_LINEINFO_WATCH_IOCTL , monitorizar cambios en un l\u00ednea: Se pasa un argumento struct gpio_v2_line_info Se indican las l\u00edneas que se desean monitorizar Los eventos de cambio se obtinen del fd del gpiochip correspondiente GPIO_V2_LINE_SET_CONFIG_IOCTL , cambiar la configuraci\u00f3n de una l\u00ednea: Se pasa un argumento struct gpio_v2_line_config No es necesario liberar la l\u00ednea antes GPIO mapeado en memoria \u00b6 Linux incorpora el dispositivo /dev/mem que permite acceder a la memoria f\u00edsica del computador. El offset en este fichero es interpretado como una direcci\u00f3n f\u00edsica y el driver controla los rangos accesibles (configurable con la opci\u00f3n de compilaci\u00f3n del kernel CONFIG_STRICT_DEVMEM ) en funci\u00f3n de la arquitectura del computador. S\u00f3lo root tiene acceso a este dispositvo, ya que usarlo implica saltarse pr\u00e1cticamente todos los mecanismos de control y las abstracciones del sistema operativo. Raspbian incorpora tambi\u00e9n el dispositivo /dev/gpiomem, que es un dispositivo que permite el acceso al rango de direcciones f\u00edsicas controlado por el GPIO. Todos los usuarios que pertenezcan al grupo gpio tienen acceso a este fichero, adem\u00e1s de root. Este fichero permite acceder en crudo a los registros del gpio puenteando al driver gpio. Aunque no se recomienda su uso (mejor utilizar el driver gpio), puede ser \u00fatil usarlo para estudiar el funcionamiento del controlador gpio. Como ejemplo vamos a ver c\u00f3mo podemos implementar el ejemplo gpio_blink utilizando este dispositivo. Para ello primero debemos revisar la documentaci\u00f3n de Broadcom para ver c\u00f3mo funciona el controlador GPIO. Resumimos aqu\u00ed los aspectos m\u00e1s destacados. En el controlador GPIO la funci\u00f3n de cada pin se configura en los registros de selecci\u00f3n GPFSELn : Registro Dir. F\u00edsica Pines GPI GPFSEL0 0x3F200000 GPIO0 - GPIO9 GPFSEL1 0x3F200004 GPIO10 - GPIO19 GPFSEL2 0x3F200008 GPIO20 - GPIO29 GPFSEL3 0x3F20000C GPIO30 - GPIO39 GPFSEL4 0x3F200010 GPIO40 - GPIO49 GPFSEL5 0x3F200014 GPIO50 - GPIO53 Se utilizan tres bits por pin, con la codificaci\u00f3n indicada en la siguiente tabla: Funci\u00f3n (seg\u00fan doc. Broadcom ) 000 Entrada 001 Salida 100 Funci\u00f3n alternativa 0 101 Funci\u00f3n alternativa 1 110 Funci\u00f3n alternativa 2 111 Funci\u00f3n alternativa 3 011 Funci\u00f3n alternativa 4 010 Funci\u00f3n alternativa 5 Para operar sobre los pines de salida hay dos pares de registros: Valor Pin Registro Direcci\u00f3n (ARM) 1 0-31 GPFSET0 0x3F20001C 1 32-53 GPFSET1 0x3F200020 0 0-31 GPFCLR0 0x3F200028 0 32-53 GPFCLR1 0x3F20002C As\u00ed, para poner a 1 un pin de salida debemos escribir un 1 en la posici\u00f3n correspondiente del registro GPSET que corresponda. Y para poner dicho pin a 0 deberemos escribir un 1 en el la misma posici\u00f3n del registro GPCLR correspondiente. Escribir un 0 no modifica el valor del pin. El programa gpio_blink_mem proyectan el dispositivo /dev/gpiomem en el mapa virtual de memoria del proceso utilizando mmap, con el fin de acceder dir\u00e9ctamente a los registros del controlador. Se utilizan unos arrays para almacenar los offsets de los registros: uint32_t gpfsel_offset [] = { 0x00 , 0x04 , 0x08 , 0x0C , 0x10 , 0x14 }; uint32_t gpfset_offset [] = { 0x1C , 0x20 }; uint32_t gpfclr_offset [] = { 0x28 , 0x2C }; Estos offsets se suman a la direcci\u00f3n base que es un puntero a byte, convirtiendo el resultado a un puntero a uint32_t por conveniencia: uint8_t * gpiomem ; volatile uint32_t * fpsel ; ... gpiomem = mmap ( NULL , 4096 , PROT_READ | PROT_WRITE , MAP_SHARED , fd , 0x3f200000 ); ... n = get_int ( argv [ i + 1 ], 10 , desc ); fpsel = ( uint32_t * )( gpiomem + gpfsel_offset [ n / 10 ]); Las escrituras en los registros se hacen desreferenciado los punteros, que se han declarado como vol\u00e1tiles: * fpsel |= ( 0x1 << ( n % 10 ) * 3 ); Aunque este mecanismo permite controlar los gpios, debemos notar que el c\u00f3digo es muy dependiente del hardware, utilizando offsets y selecciones de registros en funci\u00f3n del n\u00famero de pin o la operaci\u00f3n a realizar; y escogiendo adecuadamente los c\u00f3digos a escribir en los registros siguiendo la documentaci\u00f3n del fabricante del SoC. Notemos adem\u00e1s que el estado de los leds se mantiene cuando el programa termina, y puede entrar en conflicto con cualquier otro proceso que use el driver del sistema para el gpio. Este c\u00f3digo es mucho m\u00e1s propenso a errores que no ser\u00e1n identificados por el sistema (no hay valor de retorno de error). La librer\u00eda bcm2835 usa entrada salida mapeada en memoria y ofrece un API m\u00e1s sencillo y pr\u00e1ctico para el manejo de los controladores de la raspberry pi, pero sigue salt\u00e1ndose todos los controles del sistema operativo, por lo que resulta m\u00e1s adecuando aprender a utilizar el driver GPIO estudiado en la secci\u00f3n anterior.","title":"Control GPIO en Linux"},{"location":"gpio_linux/#control-gpio-en-linux","text":"En esta pr\u00e1ctica utilizaremos los drivers que proporciona linux para controlar el GPIO. Puedes hacer esta pr\u00e1ctica si tienes una raspberry-pi con Raspbian, consiguiendo manejar dispositivos sencillos, como los pulsadores y los leds que incorpora la placa BEE, desde un programa de usuario escrito en C.","title":"Control GPIO en Linux"},{"location":"gpio_linux/#introduccion","text":"Linux expone los controladores del GPIO como dispositivos orientados a caracteres /dev/gpiochip# . Usar estos dispositivos ofrece las siguientes ventajas: Portabilidad: el c\u00f3digo es pr\u00e1cticamente independiente del hardware, a excepci\u00f3n de los GPIOS/pines que hay que usar No requiere privilegios de root Ofrece un mecanismo para tratar eventos hw desde el espacio de usuario Mantiene la sem\u00e1ntica UNIX tradicional de todo es un fichero Como con cualquier otro dispositivo, podemos trabajar con el gpio como si fuese un fichero, utilizando las llamadas al sistema open() , read() , write() , ioctl() , close() . En esta pr\u00e1ctica usaremos la versi\u00f3n 2 del ABI, la 1 se considera obsoleta ( deprecated ). La fuente m\u00e1s fiable de referencia/documentaci\u00f3n es el propio fichero de cabecera /usr/include/linux/gpio.h .","title":"Introducci\u00f3n"},{"location":"gpio_linux/#utilidades-de-linea-de-comandos","text":"La librer\u00eda libgpiod nos ofrece unos programas de ejemplo que podemos utilizar como utilidades de l\u00ednea de comandos para interactuar con los controladores de GPIO. Para disponer de estas herramientas debemos instalar algunos paquetes de raspbian: sudo apt install gpiod libgpiod-dev libgpiod-doc Una vez instalados estos paquetes tendremos disponibles las utilidades descritas en las siguientes secciones.","title":"Utilidades de l\u00ednea de comandos"},{"location":"gpio_linux/#gpiodetect","text":"Esta utilidad nos da una lista de los dispositivos de caracteres para control del gpio disponibles en nuestra plataforma: pi@raspberrypi:~ $ gpiodetect gpiochip0 [ pinctrl-bcm2835 ] ( 54 lines ) gpiochip1 [ brcmvirt-gpio ] ( 2 lines ) gpiochip2 [ raspberrypi-exp-gpio ] ( 8 lines ) pi@raspberrypi:~ $","title":"gpiodetect"},{"location":"gpio_linux/#gpioinfo","text":"Esta utilidad lista los pines controlados por uno de los controladores: pi@raspberrypi:~ $ gpioinfo gpiochip0 gpiochip0 - 54 lines: line 0 : unnamed unused input active-high line 1 : unnamed unused input active-high line 2 : unnamed unused input active-high line 3 : unnamed unused input active-high ... pi@raspberrypi:~ $","title":"gpioinfo"},{"location":"gpio_linux/#gpiofind","text":"Utilidad que nos da el n\u00famero de l\u00ednea de gpio para l\u00edneas identificadas con un nombre en el device-tree","title":"gpiofind"},{"location":"gpio_linux/#gpioset","text":"Utilidad que permite asignar un valor a un conjunto de l\u00edneas del gpio mientras ejecuta el comando. Con -m modo podemos configurar lo que hace el comando tras dar el valor a las l\u00edneas. Los posibles modos son: wait: espera a que el usuario pulse enter exit: termina inmediatamente time: duerme por el periodo de tiempo especificado con el flag -s o el flag -u signal: espera hasta recibir SIGINT o SIGTERM Por ejemplo, para encender 3 leds conectados a los pines 20, 21 y 26, hasta que el usuario pulse enter: pi@raspberrypi:~ $ gpioset -m wait 0 20 = 1 21 = 1 26 = 1 pi@raspberrypi:~ $ El siguiente script es un ejemplo de uso de gpioset que hace oscilar una luz entre tres leds. #!/bin/bash ini = 0x01 dir = 0 while true do bit26 = $(( ( ini & 0 x4 ) >> 2 )) bit21 = $(( ( ini & 0 x2 ) >> 1 )) bit20 = $(( ini & 0 x1 )) gpioset -m time -s 1 0 26 = $bit26 21 = $bit21 20 = $bit20 if [ $dir -eq 0 ] ; then ini = $(( ( ini << 1) & 0x7)) else ini=$(((ini >> 1 ) & 0 x7 )) fi if [ $ini -eq 0 ] ; then dir = $(( ( dir + 1 ) & 1 )) ini = 0x2 fi done","title":"gpioset"},{"location":"gpio_linux/#gpioget","text":"Esta utilidad nos da el estado actual de las l\u00edneas solicitadas en el chip de control indicado en la linea de comandos","title":"gpioget"},{"location":"gpio_linux/#gpiomon","text":"Esta utilidad nos permite monitorizar el estado de unos pines. Usa la llamada al sistema poll , con las siguientes opciones: -n NUM: termina despu\u00e9s de \\texttt{NUM} eventos -s: no imprime informaci\u00f3n de evento -r: procesa s\u00f3lo eventos de flanco de subida -f: procesa s\u00f3lo eventos de flanco de bajada -F FMT: especifica el formato de salida (consulta la p\u00e1gina de manual) Por ejemplo, para monitorizar tres pulsadores conectados a las l\u00edneas 19, 6 y 5: pi@raspberrypi:~ $ gpiomon -f 0 19 6 5 event: FALLING EDGE offset: 19 timestamp: [ 2740 .887807571 ] event: FALLING EDGE offset: 6 timestamp: [ 2742 .291116096 ] event: FALLING EDGE offset: 5 timestamp: [ 2744 .609921761 ] ^Cpi@raspberrypi:~ $","title":"gpiomon"},{"location":"gpio_linux/#driver-gpio","text":"Vamos a ver c\u00f3mo podemos manejar los pines del GPIO desde un programa de usuario escrito en C utilizando el driver de GPIO proporcionado por Linux. Para ello debemos comprender qu\u00e9 son las operaciones ioctl en el est\u00e1ndar POSIX, que ser\u00e1n vitales para la comunicaci\u00f3n con el driver. Luego iremos viendo como podemos utilizar estas operaciones para interactuar con el controlador GPIO.","title":"Driver GPIO"},{"location":"gpio_linux/#operaciones-ioctl","text":"En los sistemas POSIX las operaciones sobre un dispositivo que no sean read o write se realizan con la llamada al sistema ioctl , cuyo prototipo es: int ioctl ( int fd , unsigned long request , void * argp ); d\u00f3nde: fd : descriptor de fichero devuelto por open request : petici\u00f3n de operaci\u00f3n, dependiente del dispositivo. argp : direcci\u00f3n a un buffer que depende del tipo de operaci\u00f3n. No hay un est\u00e1ndar para los c\u00f3digos de las peticiones, pero un convenio que es ampliamente usado es el siguiente: Dos bits para indicar la direcci\u00f3n: 00 (nada), 01 (lectura), 10 (escritura) y 11 (lectura y escritura). 14 bits que indican el tama\u00f1o del dato pasado como argumento 8 bits de tipo de operaci\u00f3n 8 bits de n\u00famero de operaci\u00f3n El sistema define unas macros para ayudar a la codificaci\u00f3n de estas peticiones: _IOR(type, nr, arg), _IOW(type, nr, arg), _IOWR(type, nr, arg) e _IO(type, nr).","title":"Operaciones ioctl"},{"location":"gpio_linux/#obtener-informacion-del-controlador-gpio","text":"Para obtener informaci\u00f3n del controlador podemos utilizar la petici\u00f3n ioctl GPIO_GET_CHIP_INFO, que requiere como par\u00e1metro adicional la direcci\u00f3n de una estructura del siguiente tipo: struct gpiochip_info { char name [ 32 ]; /* Nombre del controlador en el kernel */ char label [ 32 ]; /* Nombre funcional, de producto */ __u32 lines ; /* n\u00famero de l\u00edneas que maneja */ }; Un ejemplo de uso ser\u00eda el siguiente: int fd ; struct gpiochip_info info ; fd = open ( \"/dev/gpiochip0\" , O_RDONLY ); ioctl ( fd , GPIO_GET_CHIPINFO_IOCTL , & info ); close ( fd ); printf ( \"label: %s \\n \" , info . label ); printf ( \"name: %s \\n \" , info . name ); printf ( \"number of lines: %u \\n \" , info . lines ); Examinar el ejemplo gpio_info y comprobar su funcionamiento.","title":"Obtener informaci\u00f3n del controlador GPIO"},{"location":"gpio_linux/#pines-de-entrada-y-salida","text":"El driver de GPIO nos permite agrupar pines en l\u00edneas , que pueden recibir un nombre l\u00f3gico definido por el programador(por ejemplo sevenseg). Para crear una de estas l\u00edneas de pines , una vez abierto el dispositivo, debemos hacer una petici\u00f3n ioctl de tipo line_request : struct gpio_v2_line_request req ; ioctl ( fd , GPIO_V2_GET_LINE_IOCTL , & req ); El registro req tiene la siguiente estructura: struct gpio_v2_line_request { __u32 offsets [ GPIO_V2_LINES_MAX ]; //pines a manejar (in) char consumer [ GPIO_MAX_NAME_SIZE ]; //nombre por usuario (in) struct gpio_v2_line_config config ; //configuraci\u00f3n (in) __u32 num_lines ; //num pines en offsets (in) __u32 event_buffer_size ; //para eventos (in) __u32 padding [ 5 ]; //no usado __s32 fd ; //fd de salida (out) }; El campo offsets debe contener los n\u00fameros de los pines que pertenecen a la l\u00ednea, indicando el n\u00famero total de pines de la l\u00ednea en num_lines . El campo config se utiliza para indicar la configuraci\u00f3n de cada uno de los pines que pertenecen a la l\u00ednea. El campo fd es de salida, en el retorno de la llamada ioctl contendr\u00e1 un nuevo descriptor de fichero que podemos usar para operar sobre los pines de la l\u00ednea (leer, escribir, etc). El campo config tiene la siguiente estructura: struct gpio_v2_line_config { __aligned_u64 flags ; // flags por defecto para los pines __u32 num_attrs ; // n\u00famero de atributos en attrs __u32 padding [ 5 ]; // no usado struct gpio_v2_line_config_attribute attrs [ GPIO_V2_LINE_NUM_ATTRS_MAX ]; // array de atributos }; El campo flags permite establecer una configuraci\u00f3n por defecto para los pines de la l\u00ednes. Se trata de una m\u00e1scara de bits a la que se le debe asignar una combinaci\u00f3n, con or a nivel de bit (operadores bitwise ), de las siguientes macros: GPIO_V2_LINE_FLAG_USED GPIO_V2_LINE_FLAG_ACTIVE_LOW GPIO_V2_LINE_FLAG_INPUT GPIO_V2_LINE_FLAG_OUTPUT GPIO_V2_LINE_FLAG_EDGE_RISING GPIO_V2_LINE_FLAG_EDGE_FALLING GPIO_V2_LINE_FLAG_OPEN_DRAIN GPIO_V2_LINE_FLAG_OPEN_SOURCE GPIO_V2_LINE_FLAG_BIAS_PULL_UP GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN GPIO_V2_LINE_FLAG_BIAS_DISABLED Los atributos de la l\u00ednea nos permiten cambiar la configuraci\u00f3n de un subconjunto de los pines de la l\u00ednea o indicar informaci\u00f3n complementaria a los flags necesaria para completar su configuraci\u00f3n (por ejemplo valor del pin en pines de salida). El campo attrs es un array de atributos definidos para la l\u00ednea, indicando el n\u00famero de atributos definidos en el campo num_attrs . Cada atributo se define con la siguiente estructura: struct gpio_v2_line_config_attribute { struct gpio_v2_line_attribute attr ; //atributo __aligned_u64 mask ; //pines a los que aplica }; El campo mask indica los pines de la linea afectados por el atributo, d\u00f3nde cada bit corresponde a un \u00edndice del array de offsets de la estructura struct gpio_v2_line_request . El campo attr se representa con la siguiente estructura: struct gpio_v2_line_attribute { __u32 id ; //GPIO_V2_LINE_ATTR_ID_{FLAGS,OUTPUT_VALUES,DEBOUNCE} __u32 padding ; union { __aligned_u64 flags ; // flag __aligned_u64 values ; // valor ini. 1-activo, 0-inactivo __u32 debounce_period_us ; // tiempo de debounce }; }; El campo id indica el tipo de atributo, y su valor determina el campo de la uni\u00f3n que contiene la informaci\u00f3n correspondiente: GPIO_V2_LINE_ATTR_ID_FLAGS : aplicable a cualquier grupo de pines. El campo flags de la uni\u00f3n indica una configuraci\u00f3n alternativa para este grupo de pines. GPIO_V2_LINE_ATTR_ID_OUTPUT : aplicable a grupos de pines configurados como salida (por defecto o con atributos anteriores). El campo values de la uni\u00f3n indica el valor que se asigna a los pines afectados. GPIO_V2_LINE_ATTR_ID_DEBOUNCE : aplicable a pines configurados como entrada (por defecto o con atributos anteriores). El campo debounce_period_us de la uni\u00f3n indica el periodo en microsegundos con el que se muestrea el pin para eliminar rebotes (cualquier cambio m\u00e1s r\u00e1pido es filtrado). Para leer o escribir en los pines de la l\u00ednea debemos realizaremos nuevas operaciones ioctl sobre el descriptor de fichero inicializado en la operaci\u00f3n ioctl line_request . Para escribir un valor en pines configurados como salida usaremos la operaci\u00f3n ioctl GPIO_V2_LINE_SET_VALUES_IOCTL : struct gpio_v2_line_values values ; ... ioctl ( req . fd , GPIO_V2_LINE_SET_VALUES_IOCTL , & values ); mientras que para leer utilizaremos la operaci\u00f3n GPIO_V2_LINE_GET_VALUES_IOCTL : struct gpio_v2_line_values values ; ... ioctl ( req . fd , GPIO_V2_LINE_GET_VALUES_IOCTL , & values ); En ambos casos values tiene la siguiente estructura: struct gpio_v2_line_values { __aligned_u64 bits ; //m\u00e1scara de bits con el valor los pines __aligned_u64 mask ; //m\u00e1scara de bits que leer/escribir }; Cada bit de ambos campos se refiere a una de las posiciones del campo offsets de la l\u00ednea. Veamos un ejemplo. El programa gpio_blink_v2.c usa el driver de caracteres del GPIO para hacer parpadear los leds que se indican por la l\u00ednea de comandos, con un periodo de 0.5Hz (1 s encendidos, 1 s apagados). Podemos probar este programa en la raspberry, conectando tres pines a los tres leds de la placa BEE. Como ejercicio, se propone al estudiante modificar el c\u00f3digo del programa anterior para que de la sensaci\u00f3n de que una luz va pasando de un led a otro, dando la vuelta cuando llegue a los extremos.","title":"Pines de entrada y salida"},{"location":"gpio_linux/#eventos-en-pines-de-entrada","text":"El driver del GPIO convierte las interrupciones en los pines del GPIO en eventos software que se insertan en el descriptor de fichero (fd) asociado a la linea. Esto permite: Usar programaci\u00f3n multihilo, destiando un hilo a atender los eventos de entrada de la l\u00ednea. Usar mecanismos de multiplexaci\u00f3n de entrada/salida para monitorizar varios descriptores/l\u00edneas (uando select, poll o epoll). La detecci\u00f3n de eventos debe ser habilitada en los pines de entrada, a\u00f1adiendo uno los flags GPIO_V2_LINE_FLAG_EDGE_RISING y/o GPIO_V2_LINE_FLAG_EDGE_FALLING . Adem\u00e1s, se puede utilizar el atributo GPIO_V2_LINE_ATTR_ID_DEBOUNCE para configurar en el pin una eliminaci\u00f3n de rebotes. Por cada evento podremos leer del descriptor de fichero una estructura del tipo: struct gpio_v2_line_event { __aligned_u64 timestamp_ns ; //Marca de tiempo del evento __u32 id ; //Tipo de evento __u32 offset ; //offset del pin correspondiente __u32 seqno ; //n\u00fam. de secuencia global __u32 line_seqno ; //n\u00fam. de secuencia en este pin __u32 padding [ 6 ]; //reservado }; d\u00f3nde el campo id nos identifica el evento detectado mientras que offset identifica el pin en el que se producido el evento. El campo seqno nos indica el \u00f3rden global en el que el evento se ha detectado, mientras que line_seqno nos indica el \u00f3rden entre los eventos de la l\u00ednea. El programa de ejemplo gpio_toggle.c usa el driver GPIO para controlar el estado de unos leds con unos pulsadores. El programa recibe como par\u00e1metros una lista con un n\u00famero par de pines. La primera mitad se configuran como pines entradas, activando la detecci\u00f3n de eventos por flancos de bajada, con un debounce de 10 ms. La segunda mitad se configuran como pines de salida, inicialmente activos (a 1). El programa se queda esperando por eventos de flanco de bajada en las entradas. Cuando se recibe un evento, se conmuta el estado del pin de salida correspondiente. El programa puede probarse conectando los 3 leds de la placa de expansi\u00f3n a 3 gpios (salidas) y los pulsadores a otros 3 gpios (entradas). Como ejercicio se propone al estudiante modificar el programa para que los pulsadores determinen si los leds parpadean o no. Es decir, inicialmente estar\u00e1n los 3 leds parpadeando a una frecuencia fija (por ejemplo 0.5 Hz), si se pulsa uno de los pulsadores el led correspondiente se quedar\u00e1 apagado. Si se vuelve a pulsar, el led volver\u00e1 a parpadear s\u00edncronamente con el resto. El dispositivo de caracteres GPIO soporta algunas operaciones ioctl adicionales: GPIO_V2_GET_LINEINFO_WATCH_IOCTL , monitorizar cambios en un l\u00ednea: Se pasa un argumento struct gpio_v2_line_info Se indican las l\u00edneas que se desean monitorizar Los eventos de cambio se obtinen del fd del gpiochip correspondiente GPIO_V2_LINE_SET_CONFIG_IOCTL , cambiar la configuraci\u00f3n de una l\u00ednea: Se pasa un argumento struct gpio_v2_line_config No es necesario liberar la l\u00ednea antes","title":"Eventos en pines de entrada"},{"location":"gpio_linux/#gpio-mapeado-en-memoria","text":"Linux incorpora el dispositivo /dev/mem que permite acceder a la memoria f\u00edsica del computador. El offset en este fichero es interpretado como una direcci\u00f3n f\u00edsica y el driver controla los rangos accesibles (configurable con la opci\u00f3n de compilaci\u00f3n del kernel CONFIG_STRICT_DEVMEM ) en funci\u00f3n de la arquitectura del computador. S\u00f3lo root tiene acceso a este dispositvo, ya que usarlo implica saltarse pr\u00e1cticamente todos los mecanismos de control y las abstracciones del sistema operativo. Raspbian incorpora tambi\u00e9n el dispositivo /dev/gpiomem, que es un dispositivo que permite el acceso al rango de direcciones f\u00edsicas controlado por el GPIO. Todos los usuarios que pertenezcan al grupo gpio tienen acceso a este fichero, adem\u00e1s de root. Este fichero permite acceder en crudo a los registros del gpio puenteando al driver gpio. Aunque no se recomienda su uso (mejor utilizar el driver gpio), puede ser \u00fatil usarlo para estudiar el funcionamiento del controlador gpio. Como ejemplo vamos a ver c\u00f3mo podemos implementar el ejemplo gpio_blink utilizando este dispositivo. Para ello primero debemos revisar la documentaci\u00f3n de Broadcom para ver c\u00f3mo funciona el controlador GPIO. Resumimos aqu\u00ed los aspectos m\u00e1s destacados. En el controlador GPIO la funci\u00f3n de cada pin se configura en los registros de selecci\u00f3n GPFSELn : Registro Dir. F\u00edsica Pines GPI GPFSEL0 0x3F200000 GPIO0 - GPIO9 GPFSEL1 0x3F200004 GPIO10 - GPIO19 GPFSEL2 0x3F200008 GPIO20 - GPIO29 GPFSEL3 0x3F20000C GPIO30 - GPIO39 GPFSEL4 0x3F200010 GPIO40 - GPIO49 GPFSEL5 0x3F200014 GPIO50 - GPIO53 Se utilizan tres bits por pin, con la codificaci\u00f3n indicada en la siguiente tabla: Funci\u00f3n (seg\u00fan doc. Broadcom ) 000 Entrada 001 Salida 100 Funci\u00f3n alternativa 0 101 Funci\u00f3n alternativa 1 110 Funci\u00f3n alternativa 2 111 Funci\u00f3n alternativa 3 011 Funci\u00f3n alternativa 4 010 Funci\u00f3n alternativa 5 Para operar sobre los pines de salida hay dos pares de registros: Valor Pin Registro Direcci\u00f3n (ARM) 1 0-31 GPFSET0 0x3F20001C 1 32-53 GPFSET1 0x3F200020 0 0-31 GPFCLR0 0x3F200028 0 32-53 GPFCLR1 0x3F20002C As\u00ed, para poner a 1 un pin de salida debemos escribir un 1 en la posici\u00f3n correspondiente del registro GPSET que corresponda. Y para poner dicho pin a 0 deberemos escribir un 1 en el la misma posici\u00f3n del registro GPCLR correspondiente. Escribir un 0 no modifica el valor del pin. El programa gpio_blink_mem proyectan el dispositivo /dev/gpiomem en el mapa virtual de memoria del proceso utilizando mmap, con el fin de acceder dir\u00e9ctamente a los registros del controlador. Se utilizan unos arrays para almacenar los offsets de los registros: uint32_t gpfsel_offset [] = { 0x00 , 0x04 , 0x08 , 0x0C , 0x10 , 0x14 }; uint32_t gpfset_offset [] = { 0x1C , 0x20 }; uint32_t gpfclr_offset [] = { 0x28 , 0x2C }; Estos offsets se suman a la direcci\u00f3n base que es un puntero a byte, convirtiendo el resultado a un puntero a uint32_t por conveniencia: uint8_t * gpiomem ; volatile uint32_t * fpsel ; ... gpiomem = mmap ( NULL , 4096 , PROT_READ | PROT_WRITE , MAP_SHARED , fd , 0x3f200000 ); ... n = get_int ( argv [ i + 1 ], 10 , desc ); fpsel = ( uint32_t * )( gpiomem + gpfsel_offset [ n / 10 ]); Las escrituras en los registros se hacen desreferenciado los punteros, que se han declarado como vol\u00e1tiles: * fpsel |= ( 0x1 << ( n % 10 ) * 3 ); Aunque este mecanismo permite controlar los gpios, debemos notar que el c\u00f3digo es muy dependiente del hardware, utilizando offsets y selecciones de registros en funci\u00f3n del n\u00famero de pin o la operaci\u00f3n a realizar; y escogiendo adecuadamente los c\u00f3digos a escribir en los registros siguiendo la documentaci\u00f3n del fabricante del SoC. Notemos adem\u00e1s que el estado de los leds se mantiene cuando el programa termina, y puede entrar en conflicto con cualquier otro proceso que use el driver del sistema para el gpio. Este c\u00f3digo es mucho m\u00e1s propenso a errores que no ser\u00e1n identificados por el sistema (no hay valor de retorno de error). La librer\u00eda bcm2835 usa entrada salida mapeada en memoria y ofrece un API m\u00e1s sencillo y pr\u00e1ctico para el manejo de los controladores de la raspberry pi, pero sigue salt\u00e1ndose todos los controles del sistema operativo, por lo que resulta m\u00e1s adecuando aprender a utilizar el driver GPIO estudiado en la secci\u00f3n anterior.","title":"GPIO mapeado en memoria"},{"location":"i2c_linux/","text":"Control de dispositivos I2C \u00b6 Para probar los c\u00f3digos utilizados en los ejemplos de esta pr\u00e1ctica necesitamos disponer de una placa Inertial One ATAVRSBIN1 . A lo largo de la pr\u00e1ctica repasaremos los conceptos b\u00e1sicos del bus I2C y veremos c\u00f3mo podemos comunicarnos con los dispositivos I2C utilizando las utilidades incluidas en Linux, as\u00ed como el driver I2C gen\u00e9rico incluido. Bus I2C \u00b6 El Inter-Integrated Circuit (IIC/\\IIC{}/I2C) es un bus serie dise\u00f1ado por Philips en d\u00e9cada del 1980 para la interconexi\u00f3n de perif\u00e9ricos a un microcontrolador. Proporciona una conexi\u00f3n serie s\u00edncrona unidireccional (halfduplex). Los dispositivos pueden ser m\u00e1ster o slave, permiti\u00e9ndose la presencia de varios m\u00e1sters en el bus. El protocolo de trasmisi\u00f3n incorpora un mecanismo de arbitraje que permite seleccionar el m\u00e1ster que toma el control del bus en caso de que varios quieran enviar simult\u00e1neamente. El m\u00e1ster es quien inicia y finaliza cada transferencia. Direcciona al esclavo con el que se quiere comunicar y genera la se\u00f1al de reloj. El esclavo no puede enviar o recibir por su cuenta. El bus puede trabajar a varias velocidades: 100Kb/s, 400Kb/s, 1Mb/s, 3.4Mb/s y 5Mb/s y s\u00f3lo utiliza dos l\u00edneas, adem\u00e1s de la tierra com\u00fan: Serial Data (SDA), que lleva los datos, y Serial Clock (SCL), que lleva la se\u00f1al de reloj generada por el master. En los \u00faltimos a\u00f1os se han popularizado algunas variantes de I2C utlizadas en los computadores personales para el control de algunos sensores, como son SMBus y PMBus. Estos protocolos pueden utilizarse igual con el driver I2C de Linux. Las conexiones a las l\u00ednea van en colector/drenador abierto ( open drain/collector ). Se emplean resistencias de pull-up externas, de 4.7 K t\u00edpicamente, que dejan la linea a Vdd en reposo. Los dispositivos pueden poner (forzar) las l\u00edneas a 0 ( OR cableada). La siguiente figura ilustra las sincronizaciones de comienzo y fin de una transacci\u00f3n I2C. Primero el m\u00e1ster env\u00eda comando START , una transici\u00f3n Alto a Bajo de SDA, con SCL en alto. A partir de ese momento el bus se considera ocupado y se procede al env\u00edo de datos (trama), gener\u00e1ndose un pulso en SCL por cada bit transferido. El receptor puede mantener SCL baja en cualquier momento si quiere alargar el ciclo de reloj (forzar una espera del master). La se\u00f1al SDA se debe mantener estable mientras SCL est\u00e1 alta. Cuando se han enviado todos los bits de la transacci\u00f3n el m\u00e1ster env\u00eda comando STOP , una transacci\u00f3n Bajo a Alto de SDA con SCL en alto. El bus queda libre tras este comando de STOP . La siguiente figura detalla la estructura de la trama. Como podemos ver, tras el comando Start hay un byte de direcci\u00f3n, que se compone de: 7 bits de direcci\u00f3n del esclavo, empezando por el m\u00e1s significativo 1 bit de tipo de operaci\u00f3n: R/nW 1 bit de ACK A continuaci\u00f3n se env\u00edan uno o m\u00e1s bytes de datos, cada uno de ellos seguidos de un bit de ACK que debe poner a 0 el receptor. Los bytes de datos se env\u00edan tambi\u00e9n empezando por el bit m\u00e1s significativo. La transacci\u00f3n termina normalmente con el env\u00edo de un comando de STOP . Pero se quiere evitar perder el bus, el m\u00e1ster puede decidir env\u00eda un comando de START en lugar del STOP (que se llama START repetido), comenzando dir\u00e9ctamente una nueva transmisi\u00f3n. As\u00ed, una transmisi\u00f3n de escritura, en la que un m\u00e1ster env\u00eda un dato a un esclavo tendr\u00eda la siguiente estructura: El m\u00e1ster env\u00eda un primer byte de direcci\u00f3n del esclavo, indicado el que quiere escribir. Luego suele enviar un byte de comando, que direcciona el registro en el que quiere escribir, seguido del dato a escribir. La operaci\u00f3n de lectura normalmente va precedida de una operaci\u00f3n de escritura en la que se env\u00eda el comando de lectura, indicando el registro del que se quiere leer. Despu\u00e9s se realiza la operaci\u00f3n de lectura propiamente dicha, en la que el primer byte direcciona el dispositivo y se indique que se quiere hacer una lectura, y el m\u00e1ster luego genera los suficientes pulsos de reloj para leer los bytes que enviar\u00e1 el esclavo, activando como corresponda el bit de ACK en cada byte transferido. I2C contempla la posibilidad de utilizar direcciones de 10 bits. Para ello, se reservan las direcciones 11110xy para indicar que la direcci\u00f3n es de 10 bits: Los bits xy ser\u00e1n los dos bits m\u00e1s significativos de la direcci\u00f3n Los 8 bits restantes se env\u00edan en el siguiente byte No lo soportan todos los controladores I2C, ni es soportado por dispositivos SMBus. En transacciones escritura-lectura encadenadas s\u00f3lo se repite el primer byte de la direcci\u00f3n. En este caso, el esquema de una operaci\u00f3n de escritura es como indica la siguiente figura: I2C write 10 bit address La lectura con un dispositivo con direcci\u00f3n de 10 bits se ilustra en la siguiente figura: I2C read 10 bit address Existen otras extensiones al bus I2C, que pueden consultarse en la especificaci\u00f3n de I2C . I2C en Linux \u00b6 El driver I2C de Linux expone dispositivos de caracteres /dev/i2c-# . Para ello es necesario cargar el m\u00f3dulo i2c-dev. Por cada controlador I2C del SoC aparecer\u00e1 un fichero en /sys/class/i2c-dev/ . El paquete i2c-tools (puede instalarse con apt-get install i2c-tools ) nos da algunas herramientas interesantes: i2cdetect -l : nos da una lista de controladores i2c en el sistema i2cdetect -y # : escanea el bus i2c-# y nos dice los dispositivos detectados y sus direcciones i2cget : permite leer registros de dispositivos conectados al bus. Por ejemplo: i2cget -y 1 0x68 0x1c b - i2cset : permite escribir en registros de dispositivos conectados al bus. - i2ctransfer : nos permite hacer transferencias encadenadas con slaves conectados al bus. Por ejemplo: i2ctransfer -y 1 w1@0x68 0x1c r1 Hay tres tipos de transaccionees soportadas por el driver: Transacciones I2C est\u00e1ndar: Operaciones read/write independientes Bit de stop detr\u00e1s de cada una Para leer un registro primero hacemos una op de escritura con el n\u00famero del registro y luego una operaci\u00f3n de lectura para leer el valor Transacciones I2C encadenadas con ioctl Varias transacciones con una sola operaci\u00f3n ioctl tipo I2C_RDWR Por defecto con repeated start Puede usarse para leer un registro, concatenando el write del comando con el read siguiente Transacciones SMBus API espec\u00edfico y simplificado implementado en la libi2c Se prefiere su uso para dispositivos compatibles El interfaz est\u00e1 documentado en www.kernel.org y en los ficheros de cabecera del driver: i2c-dev.h , i2c.h y smbus.h . Las operaciones ioctl soportadas por estos dispositivos son: I2C_SLAVE : establece la direcci\u00f3n del esclavo, nos ahorramos tener que ponerla en cada operaci\u00f3n I2C_FUNCS : nos permite consultar la funcionalidad disponible en el controlador I2C_TENBIT : selecci\u00f3n del uso de direcciones de 10 bits. El controlador debe tener la funcionalidad I2C_FUNC_10BIT_ADDR I2C_RDWR : Para realizar transacciones de lectura/escritura encadenadas, sin bit de stop entre ellas. El controlador debe tener I2C_FUNC_I2C . I2C_PEC : generaci\u00f3n y verificaci\u00f3n de Packet Error Checking para el protocolo SMBus. El controlador debe tener I2C_FUNC_SMBUS_PEC I2C_SMBUS : Para transacciones SMBus.Se recomienda el uso de las funciones i2c_smbus_* , proporcionadas por la librer\u00eda libi2c (paquete i2c-tools ), que hacen de wrapper sobre la operaci\u00f3n ioctl SMBus es un subconjunto de I2C: S\u00f3lo admite direcciones de 7 bits S\u00f3lo hasta 100 KHz Timeout 35 ms, frecuencia m\u00ednima de 10 KHz El API implementado en libi2c opera sobre la operaci\u00f3n ioctl I2C_SMBUS : __s32 i2c_smbus_write_quick ( int file , __u8 value ); __s32 i2c_smbus_read_byte ( int file ); __s32 i2c_smbus_write_byte ( int file , __u8 value ); __s32 i2c_smbus_read_byte_data ( int file , __u8 command ); __s32 i2c_smbus_write_byte_data ( int file , __u8 command , __u8 value ); __s32 i2c_smbus_read_word_data ( int file , __u8 command ); __s32 i2c_smbus_write_word_data ( int file , __u8 command , __u16 value ); /* Returns the number of read bytes */ __s32 i2c_smbus_read_block_data ( int file , __u8 command , __u8 * values ); __s32 i2c_smbus_write_block_data ( int file , __u8 command , __u8 length , const __u8 * values ); El API completo se documenta en /usr/include/i2c/smbus.h . Ejemplo de transacciones I2C est\u00e1ndar \u00b6 El siguiente c\u00f3digo es un ejemplo de lectura de un registro de tama\u00f1o byte de un sensor i2c, usando una transacci\u00f3n I2C est\u00e1ndar con el driver I2C de Linux: int addr = 0x68 ; // Direcci\u00f3n del sensor I2C unsigned char regid = 0x1b ; // Id del registro a leer unsigned char buf ; // buffer para el valor le\u00eddo int fd ; fd = open ( \"/dev/i2c-1\" , O_RDWR ); ioctl ( fd , I2C_SLAVE , addr ); write ( fd , & regid , 1 ); // Transacci\u00f3n de escritura/comando read ( fd , & buf , 1 ); // Transacci\u00f3n de lectura Ejemplo de transacci\u00f3n I2C encadenada \u00b6 El siguiente c\u00f3digo es un ejemplo de una transacci\u00f3n encadenada con el driver de I2C de Linux en el que se hace la misma lectura que en el ejemplo anterior, pero encadenando la operaci\u00f3n de escritura (que indica el registro a leer) y la operaci\u00f3n de lectura posterior: int fd ; // descriptor de fichero int addr = 0x68 ; // Direcci\u00f3n del sensor I2C char wbuf [ 1 ] = { 0x1b }; // Id del registro a leer char rbuf [ 1 ]; // buffer para el valor le\u00eddo struct i2c_msg msgs [ 2 ]; // variables para la op ioctl struct i2c_rdwr_ioctl_data i2cdata ; // Transacci\u00f3n de escritura / comando msgs [ 0 ]. addr = addr ; msgs [ 0 ]. flags = 0 ; msgs [ 0 ]. len = 1 ; msgs [ 0 ]. buf = wbuf ; // Transacci\u00f3n de lectura msgs [ 1 ]. addr = addr ; msgs [ 1 ]. flags = I2C_M_RD ; msgs [ 1 ]. len = 1 ; msgs [ 1 ]. buf = rbuf ; fd = open ( \"/dev/i2c-1\" , O_RDWR ); // ioctl para realizar las dos transacciones i2cdata . msgs = msgs ; i2cdata . nmsgs = 2 ; ioctl ( fd , I2C_RDWR , & i2cdata ); // Operaciones encadenadas Ejemplo de transacci\u00f3n SMBus \u00b6 La misma lectura de un registro de tama\u00f1o byte usando el API SMBus se realizar\u00eda del siguiente modo: int addr = 0x68 ; // Direcci\u00f3n del sensor I2C unsigned char regid = 0x1b ; // Id del registro a leer unsigned char buf ; // buffer para el valor le\u00eddo int fd , ret ; fd = open ( \"/dev/i2c-1\" , O_RDWR ); ioctl ( fd , I2C_SLAVE , addr ); ret = i2c_smbus_read_byte_data ( fd , regid ); buf = ret ; Ejemplo: lectura del sensor Inertial One \u00b6 La placa Inertial One ATAVRSBIN1 contiene 3 dispositivos i2c: Aceler\u00f3metro de tres ejes Bosh Sensortech (BMA-150) Gir\u00f3scopo de tres ejes InvenSense (ITG-3200) Br\u00fajula Electr\u00f3nica de tres ejes AKM (AK8975) Podemos conectarla a la placa BEE del siguiente modo: Pin 1 del Jumper J2 a SDA Pin 2 del Jumper J2 a SCL Pin 9 del Jumper J2 a Gnd Pin 10 del Jumper J2 a Vdd Para comprobar que est\u00e1 bien conectada podemos usar el comando i2cdetect -y 1 : pi@raspberrypi:~/ejemplos $ i2cdetect -y 1 0 1 2 3 4 5 6 7 8 9 a b c d e f 00 : -- -- -- -- 0c -- -- -- 10 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 20 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 30 : -- -- -- -- -- -- -- -- 38 -- -- -- -- -- -- -- 40 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60 : -- -- -- -- -- -- -- -- 68 -- -- -- -- -- -- -- 70 : -- -- -- -- -- -- -- -- pi@raspberrypi:~/ejemplos $ El Gir\u00f3scopo ITG-3200 del Inertial One tiene asignada la direcci\u00f3n 0x68, e integra cuatro sensores de 16 bits accesibles en los siguientes registros: Como puede verse, cada sensor tiene dos registros, uno con los 8 bits m\u00e1s significativos y otro con los 8 bits menos significativos. El programa de ejemplo itg3200_sensors.c lee estos sensores y muestra su valor por la salida est\u00e1ndar. Los flags de la l\u00ednea de comandos permiten seleccionar los tres tipos de transacciones para leer estos valores. Examina el programa y prueba a utilizarlo leyendo cada uno de los registros. Comprueba que funcionan los tres tipos de transacciones. Ejercicio \u00b6 Dise\u00f1ar un programa que lea los valores acc_x , acc_y y acc_z del aceler\u00f3metro BMA 150 incluido en la unidad inercial. Consultar el datasheet del componente para: Determinar los registros que hay que leer Determinar el registro de configuraci\u00f3n del: rango de medida, seleccionar el rango [-2g, 2g) el ancho de banda, seleccionar 25 Hz Determinar la sensibilidad de la medida Consultar el[Application Note de NXP Tilt Sensing Using a Three-Axis Accelerometer (AN3461) para determinar c\u00f3mo obtener los \u00e1ngulos roll y pitch a partir de las medidas del aceler\u00f3metro.","title":"Control de dispositivos I2C"},{"location":"i2c_linux/#control-de-dispositivos-i2c","text":"Para probar los c\u00f3digos utilizados en los ejemplos de esta pr\u00e1ctica necesitamos disponer de una placa Inertial One ATAVRSBIN1 . A lo largo de la pr\u00e1ctica repasaremos los conceptos b\u00e1sicos del bus I2C y veremos c\u00f3mo podemos comunicarnos con los dispositivos I2C utilizando las utilidades incluidas en Linux, as\u00ed como el driver I2C gen\u00e9rico incluido.","title":"Control de dispositivos I2C"},{"location":"i2c_linux/#bus-i2c","text":"El Inter-Integrated Circuit (IIC/\\IIC{}/I2C) es un bus serie dise\u00f1ado por Philips en d\u00e9cada del 1980 para la interconexi\u00f3n de perif\u00e9ricos a un microcontrolador. Proporciona una conexi\u00f3n serie s\u00edncrona unidireccional (halfduplex). Los dispositivos pueden ser m\u00e1ster o slave, permiti\u00e9ndose la presencia de varios m\u00e1sters en el bus. El protocolo de trasmisi\u00f3n incorpora un mecanismo de arbitraje que permite seleccionar el m\u00e1ster que toma el control del bus en caso de que varios quieran enviar simult\u00e1neamente. El m\u00e1ster es quien inicia y finaliza cada transferencia. Direcciona al esclavo con el que se quiere comunicar y genera la se\u00f1al de reloj. El esclavo no puede enviar o recibir por su cuenta. El bus puede trabajar a varias velocidades: 100Kb/s, 400Kb/s, 1Mb/s, 3.4Mb/s y 5Mb/s y s\u00f3lo utiliza dos l\u00edneas, adem\u00e1s de la tierra com\u00fan: Serial Data (SDA), que lleva los datos, y Serial Clock (SCL), que lleva la se\u00f1al de reloj generada por el master. En los \u00faltimos a\u00f1os se han popularizado algunas variantes de I2C utlizadas en los computadores personales para el control de algunos sensores, como son SMBus y PMBus. Estos protocolos pueden utilizarse igual con el driver I2C de Linux. Las conexiones a las l\u00ednea van en colector/drenador abierto ( open drain/collector ). Se emplean resistencias de pull-up externas, de 4.7 K t\u00edpicamente, que dejan la linea a Vdd en reposo. Los dispositivos pueden poner (forzar) las l\u00edneas a 0 ( OR cableada). La siguiente figura ilustra las sincronizaciones de comienzo y fin de una transacci\u00f3n I2C. Primero el m\u00e1ster env\u00eda comando START , una transici\u00f3n Alto a Bajo de SDA, con SCL en alto. A partir de ese momento el bus se considera ocupado y se procede al env\u00edo de datos (trama), gener\u00e1ndose un pulso en SCL por cada bit transferido. El receptor puede mantener SCL baja en cualquier momento si quiere alargar el ciclo de reloj (forzar una espera del master). La se\u00f1al SDA se debe mantener estable mientras SCL est\u00e1 alta. Cuando se han enviado todos los bits de la transacci\u00f3n el m\u00e1ster env\u00eda comando STOP , una transacci\u00f3n Bajo a Alto de SDA con SCL en alto. El bus queda libre tras este comando de STOP . La siguiente figura detalla la estructura de la trama. Como podemos ver, tras el comando Start hay un byte de direcci\u00f3n, que se compone de: 7 bits de direcci\u00f3n del esclavo, empezando por el m\u00e1s significativo 1 bit de tipo de operaci\u00f3n: R/nW 1 bit de ACK A continuaci\u00f3n se env\u00edan uno o m\u00e1s bytes de datos, cada uno de ellos seguidos de un bit de ACK que debe poner a 0 el receptor. Los bytes de datos se env\u00edan tambi\u00e9n empezando por el bit m\u00e1s significativo. La transacci\u00f3n termina normalmente con el env\u00edo de un comando de STOP . Pero se quiere evitar perder el bus, el m\u00e1ster puede decidir env\u00eda un comando de START en lugar del STOP (que se llama START repetido), comenzando dir\u00e9ctamente una nueva transmisi\u00f3n. As\u00ed, una transmisi\u00f3n de escritura, en la que un m\u00e1ster env\u00eda un dato a un esclavo tendr\u00eda la siguiente estructura: El m\u00e1ster env\u00eda un primer byte de direcci\u00f3n del esclavo, indicado el que quiere escribir. Luego suele enviar un byte de comando, que direcciona el registro en el que quiere escribir, seguido del dato a escribir. La operaci\u00f3n de lectura normalmente va precedida de una operaci\u00f3n de escritura en la que se env\u00eda el comando de lectura, indicando el registro del que se quiere leer. Despu\u00e9s se realiza la operaci\u00f3n de lectura propiamente dicha, en la que el primer byte direcciona el dispositivo y se indique que se quiere hacer una lectura, y el m\u00e1ster luego genera los suficientes pulsos de reloj para leer los bytes que enviar\u00e1 el esclavo, activando como corresponda el bit de ACK en cada byte transferido. I2C contempla la posibilidad de utilizar direcciones de 10 bits. Para ello, se reservan las direcciones 11110xy para indicar que la direcci\u00f3n es de 10 bits: Los bits xy ser\u00e1n los dos bits m\u00e1s significativos de la direcci\u00f3n Los 8 bits restantes se env\u00edan en el siguiente byte No lo soportan todos los controladores I2C, ni es soportado por dispositivos SMBus. En transacciones escritura-lectura encadenadas s\u00f3lo se repite el primer byte de la direcci\u00f3n. En este caso, el esquema de una operaci\u00f3n de escritura es como indica la siguiente figura: I2C write 10 bit address La lectura con un dispositivo con direcci\u00f3n de 10 bits se ilustra en la siguiente figura: I2C read 10 bit address Existen otras extensiones al bus I2C, que pueden consultarse en la especificaci\u00f3n de I2C .","title":"Bus I2C"},{"location":"i2c_linux/#i2c-en-linux","text":"El driver I2C de Linux expone dispositivos de caracteres /dev/i2c-# . Para ello es necesario cargar el m\u00f3dulo i2c-dev. Por cada controlador I2C del SoC aparecer\u00e1 un fichero en /sys/class/i2c-dev/ . El paquete i2c-tools (puede instalarse con apt-get install i2c-tools ) nos da algunas herramientas interesantes: i2cdetect -l : nos da una lista de controladores i2c en el sistema i2cdetect -y # : escanea el bus i2c-# y nos dice los dispositivos detectados y sus direcciones i2cget : permite leer registros de dispositivos conectados al bus. Por ejemplo: i2cget -y 1 0x68 0x1c b - i2cset : permite escribir en registros de dispositivos conectados al bus. - i2ctransfer : nos permite hacer transferencias encadenadas con slaves conectados al bus. Por ejemplo: i2ctransfer -y 1 w1@0x68 0x1c r1 Hay tres tipos de transaccionees soportadas por el driver: Transacciones I2C est\u00e1ndar: Operaciones read/write independientes Bit de stop detr\u00e1s de cada una Para leer un registro primero hacemos una op de escritura con el n\u00famero del registro y luego una operaci\u00f3n de lectura para leer el valor Transacciones I2C encadenadas con ioctl Varias transacciones con una sola operaci\u00f3n ioctl tipo I2C_RDWR Por defecto con repeated start Puede usarse para leer un registro, concatenando el write del comando con el read siguiente Transacciones SMBus API espec\u00edfico y simplificado implementado en la libi2c Se prefiere su uso para dispositivos compatibles El interfaz est\u00e1 documentado en www.kernel.org y en los ficheros de cabecera del driver: i2c-dev.h , i2c.h y smbus.h . Las operaciones ioctl soportadas por estos dispositivos son: I2C_SLAVE : establece la direcci\u00f3n del esclavo, nos ahorramos tener que ponerla en cada operaci\u00f3n I2C_FUNCS : nos permite consultar la funcionalidad disponible en el controlador I2C_TENBIT : selecci\u00f3n del uso de direcciones de 10 bits. El controlador debe tener la funcionalidad I2C_FUNC_10BIT_ADDR I2C_RDWR : Para realizar transacciones de lectura/escritura encadenadas, sin bit de stop entre ellas. El controlador debe tener I2C_FUNC_I2C . I2C_PEC : generaci\u00f3n y verificaci\u00f3n de Packet Error Checking para el protocolo SMBus. El controlador debe tener I2C_FUNC_SMBUS_PEC I2C_SMBUS : Para transacciones SMBus.Se recomienda el uso de las funciones i2c_smbus_* , proporcionadas por la librer\u00eda libi2c (paquete i2c-tools ), que hacen de wrapper sobre la operaci\u00f3n ioctl SMBus es un subconjunto de I2C: S\u00f3lo admite direcciones de 7 bits S\u00f3lo hasta 100 KHz Timeout 35 ms, frecuencia m\u00ednima de 10 KHz El API implementado en libi2c opera sobre la operaci\u00f3n ioctl I2C_SMBUS : __s32 i2c_smbus_write_quick ( int file , __u8 value ); __s32 i2c_smbus_read_byte ( int file ); __s32 i2c_smbus_write_byte ( int file , __u8 value ); __s32 i2c_smbus_read_byte_data ( int file , __u8 command ); __s32 i2c_smbus_write_byte_data ( int file , __u8 command , __u8 value ); __s32 i2c_smbus_read_word_data ( int file , __u8 command ); __s32 i2c_smbus_write_word_data ( int file , __u8 command , __u16 value ); /* Returns the number of read bytes */ __s32 i2c_smbus_read_block_data ( int file , __u8 command , __u8 * values ); __s32 i2c_smbus_write_block_data ( int file , __u8 command , __u8 length , const __u8 * values ); El API completo se documenta en /usr/include/i2c/smbus.h .","title":"I2C en Linux"},{"location":"i2c_linux/#ejemplo-de-transacciones-i2c-estandar","text":"El siguiente c\u00f3digo es un ejemplo de lectura de un registro de tama\u00f1o byte de un sensor i2c, usando una transacci\u00f3n I2C est\u00e1ndar con el driver I2C de Linux: int addr = 0x68 ; // Direcci\u00f3n del sensor I2C unsigned char regid = 0x1b ; // Id del registro a leer unsigned char buf ; // buffer para el valor le\u00eddo int fd ; fd = open ( \"/dev/i2c-1\" , O_RDWR ); ioctl ( fd , I2C_SLAVE , addr ); write ( fd , & regid , 1 ); // Transacci\u00f3n de escritura/comando read ( fd , & buf , 1 ); // Transacci\u00f3n de lectura","title":"Ejemplo de transacciones I2C est\u00e1ndar"},{"location":"i2c_linux/#ejemplo-de-transaccion-i2c-encadenada","text":"El siguiente c\u00f3digo es un ejemplo de una transacci\u00f3n encadenada con el driver de I2C de Linux en el que se hace la misma lectura que en el ejemplo anterior, pero encadenando la operaci\u00f3n de escritura (que indica el registro a leer) y la operaci\u00f3n de lectura posterior: int fd ; // descriptor de fichero int addr = 0x68 ; // Direcci\u00f3n del sensor I2C char wbuf [ 1 ] = { 0x1b }; // Id del registro a leer char rbuf [ 1 ]; // buffer para el valor le\u00eddo struct i2c_msg msgs [ 2 ]; // variables para la op ioctl struct i2c_rdwr_ioctl_data i2cdata ; // Transacci\u00f3n de escritura / comando msgs [ 0 ]. addr = addr ; msgs [ 0 ]. flags = 0 ; msgs [ 0 ]. len = 1 ; msgs [ 0 ]. buf = wbuf ; // Transacci\u00f3n de lectura msgs [ 1 ]. addr = addr ; msgs [ 1 ]. flags = I2C_M_RD ; msgs [ 1 ]. len = 1 ; msgs [ 1 ]. buf = rbuf ; fd = open ( \"/dev/i2c-1\" , O_RDWR ); // ioctl para realizar las dos transacciones i2cdata . msgs = msgs ; i2cdata . nmsgs = 2 ; ioctl ( fd , I2C_RDWR , & i2cdata ); // Operaciones encadenadas","title":"Ejemplo de transacci\u00f3n I2C encadenada"},{"location":"i2c_linux/#ejemplo-de-transaccion-smbus","text":"La misma lectura de un registro de tama\u00f1o byte usando el API SMBus se realizar\u00eda del siguiente modo: int addr = 0x68 ; // Direcci\u00f3n del sensor I2C unsigned char regid = 0x1b ; // Id del registro a leer unsigned char buf ; // buffer para el valor le\u00eddo int fd , ret ; fd = open ( \"/dev/i2c-1\" , O_RDWR ); ioctl ( fd , I2C_SLAVE , addr ); ret = i2c_smbus_read_byte_data ( fd , regid ); buf = ret ;","title":"Ejemplo de transacci\u00f3n SMBus"},{"location":"i2c_linux/#ejemplo-lectura-del-sensor-inertial-one","text":"La placa Inertial One ATAVRSBIN1 contiene 3 dispositivos i2c: Aceler\u00f3metro de tres ejes Bosh Sensortech (BMA-150) Gir\u00f3scopo de tres ejes InvenSense (ITG-3200) Br\u00fajula Electr\u00f3nica de tres ejes AKM (AK8975) Podemos conectarla a la placa BEE del siguiente modo: Pin 1 del Jumper J2 a SDA Pin 2 del Jumper J2 a SCL Pin 9 del Jumper J2 a Gnd Pin 10 del Jumper J2 a Vdd Para comprobar que est\u00e1 bien conectada podemos usar el comando i2cdetect -y 1 : pi@raspberrypi:~/ejemplos $ i2cdetect -y 1 0 1 2 3 4 5 6 7 8 9 a b c d e f 00 : -- -- -- -- 0c -- -- -- 10 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 20 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 30 : -- -- -- -- -- -- -- -- 38 -- -- -- -- -- -- -- 40 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50 : -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60 : -- -- -- -- -- -- -- -- 68 -- -- -- -- -- -- -- 70 : -- -- -- -- -- -- -- -- pi@raspberrypi:~/ejemplos $ El Gir\u00f3scopo ITG-3200 del Inertial One tiene asignada la direcci\u00f3n 0x68, e integra cuatro sensores de 16 bits accesibles en los siguientes registros: Como puede verse, cada sensor tiene dos registros, uno con los 8 bits m\u00e1s significativos y otro con los 8 bits menos significativos. El programa de ejemplo itg3200_sensors.c lee estos sensores y muestra su valor por la salida est\u00e1ndar. Los flags de la l\u00ednea de comandos permiten seleccionar los tres tipos de transacciones para leer estos valores. Examina el programa y prueba a utilizarlo leyendo cada uno de los registros. Comprueba que funcionan los tres tipos de transacciones.","title":"Ejemplo: lectura del sensor Inertial One"},{"location":"i2c_linux/#ejercicio","text":"Dise\u00f1ar un programa que lea los valores acc_x , acc_y y acc_z del aceler\u00f3metro BMA 150 incluido en la unidad inercial. Consultar el datasheet del componente para: Determinar los registros que hay que leer Determinar el registro de configuraci\u00f3n del: rango de medida, seleccionar el rango [-2g, 2g) el ancho de banda, seleccionar 25 Hz Determinar la sensibilidad de la medida Consultar el[Application Note de NXP Tilt Sensing Using a Three-Axis Accelerometer (AN3461) para determinar c\u00f3mo obtener los \u00e1ngulos roll y pitch a partir de las medidas del aceler\u00f3metro.","title":"Ejercicio"},{"location":"linux-kernel/config/","text":"Drivers en Linux. Preparaci\u00f3n del entorno de trabajo \u00b6 Esta breve gu\u00eda describe el procedimiento de configuraci\u00f3n del sistema formado por la Raspberry Pi (en su variante 3B+ o 4) y la placa de entrada salida Bee v2.0, para la realizaci\u00f3n de pr\u00e1cticas sobre desarrollo de Drivers en Linux. Esencialmente, para preparar este entorno de pr\u00e1cticas deben realizarse los siguientes pasos: Configuraci\u00f3n hardware de placa de entrada-salida (\"Bee v2.0\") para realizaci\u00f3n de pr\u00e1cticas Configuraci\u00f3n inicial de la m\u00e1quina virtual y de la red interna para conexi\u00f3n con la Raspberry Pi Arranque por primera vez de la Raspberry Pi usando imagen custom preparada para las pr\u00e1cticas Prueba de conexi\u00f3n por SSH a la Raspberry Pi desde la m\u00e1quina virtual Comprobaci\u00f3n del funcionamiento de la placa de E/S y de su configuraci\u00f3n An\u00e1lisis de alternativas para desarrollo en la Raspberry Pi desde la m\u00e1quina virtual. Configuraci\u00f3n de VSCode. Adem\u00e1s del equipo con la m\u00e1quina virtual instalada, y de la Raspberry Pi conectada a la placa de E/S, se requiere disponer del siguiente material para la realizaci\u00f3n de los distintos pasos: Scripts de comprobaci\u00f3n de conexiones de la placa Bee : Se encuentran en el directorio TestBee de los ficheros de ejemplo proporcionados con la primera pr\u00e1ctica de drivers . Tarjeta SD de al menos 16GB : En esta tarjeta se ha de instalar una imagen custom de Raspberry Pi OS. El fichero de imagen ( raspberry-pi-os_030422.img ) puede descargarse usando este enlace de Google Drive . Para la instalaci\u00f3n/restauraci\u00f3n de la imagen puede emplearse la aplicaci\u00f3n gratuita multiplataforma balenaEtcher que puede descargarse aqu\u00ed . La instalaci\u00f3n de la imagen es un proceso muy sencillo. Basta seleccionar el fichero de imagen descargado previamente en nuestro equipo (fichero raspberry-pi-os_030422.img ) , escoger la unidad de la tarjeta SD de 16GB donde instalar la imagen (accesible mediante un lector de tarjetas SD), y finalmente hacer clic en Flash. Cable USB TTL Interfaz USB Ethernet Cable Ethernet 7 cables dupont hembra-hembra Dos jumpers (o en su defecto dos cables dupont hembra-hembra adicionales para interconectar 4 pines de la placa Bee v2.0) Configuraci\u00f3n hardware de placa de entrada-salida (\"Bee v2.0\") para realizaci\u00f3n de pr\u00e1cticas \u00b6 La placa de E/S Bee v2.0 que se utilizar\u00e1 en las pr\u00e1cticas de desarrollo de drivers consta de una serie de circuitos desacoplados para la gesti\u00f3n de distintos dispositivos como LEDs, pulsadores, un zumbador ( buzzer ) pasivo, etc. Antes de proceder a arrancar la Raspberry Pi usando la imagen del sistema operativo instalado en la tarjeta SD es preciso realizar distintas conexiones entre pines espec\u00edficos de la placa (GPIOs) y los pines de entrada o salida de los circuitos que controlan los distintos dispositivos a utilizar. Asimismo, es necesario conectar el cable USB TTL para poder visualizar la salida del puerto serie de la placa desde la m\u00e1quina virtual de Debian. La siguiente figura muestra los m\u00f3dulos de pines (J3, J4, J5, J6, J13 y J17) donde se realizar\u00e1n las conexiones necesarias usando 7 cables dupont hembra-hembra y 2 jumpers (o, dos cables dupont extra, si no se dispone de jumpers ). El siguiente video ilustra c\u00f3mo realizar las interconexiones de los pines que se requieren para las pr\u00e1cticas: Configuraci\u00f3n inicial de la m\u00e1quina virtual y de la red interna \u00b6 En este paso procederemos a arrancar la m\u00e1quina virtual de Debian VMWare, y realizaremos la configuraci\u00f3n m\u00ednima necesaria para poder conectarnos a la Raspberry Pi desde la m\u00e1quina virtual de distintas formas. Tras finalizar el proceso de arranque iniciaremos sesi\u00f3n con el usuario kernel y contrase\u00f1a kernel . Recordad que la cuenta de usuario tiene \"permisos de sudo \". Para ejecutar un comando como root , cuando sea preciso, se ha de hacer lo siguiente: sudo <comando> y teclear la contrase\u00f1a del usuario en cuesti\u00f3n (no la de root ) cuando la solicite. Para abrir un shell de root, debemos usar el siguiente comando: sudo -i Conexi\u00f3n de dispositivos USB a la m\u00e1quina virtual \u00b6 Para poder acceder v\u00eda Ethernet y v\u00eda puerto serie a la Raspberry Pi desde la m\u00e1quina virtual, es preciso ahora conectar la interfaz Ethernet USB y el cable USB TTL a nuestro equipo. La interfaz Ethernet debe estar conectada usando un cable Ethernet a la Raspberry Pi, y el cable USB TTL tambi\u00e9n debe estar conectado a la placa tal y como se mostr\u00f3 en el video descriptivo. Al conectar ambos dispositivos USB a nuestro equipo, los dispositivos deber\u00edan listarse correctamente en la entrada de men\u00fa \"USB & Bluetooth\" de VMWare, tal y como se muestra en la siguiente imagen: En la captura de pantalla, la interfaz Ethernet conectada figura como \"ASIX AX88772B\" (el modelo de la interfaz proporcionado con el material de laboratorios podr\u00eda ser diferente), y el cable USB TTL como \"Future Devices TTL232R-3V3\". Para que la m\u00e1quina virtual tenga el control de ambos dispositivos es necesario hacer clic en la entrada de men\u00fa con etiqueta \"Connect ...\" para los dos dispositivos. Al hacer esto, el men\u00fa \"USB & Bluetooth\" deber\u00eda mostrar ahora la etiqueta \"Disconnect ...\" para ambos dispositivos: Procederemos ahora a comprobar si el dispositivo /dev/ttyUSB0 est\u00e1 presente, lo cual indicar\u00e1 que el cable USB TTL ha sido reconocido adecuadamente por el sistema Debian. Para ello, abriremos una ventana de terminal dentro de la m\u00e1quina virtual y ejecutaremos el siguiente comando: kernel@debian:~$ ls -l /dev/ttyUSB0 crw-rw---- 1 root dialout 188 , 0 abr 3 18 :47 /dev/ttyUSB0 Para verificar que la interfaz de red USB se ha reconocido correctamente ejecutaremos el comando ip a , que deber\u00eda listar tres interfaces de red: loopback ( lo ), la interfaz ethernet de la propia m\u00e1quina virtual ( ens33 ) y, en \u00faltimo lugar, la interfaz USB Ethernet: kernel@debian:~$ ip a 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2 : ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00 :0c:29:c4:71:56 brd ff:ff:ff:ff:ff:ff inet 192 .168.127.131/24 brd 192 .168.127.255 scope global dynamic noprefixroute ens33 valid_lft 1624sec preferred_lft 1624sec inet6 fe80::20c:29ff:fec4:7156/64 scope link noprefixroute valid_lft forever preferred_lft forever 3 : enx00001b3c0049: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000 link/ether 00 :00:1b:3c:00:49 brd ff:ff:ff:ff:ff:ff Llegados a este punto es crucial anotar el nombre asignado por Linux para la interfaz USB Ethernet conectada a nuestro equipo, ya que este nombre deber\u00e1 almacenarse en dos ficheros que editaremos a continuaci\u00f3n. Esto es preciso para configurar correctamente la red interna, por donde estableceremos comunicaci\u00f3n con la Raspberry Pi. En particular, es preciso realizar lo siguiente: Reemplazar los ficheros /usr/local/bin/setup-network.sh y /etc/hosts con la versi\u00f3n de los mismos que se encuentra aqu\u00ed . Para ello se pueden ejecutar los siguientes comandos: # Crear directorio temporal para almacenar los ficheros kernel@debian:~$ mkdir /tmp/new kernel@debian:~$ cd /tmp/new # Descargar ficheros en directorio temporal con wget kernel@debian:/tmp/new$ wget https://jcsaezal.github.io/lin-ucm-docs/code/fixed-files.tgz wget https://jcsaezal.github.io/lin-ucm-docs/code/fixed-files.tgz --2024-10-25 16 :08:19-- https://jcsaezal.github.io/lin-ucm-docs/code/fixed-files.tgz Resolviendo jcsaezal.github.io ( jcsaezal.github.io ) ... 185 .199.111.153, 185 .199.109.153, 185 .199.108.153, ... Conectando con jcsaezal.github.io ( jcsaezal.github.io )[ 185 .199.111.153 ] :443... conectado. Petici\u00f3n HTTP enviada, esperando respuesta... 200 OK Longitud: 1293 ( 1 ,3K ) [ application/octet-stream ] Grabando a: \u00abfixed-files.tgz\u00bb fixed-files.tgz 100 % [=================== > ] 1 ,26K --.-KB/s en 0s 2024 -10-25 16 :08:19 ( 97 ,2 MB/s ) - \u00abfixed-files.tgz\u00bb guardado [ 1293 /1293 ] kernel@debian:/tmp/new$ tar xzvf fixed-files.tgz ./._copy_files.sh copy_files.sh ./._hosts hosts ./._setup-network.sh setup-network.sh # Reemplazar ficheros necesarios usando el script que se proporciona (Introducir contrase\u00f1a usuario kernel si la solicita) kernel@debian:/tmp/new$ ./copy_files.sh Efectuar las siguientes modificaciones en el fichero /etc/network/interfaces como root (p.ej.: sudo nano /etc/network/interfaces ) Descomentar las 4 \u00faltimas l\u00edneas del fichero, eliminando el s\u00edmbolo \"#\" al principio de las 4 l\u00edneas: #auto enx00001b3c0049 #iface enx00001b3c0049 inet static #address 192.168.2.1 #netmask 255.255.255.0 Tras descomentar estas l\u00edneas, se ha de establecer el nombre asignado a la interfaz USB Ethernet en nuestro sistema en las dos primeras l\u00edneas de ese fragmento de texto. As\u00ed, por ejemplo, si el nombre de la interfaz USB Ethernet mostrado por ip a fuese \"enx00001b3c7740\", las \u00faltimas 4 l\u00edneas del fichero /etc/network/interfaces deber\u00edan ser las siguientes: auto enx00001b3c7740 iface enx00001b3c7740 inet static address 192.168.2.1 netmask 255.255.255.0 Editar el script /usr/local/bin/setup-network.sh como root (p.ej.: sudo nano /usr/local/bin/setup-network.sh ) Modificar la primera l\u00ednea del fichero (definici\u00f3n de variable ifname ) para establecer correctamente el nombre de la interfaz USB Ethernet de nuestro equipo. As\u00ed por ejemplo, si el nombre de la interfaz USB Ethernet fuese \"enx00001b3c7740\", el contenido del fichero /usr/local/bin/setup-network.sh deber\u00eda quedar de la siguiente forma: #!/bin/bash ifname = \"enx00001b3c7740\" service networking restart iptables -A FORWARD --in-interface ${ ifname } -j ACCEPT iptables --table nat -A POSTROUTING --out-interface ens33 -j MASQUERADE iptables -I DOCKER-USER -o ${ ifname } -i ens33 -j ACCEPT sysctl -w net.ipv4.ip_forward = 1 Tras llevar a cabo estas modificaciones en los ficheros, procederemos a configurar la red interna ejecutando el script setup-network.sh con sudo : kernel@debian:~$ sudo setup-network.sh net.ipv4.ip_forward = 1 Nota importante : Para establecer correctamente la configuraci\u00f3n de la red interna, este script deber\u00e1 ejecutarse manualmente siempre que se reinicie la m\u00e1quina virtual (MV) de Debian, y siempre asegur\u00e1ndonos que la interfaz USB Ethernet est\u00e1 conectada a la MV. Primer arranque de la Raspberry Pi \u00b6 Si se han realizado correctamente todos los pasos hasta este punto, la m\u00e1quina virtual deber\u00eda est\u00e1 correctamente configurada, incluyendo la red interna para conexi\u00f3n con la Raspberry Pi. Procederemos entonces a iniciar una sesi\u00f3n serie con la Raspberry Pi (no arrancar a\u00fan) desde la m\u00e1quina virtual, usando el programa minicom de la siguiente forma: $ sudo minicom ttyUSB0 Esto abrir\u00e1 la sesi\u00f3n serie de minicom: Welcome to minicom 2 .7.1 OPCIONES: I18n Compilado en May 6 2018 , 08 :02:47. Port /dev/ttyUSB0, 18 :47:08 Presione CTRL-A Z para obtener ayuda sobre teclas especiales En este preciso instante, arrancaremos la Raspberry Pi, y visualizaremos el proceso de arranque por la sesi\u00f3n serie de minicom. N\u00f3tese que el primer arranque de la placa puede tardar m\u00e1s de lo habitual (algunos minutos), ya que el sistema de ficheros de la partici\u00f3n ra\u00edz en la tarjeta SD est\u00e1 configurado para expandirse durante este primer arranque. Acabado el proceso de arranque, se mostrar\u00e1 el prompt de login a trav\u00e9s del puerto serie: [ OK ] Started triggerhappy global hotkey daemon. [ OK ] Finished Check for glamor. [ OK ] Finished Check for v3d driver. [ OK ] Finished Remove Stale Onli\u2026ext4 Metadata Check Snapshots. [ OK ] Started System Logging Service. [ OK ] Finished dphys-swapfile - \u2026mount, and delete a swap file. [ OK ] Started LSB: rng-tools ( Debian variant ) . [ OK ] Started User Login Management. [ OK ] Started Avahi mDNS/DNS-SD Stack. [ OK ] Started WPA supplicant. Starting Authorization Manager... [ OK ] Finished Raise network interfaces. [ OK ] Reached target Network. Starting CUPS Scheduler... Starting /etc/rc.local Compatibility... Starting OpenBSD Secure Shell server... Starting Permit User Sessions... My IP address is 192 .168.2.20 [ OK ] Started VNC Server in Service Mode daemon. [ OK ] Started /etc/rc.local Compatibility. [ OK ] Finished Permit User Sessions. Starting Light Display Manager... Starting Hold until boot process finishes up... [ OK ] Started LSB: Switch to ond\u2026 ( unless shift key is pressed ) . [ OK ] Started Authorization Manager. [ OK ] Started OpenBSD Secure Shell server. Raspbian GNU/Linux 11 raspberrypi ttyS0 raspberrypi login: CTRL-A Z for help | 115200 8N1 | NOR | Minicom 2 .7.1 | VT102 | Desconectado | ttyUSB0 Opcionalmente en este paso se puede realizar login (si se desea) a trav\u00e9s del puerto serie utlizando las siguientes credenciales: nombre de usuario: pi Contrase\u00f1a: raspberry Prueba de conexi\u00f3n por SSH a la Raspberry Pi desde la m\u00e1quina virtual \u00b6 Considerando que la configuraci\u00f3n de red se ha realizado correctamente, la Raspberry Pi deber\u00eda ser accesible por SSH desde la m\u00e1quina virtual utilizando la direcci\u00f3n IP est\u00e1tica 192.198.2.20, o alternativamente el nombre de host pi , que figura en el fichero /etc/hosts de la m\u00e1quina virtual. A continuaci\u00f3n se muestra el resultado de acceder por SSH a la Raspberry Pi la primera vez desde la m\u00e1quina virtual (usuario: \"pi\", contrase\u00f1a: \"raspberry\"): kernel@debian:~$ ssh pi@pi The authenticity of host 'pi (192.168.2.20)' can 't be established. ECDSA key fingerprint is SHA256:w+zPKbk0eA66xKatEQMe/Hr70SST88LrvHlsF7CfiQE. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added ' pi,192.168.2.20 ' (ECDSA) to the list of known hosts. pi@pi' s password: Linux raspberrypi 5 .10.92-v7+ #1514 SMP Mon Jan 17 17:36:39 GMT 2022 armv7l The programs included with the Debian GNU/Linux system are free software ; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Sun Oct 2 21 :15:07 2022 SSH is enabled and the default password for the 'pi' user has not been changed. This is a security risk - please login as the 'pi' user and type 'passwd' to set a new password. Wi-Fi is currently blocked by rfkill. Use raspi-config to set the country before use. pi@raspberrypi:~ $ Para garantizar que la configuraci\u00f3n de red es completamente funcional, comprobaremos que la Raspberry Pi tiene acceso a Internet, ejecutando el siguiente comando (a cancelar manualmente con CTRL+C): pi@raspberrypi:~ $ ping www.google.es PING www.google.es ( 142 .250.201.67 ) 56 ( 84 ) bytes of data. 64 bytes from mad07s25-in-f3.1e100.net ( 142 .250.201.67 ) : icmp_seq = 2 ttl = 127 time = 7 .62 ms 64 bytes from mad07s25-in-f3.1e100.net ( 142 .250.201.67 ) : icmp_seq = 3 ttl = 127 time = 8 .10 ms 64 bytes from mad07s25-in-f3.1e100.net ( 142 .250.201.67 ) : icmp_seq = 4 ttl = 127 time = 9 .16 ms 64 bytes from mad07s25-in-f3.1e100.net ( 142 .250.201.67 ) : icmp_seq = 5 ttl = 127 time = 11 .0 ms 64 bytes from mad07s25-in-f3.1e100.net ( 142 .250.201.67 ) : icmp_seq = 6 ttl = 127 time = 12 .1 ms ^C --- www.google.es ping statistics --- 6 packets transmitted, 5 received, 16 .6667% packet loss, time 5051ms rtt min/avg/max/mdev = 7 .615/9.594/12.143/1.713 ms pi@raspberrypi:~ $ Comprobaci\u00f3n del funcionamiento de la placa de E/S y de su configuraci\u00f3n \u00b6 Concluiremos la preparaci\u00f3n del entorno de trabajo comprobando que las conexiones realizadas en la placa Bee v2.0 (punto 1 de esta gu\u00eda), son correctas, y que por tanto, los dispositivos correspondientes que se usar\u00e1n en las pr\u00e1cticas (ver imagen a continuaci\u00f3n) son completamente funcionales. Para realizar las comprobaciones pertinentes es preciso haber descargado primero los ficheros de la primera pr\u00e1ctica sobre drivers . Los comandos que se muestran a continuaci\u00f3n asumen que el fichero TAR.GZ correspondiente se ha extra\u00eddo en el directorio HOME del usuario kernel , por lo que existir\u00e1 un directorio TestBee en su interior, donde podr\u00e1n encontrarse cuatro scripts: pi@raspberrypi:~ $ cd TestBee/ pi@raspberrypi:~/TestBee $ ls 7sdisplay_test.py button_test.py buzzer_test.sh leds_test.py Estos scripts permiten controlar el estado del display 7 segmentos de la placa, modificar el estado de los LEDS D1-D3, reproducir notas musicales con el buzzer pasivo, y comprobar si el pulsador SW1 est\u00e1 o no pulsado, todo ello desde espacio de usuario. Cabe destacar que en las pr\u00e1cticas de este curso nos centraremos en el acceso a estos dispositivos desde el kernel Linux. Por lo tanto, se deja como ejercicio el estudio del c\u00f3digo de los scripts proporcionados, donde se accede a todos estos dispositivos desde espacio de usuario. Comenzaremos ejecutando el script ./leds_test.py . Si las conexiones se han realizado correctamente, el script encender\u00e1 y apagar\u00e1 alternativamente los tres LEDs de la placa Bee (D1, D2 y D3). La ejecuci\u00f3n del script tendr\u00e1 que cancelarse manualmente con CTRL+C, tras comprobar que los LEDs se apagan y enciencen alternativamente: pi@raspberrypi:~/TestBee $ ./leds_test.py ^CTraceback ( most recent call last ) : File \"/home/pi/TestBee/./leds_test.py\" , line 20 , in <module> time.sleep ( 0 .5 ) KeyboardInterrupt En segundo lugar probaremos el funcionamiento del pulsador SW1, que se encuentra debajo de los LEDs. El script ./button_test.py muestra periodicamente el estado del circuito del pulsador SW1, imprimiendo \"Closed\" cuando el pulsador no est\u00e9 pulsado, y \"Open\" al mantener presionado el pulsador. De nuevo, la ejecuci\u00f3n del script ha de interrumpirse manualmente con CTRL+C al finalizar la prueba: pi@raspberrypi:~/TestBee $ ./button_test.py Closed Closed Closed Closed Closed Closed Closed Closed Closed Closed Closed Closed Closed Open Open Open Open Open Open Open Open Open Closed Closed Closed Closed Open Open Open Open Open Open Closed Closed Closed Closed Closed Closed ^CTraceback ( most recent call last ) : File \"/home/pi/TestBee/./button_test.py\" , line 17 , in <module> time.sleep ( 0 .2 ) Probaremos ahora el display 7 segmentos mediante el script 7sdisplay_test.py . Si las conexiones se han realizado correctamente, el script mostrar\u00e1 continuamente la secuencia hexadecimal de n\u00fameros 0,1,2,..., F. La ejecuci\u00f3n del script tendr\u00e1 que cancelarse tecleando CTRL+C: pi@raspberrypi:~/Code/TestBee $ ./7sdisplay_test.py ======================================== | LEDs with 74HC595 | | | | Control LEDs with 74HC595 | | | ======================================== Program is running... Please press Ctrl+C to end the program... ^Cpi@raspberrypi:~/Code/TestBee $ Finalmente, se comprobar\u00e1 el funcionamiento del buzzer pasivo, mediante el script buzzer_test.sh . Este script configura el buzzer para la reproducci\u00f3n de la siguiente secuencia de notas: LA4, MI4 y LA4 (cada una de ellas durante un segundo). Este script, a diferencia de los anteriores, ha de ejecutarse con sudo : pi@raspberrypi:~/TestBee $ sudo ./buzzer_test.sh Exporting PWM0 channel Testing Passive Buzzer A4 .. E4 .. A4 Done Unexporting PWM0 channel An\u00e1lisis de alternativas para desarrollo en la Raspberry Pi desde la m\u00e1quina virtual. Configuraci\u00f3n de VSCode. \u00b6 Por motivos de rendimiento se aconseja almacenar en el directorio HOME del usuario pi --en la propia Raspberry Pi (tarjeta SD)-- los ficheros fuente de los m\u00f3dulos del kernel a desarrollar en las pr\u00e1cticas. Tambi\u00e9n es recomendable hacer copia de seguridad de los ficheros cada cierto tiempo transfiri\u00e9ndolos al sistema host por red (p.ej., usando comando scp visto en clase). En este caso, usaremos el t\u00e9rmino \" host \" para referirnos a la m\u00e1quina virtual de Debian, que es desde donde nos comunicaremos por red con la placa Raspberry Pi. Conectarse a la placa por SSH desde la m\u00e1quina virtual ser\u00e1 algo muy frecuente durante la realizaci\u00f3n de las pr\u00e1cticas. Por este motivo, se aconseja configurar el acceso a la Raspberry Pi sin contrase\u00f1a, es decir usando una clave SSH. Para establecer la configuraci\u00f3n han de seguirse los siguientes pasos dentro de la m\u00e1quina virtual: Si el fichero ~/.ssh/id_rsa.pub no existe, ha de crearse uno mediante el comando ssh-keygen -t rsa -b 2048 . En nuestro caso teclearemos ENTER a continuaci\u00f3n para aceptar la ruta por defecto del fichero, y NO establecer passphrase : kernel@debian:~$ ssh-keygen -t rsa -b 2048 Generating public/private rsa key pair. Enter file in which to save the key ( /home/kernel/.ssh/id_rsa ) : Enter passphrase ( empty for no passphrase ) : Enter same passphrase again: Your identification has been saved in /home/kernel/.ssh/id_rsa. Your public key has been saved in /home/kernel/.ssh/id_rsa.pub. The key fingerprint is: SHA256:6IdQ3RHxf8QeyZRmCgN1j2l7u5v/Dx18VPLjmxamRy8 kernel@debian The key ' s randomart image is: +--- [ RSA 2048 ] ----+ | .*+ ...o | | . . = . *Bo | | . . . +++* = | | . . .o++o | | . . S ..O+ | | o . = oO | | o . .E*o | | . ooo | | +O | +---- [ SHA256 ] -----+ Dar de alta la clave SSH generada en el registro del usuario pi dentro de la Raspberry Pi. Para ello haremos uso del comando ssh-copy-id como se muestra a continuaci\u00f3n, y tecleando la contrase\u00f1a del usuario ( raspberry ) cuando nos lo solicite: kernel@debian:~$ ssh-copy-id pi@pi /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key ( s ) , to filter out any that are already installed /usr/bin/ssh-copy-id: INFO: 1 key ( s ) remain to be installed -- if you are prompted now it is to install the new keys pi@pi 's password: Number of key(s) added: 1 Now try logging into the machine, with: \"ssh ' pi@pi ' \" and check to make sure that only the key(s) you wanted were added. Llegados a este punto ya podremos conectarnos por SSH a la Raspberry Pi sin teclear la contrase\u00f1a, y usando por debajo la clave SSH generada: kernel@debian:~$ ssh pi@pi Linux raspberrypi 5 .10.92-v7+ #1514 SMP Mon Jan 17 17:36:39 GMT 2022 armv7l The programs included with the Debian GNU/Linux system are free software ; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Sat Sep 24 18 :07:44 2022 from 192 .168.2.1 SSH is enabled and the default password for the 'pi' user has not been changed. This is a security risk - please login as the 'pi' user and type 'passwd' to set a new password. Wi-Fi is currently blocked by rfkill. Use raspi-config to set the country before use. pi@raspberrypi:~ $ Existen esencialmente tres alternativas para desarrollar las pr\u00e1cticas sobre la Raspberry Pi, compilando los m\u00f3dulos del kernel desde la propia placa^[Tambi\u00e9n es posible almacenar, editar los ficheros, y compilar los m\u00f3dulos desde el sistema host , empleando compilaci\u00f3n cruzada. Sin embargo esto conlleva copiar los .ko correspondientes a la placa para testear su funcionalidad.]. A continuaci\u00f3n se describen las distintas opciones. Opci\u00f3n 1: Ejecuci\u00f3n del editor en la propia placa \u00b6 Editar los ficheros con programa editor instalado en la propia placa, lanzando el editor por SSH. Pueden utilizarse para ello editores de l\u00ednea de comandos (como vim o nano ) o incluso editores gr\u00e1ficos como geany (esto exige activar la opci\u00f3n -X al conectarse por SSH: ssh -X pi@pi ). La compilaci\u00f3n debe llevarse a cabo desde un shell SSH dentro de la propia Raspberry Pi. Opci\u00f3n 2: SSHFS y edici\u00f3n de ficheros desde el host \u00b6 El sistema de ficheros de la Raspberry Pi se puede montar en el host (m\u00e1quina virtual de Debian) por SSH usando el comando sshfs , como en el siguiente ejemplo: kernel@debian:~$ mkdir home-raspberry kernel@debian:~$ sshfs pi@pi:/home/pi home-raspberry kernel@debian:~$ ls home-raspberry/ Bookshelf Desktop Downloads Pictures Videos Documents Music Public Templates En el ejemplo se crea un directorio vac\u00edo home-raspberry (puede usarse el nombre que se desee), que se emplea como punto de montaje. Gracias al comando sshfs del ejemplo se monta el directorio HOME del usuario pi de la Raspberry en el directorio ~/home-raspberry del host . Una vez montada la carpeta por SSH se pueden editar los ficheros con cualquier editor en el host, ya sea por l\u00ednea de comandos o gr\u00e1ficamente (p.ej., con Sublime Text o VSCode). SSHFS transfiere autom\u00e1ticamente los ficheros a la Raspberry cuando detecta cambios en los mismos, y sin requerir intervenci\u00f3n del usuario. Cuando se haya acabado de trabajar con los ficheros, o cuando se desee reiniciar o apagar la Raspberry Pi, se ha de desmontar la carpeta montada usando fusermount : kernel@debian:~$ fusermount -u home-raspberry kernel@debian:~$ Opci\u00f3n 3: Uso de extensi\u00f3n Remote de VSCode para trabajar con Raspberry Pi de forma transparente \u00b6 VSCode posee una extensi\u00f3n llamada Remote que permite trabajar con una o varias carpetas de un sistema accesible por SSH^[Este plugin de VSCode tambi\u00e9n soporta trabajar con WSL y contenedores Docker.] como si de una carpeta local se tratara. Una vez se ha establecido la conexi\u00f3n de VSCode con el sistema remoto, los terminales abiertos dentro del propio entorno se ejecutar\u00e1n en la m\u00e1quina a la que nos hemos conectado. Por lo tanto, cada terminal se corresponde con un shell SSH en la m\u00e1quina target (la Raspberry Pi en nuestro caso). En definitiva, de esta forma tendremos la ilusi\u00f3n de que trabajamos con VSCode desde dentro del propio sistema target , pero usando el entorno gr\u00e1fico del host de desarrollo. La extensi\u00f3n Remote ya est\u00e1 instalada en la m\u00e1quina virtual del laboratorio. No obstante, hemos de configurar dicha extensi\u00f3n para trabajar con la Raspberry Pi. Para ilustrar el proceso de configuraci\u00f3n de Remote desde la m\u00e1quina virtual se proporciona el v\u00eddeo mostrado a continuaci\u00f3n. En el v\u00eddeo se asume que se ha habilitado el acceso por SSH sin contrase\u00f1a (v\u00eda clave SSH) a la Raspberry Pi siguiendo las instrucciones mostradas m\u00e1s arriba. Una vez que la Raspberry Pi se ha dado de alta como remote dentro de VSCode --como se ilustra en el v\u00eddeo--, dicho remote permanecer\u00e1 registrado en futuras ejecuciones de VSCode. Por lo tanto, para trabajar con ficheros en la placa bastar\u00e1 abrir la carpeta deseada desde el explorador de Remotes . Por \u00faltimo, se ha de tener presente que cuando hacemos uso de la extensi\u00f3n Remote , es necesario instalar las extensiones de VSCode que deseemos para desarrollar desde ese target al que nos conectamos. Para trabajar con la Raspberry Pi, se recomienda instalar las extensiones est\u00e1ndar de VSCode para desarollo C/C++. La instalaci\u00f3n debe hacerse desde una ventana de Remote.","title":"Drivers en Linux. Preparaci\u00f3n del entorno de trabajo"},{"location":"linux-kernel/config/#drivers-en-linux-preparacion-del-entorno-de-trabajo","text":"Esta breve gu\u00eda describe el procedimiento de configuraci\u00f3n del sistema formado por la Raspberry Pi (en su variante 3B+ o 4) y la placa de entrada salida Bee v2.0, para la realizaci\u00f3n de pr\u00e1cticas sobre desarrollo de Drivers en Linux. Esencialmente, para preparar este entorno de pr\u00e1cticas deben realizarse los siguientes pasos: Configuraci\u00f3n hardware de placa de entrada-salida (\"Bee v2.0\") para realizaci\u00f3n de pr\u00e1cticas Configuraci\u00f3n inicial de la m\u00e1quina virtual y de la red interna para conexi\u00f3n con la Raspberry Pi Arranque por primera vez de la Raspberry Pi usando imagen custom preparada para las pr\u00e1cticas Prueba de conexi\u00f3n por SSH a la Raspberry Pi desde la m\u00e1quina virtual Comprobaci\u00f3n del funcionamiento de la placa de E/S y de su configuraci\u00f3n An\u00e1lisis de alternativas para desarrollo en la Raspberry Pi desde la m\u00e1quina virtual. Configuraci\u00f3n de VSCode. Adem\u00e1s del equipo con la m\u00e1quina virtual instalada, y de la Raspberry Pi conectada a la placa de E/S, se requiere disponer del siguiente material para la realizaci\u00f3n de los distintos pasos: Scripts de comprobaci\u00f3n de conexiones de la placa Bee : Se encuentran en el directorio TestBee de los ficheros de ejemplo proporcionados con la primera pr\u00e1ctica de drivers . Tarjeta SD de al menos 16GB : En esta tarjeta se ha de instalar una imagen custom de Raspberry Pi OS. El fichero de imagen ( raspberry-pi-os_030422.img ) puede descargarse usando este enlace de Google Drive . Para la instalaci\u00f3n/restauraci\u00f3n de la imagen puede emplearse la aplicaci\u00f3n gratuita multiplataforma balenaEtcher que puede descargarse aqu\u00ed . La instalaci\u00f3n de la imagen es un proceso muy sencillo. Basta seleccionar el fichero de imagen descargado previamente en nuestro equipo (fichero raspberry-pi-os_030422.img ) , escoger la unidad de la tarjeta SD de 16GB donde instalar la imagen (accesible mediante un lector de tarjetas SD), y finalmente hacer clic en Flash. Cable USB TTL Interfaz USB Ethernet Cable Ethernet 7 cables dupont hembra-hembra Dos jumpers (o en su defecto dos cables dupont hembra-hembra adicionales para interconectar 4 pines de la placa Bee v2.0)","title":"Drivers en Linux. Preparaci\u00f3n del entorno de trabajo"},{"location":"linux-kernel/config/#configuracion-hardware-de-placa-de-entrada-salida-bee-v20-para-realizacion-de-practicas","text":"La placa de E/S Bee v2.0 que se utilizar\u00e1 en las pr\u00e1cticas de desarrollo de drivers consta de una serie de circuitos desacoplados para la gesti\u00f3n de distintos dispositivos como LEDs, pulsadores, un zumbador ( buzzer ) pasivo, etc. Antes de proceder a arrancar la Raspberry Pi usando la imagen del sistema operativo instalado en la tarjeta SD es preciso realizar distintas conexiones entre pines espec\u00edficos de la placa (GPIOs) y los pines de entrada o salida de los circuitos que controlan los distintos dispositivos a utilizar. Asimismo, es necesario conectar el cable USB TTL para poder visualizar la salida del puerto serie de la placa desde la m\u00e1quina virtual de Debian. La siguiente figura muestra los m\u00f3dulos de pines (J3, J4, J5, J6, J13 y J17) donde se realizar\u00e1n las conexiones necesarias usando 7 cables dupont hembra-hembra y 2 jumpers (o, dos cables dupont extra, si no se dispone de jumpers ). El siguiente video ilustra c\u00f3mo realizar las interconexiones de los pines que se requieren para las pr\u00e1cticas:","title":"Configuraci\u00f3n hardware de placa de entrada-salida (\"Bee v2.0\") para realizaci\u00f3n de pr\u00e1cticas"},{"location":"linux-kernel/config/#configuracion-inicial-de-la-maquina-virtual-y-de-la-red-interna","text":"En este paso procederemos a arrancar la m\u00e1quina virtual de Debian VMWare, y realizaremos la configuraci\u00f3n m\u00ednima necesaria para poder conectarnos a la Raspberry Pi desde la m\u00e1quina virtual de distintas formas. Tras finalizar el proceso de arranque iniciaremos sesi\u00f3n con el usuario kernel y contrase\u00f1a kernel . Recordad que la cuenta de usuario tiene \"permisos de sudo \". Para ejecutar un comando como root , cuando sea preciso, se ha de hacer lo siguiente: sudo <comando> y teclear la contrase\u00f1a del usuario en cuesti\u00f3n (no la de root ) cuando la solicite. Para abrir un shell de root, debemos usar el siguiente comando: sudo -i","title":"Configuraci\u00f3n inicial de la m\u00e1quina virtual y de la red interna"},{"location":"linux-kernel/config/#conexion-de-dispositivos-usb-a-la-maquina-virtual","text":"Para poder acceder v\u00eda Ethernet y v\u00eda puerto serie a la Raspberry Pi desde la m\u00e1quina virtual, es preciso ahora conectar la interfaz Ethernet USB y el cable USB TTL a nuestro equipo. La interfaz Ethernet debe estar conectada usando un cable Ethernet a la Raspberry Pi, y el cable USB TTL tambi\u00e9n debe estar conectado a la placa tal y como se mostr\u00f3 en el video descriptivo. Al conectar ambos dispositivos USB a nuestro equipo, los dispositivos deber\u00edan listarse correctamente en la entrada de men\u00fa \"USB & Bluetooth\" de VMWare, tal y como se muestra en la siguiente imagen: En la captura de pantalla, la interfaz Ethernet conectada figura como \"ASIX AX88772B\" (el modelo de la interfaz proporcionado con el material de laboratorios podr\u00eda ser diferente), y el cable USB TTL como \"Future Devices TTL232R-3V3\". Para que la m\u00e1quina virtual tenga el control de ambos dispositivos es necesario hacer clic en la entrada de men\u00fa con etiqueta \"Connect ...\" para los dos dispositivos. Al hacer esto, el men\u00fa \"USB & Bluetooth\" deber\u00eda mostrar ahora la etiqueta \"Disconnect ...\" para ambos dispositivos: Procederemos ahora a comprobar si el dispositivo /dev/ttyUSB0 est\u00e1 presente, lo cual indicar\u00e1 que el cable USB TTL ha sido reconocido adecuadamente por el sistema Debian. Para ello, abriremos una ventana de terminal dentro de la m\u00e1quina virtual y ejecutaremos el siguiente comando: kernel@debian:~$ ls -l /dev/ttyUSB0 crw-rw---- 1 root dialout 188 , 0 abr 3 18 :47 /dev/ttyUSB0 Para verificar que la interfaz de red USB se ha reconocido correctamente ejecutaremos el comando ip a , que deber\u00eda listar tres interfaces de red: loopback ( lo ), la interfaz ethernet de la propia m\u00e1quina virtual ( ens33 ) y, en \u00faltimo lugar, la interfaz USB Ethernet: kernel@debian:~$ ip a 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2 : ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00 :0c:29:c4:71:56 brd ff:ff:ff:ff:ff:ff inet 192 .168.127.131/24 brd 192 .168.127.255 scope global dynamic noprefixroute ens33 valid_lft 1624sec preferred_lft 1624sec inet6 fe80::20c:29ff:fec4:7156/64 scope link noprefixroute valid_lft forever preferred_lft forever 3 : enx00001b3c0049: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000 link/ether 00 :00:1b:3c:00:49 brd ff:ff:ff:ff:ff:ff Llegados a este punto es crucial anotar el nombre asignado por Linux para la interfaz USB Ethernet conectada a nuestro equipo, ya que este nombre deber\u00e1 almacenarse en dos ficheros que editaremos a continuaci\u00f3n. Esto es preciso para configurar correctamente la red interna, por donde estableceremos comunicaci\u00f3n con la Raspberry Pi. En particular, es preciso realizar lo siguiente: Reemplazar los ficheros /usr/local/bin/setup-network.sh y /etc/hosts con la versi\u00f3n de los mismos que se encuentra aqu\u00ed . Para ello se pueden ejecutar los siguientes comandos: # Crear directorio temporal para almacenar los ficheros kernel@debian:~$ mkdir /tmp/new kernel@debian:~$ cd /tmp/new # Descargar ficheros en directorio temporal con wget kernel@debian:/tmp/new$ wget https://jcsaezal.github.io/lin-ucm-docs/code/fixed-files.tgz wget https://jcsaezal.github.io/lin-ucm-docs/code/fixed-files.tgz --2024-10-25 16 :08:19-- https://jcsaezal.github.io/lin-ucm-docs/code/fixed-files.tgz Resolviendo jcsaezal.github.io ( jcsaezal.github.io ) ... 185 .199.111.153, 185 .199.109.153, 185 .199.108.153, ... Conectando con jcsaezal.github.io ( jcsaezal.github.io )[ 185 .199.111.153 ] :443... conectado. Petici\u00f3n HTTP enviada, esperando respuesta... 200 OK Longitud: 1293 ( 1 ,3K ) [ application/octet-stream ] Grabando a: \u00abfixed-files.tgz\u00bb fixed-files.tgz 100 % [=================== > ] 1 ,26K --.-KB/s en 0s 2024 -10-25 16 :08:19 ( 97 ,2 MB/s ) - \u00abfixed-files.tgz\u00bb guardado [ 1293 /1293 ] kernel@debian:/tmp/new$ tar xzvf fixed-files.tgz ./._copy_files.sh copy_files.sh ./._hosts hosts ./._setup-network.sh setup-network.sh # Reemplazar ficheros necesarios usando el script que se proporciona (Introducir contrase\u00f1a usuario kernel si la solicita) kernel@debian:/tmp/new$ ./copy_files.sh Efectuar las siguientes modificaciones en el fichero /etc/network/interfaces como root (p.ej.: sudo nano /etc/network/interfaces ) Descomentar las 4 \u00faltimas l\u00edneas del fichero, eliminando el s\u00edmbolo \"#\" al principio de las 4 l\u00edneas: #auto enx00001b3c0049 #iface enx00001b3c0049 inet static #address 192.168.2.1 #netmask 255.255.255.0 Tras descomentar estas l\u00edneas, se ha de establecer el nombre asignado a la interfaz USB Ethernet en nuestro sistema en las dos primeras l\u00edneas de ese fragmento de texto. As\u00ed, por ejemplo, si el nombre de la interfaz USB Ethernet mostrado por ip a fuese \"enx00001b3c7740\", las \u00faltimas 4 l\u00edneas del fichero /etc/network/interfaces deber\u00edan ser las siguientes: auto enx00001b3c7740 iface enx00001b3c7740 inet static address 192.168.2.1 netmask 255.255.255.0 Editar el script /usr/local/bin/setup-network.sh como root (p.ej.: sudo nano /usr/local/bin/setup-network.sh ) Modificar la primera l\u00ednea del fichero (definici\u00f3n de variable ifname ) para establecer correctamente el nombre de la interfaz USB Ethernet de nuestro equipo. As\u00ed por ejemplo, si el nombre de la interfaz USB Ethernet fuese \"enx00001b3c7740\", el contenido del fichero /usr/local/bin/setup-network.sh deber\u00eda quedar de la siguiente forma: #!/bin/bash ifname = \"enx00001b3c7740\" service networking restart iptables -A FORWARD --in-interface ${ ifname } -j ACCEPT iptables --table nat -A POSTROUTING --out-interface ens33 -j MASQUERADE iptables -I DOCKER-USER -o ${ ifname } -i ens33 -j ACCEPT sysctl -w net.ipv4.ip_forward = 1 Tras llevar a cabo estas modificaciones en los ficheros, procederemos a configurar la red interna ejecutando el script setup-network.sh con sudo : kernel@debian:~$ sudo setup-network.sh net.ipv4.ip_forward = 1 Nota importante : Para establecer correctamente la configuraci\u00f3n de la red interna, este script deber\u00e1 ejecutarse manualmente siempre que se reinicie la m\u00e1quina virtual (MV) de Debian, y siempre asegur\u00e1ndonos que la interfaz USB Ethernet est\u00e1 conectada a la MV.","title":"Conexi\u00f3n de dispositivos USB a la m\u00e1quina virtual"},{"location":"linux-kernel/config/#primer-arranque-de-la-raspberry-pi","text":"Si se han realizado correctamente todos los pasos hasta este punto, la m\u00e1quina virtual deber\u00eda est\u00e1 correctamente configurada, incluyendo la red interna para conexi\u00f3n con la Raspberry Pi. Procederemos entonces a iniciar una sesi\u00f3n serie con la Raspberry Pi (no arrancar a\u00fan) desde la m\u00e1quina virtual, usando el programa minicom de la siguiente forma: $ sudo minicom ttyUSB0 Esto abrir\u00e1 la sesi\u00f3n serie de minicom: Welcome to minicom 2 .7.1 OPCIONES: I18n Compilado en May 6 2018 , 08 :02:47. Port /dev/ttyUSB0, 18 :47:08 Presione CTRL-A Z para obtener ayuda sobre teclas especiales En este preciso instante, arrancaremos la Raspberry Pi, y visualizaremos el proceso de arranque por la sesi\u00f3n serie de minicom. N\u00f3tese que el primer arranque de la placa puede tardar m\u00e1s de lo habitual (algunos minutos), ya que el sistema de ficheros de la partici\u00f3n ra\u00edz en la tarjeta SD est\u00e1 configurado para expandirse durante este primer arranque. Acabado el proceso de arranque, se mostrar\u00e1 el prompt de login a trav\u00e9s del puerto serie: [ OK ] Started triggerhappy global hotkey daemon. [ OK ] Finished Check for glamor. [ OK ] Finished Check for v3d driver. [ OK ] Finished Remove Stale Onli\u2026ext4 Metadata Check Snapshots. [ OK ] Started System Logging Service. [ OK ] Finished dphys-swapfile - \u2026mount, and delete a swap file. [ OK ] Started LSB: rng-tools ( Debian variant ) . [ OK ] Started User Login Management. [ OK ] Started Avahi mDNS/DNS-SD Stack. [ OK ] Started WPA supplicant. Starting Authorization Manager... [ OK ] Finished Raise network interfaces. [ OK ] Reached target Network. Starting CUPS Scheduler... Starting /etc/rc.local Compatibility... Starting OpenBSD Secure Shell server... Starting Permit User Sessions... My IP address is 192 .168.2.20 [ OK ] Started VNC Server in Service Mode daemon. [ OK ] Started /etc/rc.local Compatibility. [ OK ] Finished Permit User Sessions. Starting Light Display Manager... Starting Hold until boot process finishes up... [ OK ] Started LSB: Switch to ond\u2026 ( unless shift key is pressed ) . [ OK ] Started Authorization Manager. [ OK ] Started OpenBSD Secure Shell server. Raspbian GNU/Linux 11 raspberrypi ttyS0 raspberrypi login: CTRL-A Z for help | 115200 8N1 | NOR | Minicom 2 .7.1 | VT102 | Desconectado | ttyUSB0 Opcionalmente en este paso se puede realizar login (si se desea) a trav\u00e9s del puerto serie utlizando las siguientes credenciales: nombre de usuario: pi Contrase\u00f1a: raspberry","title":"Primer arranque de la Raspberry Pi"},{"location":"linux-kernel/config/#prueba-de-conexion-por-ssh-a-la-raspberry-pi-desde-la-maquina-virtual","text":"Considerando que la configuraci\u00f3n de red se ha realizado correctamente, la Raspberry Pi deber\u00eda ser accesible por SSH desde la m\u00e1quina virtual utilizando la direcci\u00f3n IP est\u00e1tica 192.198.2.20, o alternativamente el nombre de host pi , que figura en el fichero /etc/hosts de la m\u00e1quina virtual. A continuaci\u00f3n se muestra el resultado de acceder por SSH a la Raspberry Pi la primera vez desde la m\u00e1quina virtual (usuario: \"pi\", contrase\u00f1a: \"raspberry\"): kernel@debian:~$ ssh pi@pi The authenticity of host 'pi (192.168.2.20)' can 't be established. ECDSA key fingerprint is SHA256:w+zPKbk0eA66xKatEQMe/Hr70SST88LrvHlsF7CfiQE. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added ' pi,192.168.2.20 ' (ECDSA) to the list of known hosts. pi@pi' s password: Linux raspberrypi 5 .10.92-v7+ #1514 SMP Mon Jan 17 17:36:39 GMT 2022 armv7l The programs included with the Debian GNU/Linux system are free software ; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Sun Oct 2 21 :15:07 2022 SSH is enabled and the default password for the 'pi' user has not been changed. This is a security risk - please login as the 'pi' user and type 'passwd' to set a new password. Wi-Fi is currently blocked by rfkill. Use raspi-config to set the country before use. pi@raspberrypi:~ $ Para garantizar que la configuraci\u00f3n de red es completamente funcional, comprobaremos que la Raspberry Pi tiene acceso a Internet, ejecutando el siguiente comando (a cancelar manualmente con CTRL+C): pi@raspberrypi:~ $ ping www.google.es PING www.google.es ( 142 .250.201.67 ) 56 ( 84 ) bytes of data. 64 bytes from mad07s25-in-f3.1e100.net ( 142 .250.201.67 ) : icmp_seq = 2 ttl = 127 time = 7 .62 ms 64 bytes from mad07s25-in-f3.1e100.net ( 142 .250.201.67 ) : icmp_seq = 3 ttl = 127 time = 8 .10 ms 64 bytes from mad07s25-in-f3.1e100.net ( 142 .250.201.67 ) : icmp_seq = 4 ttl = 127 time = 9 .16 ms 64 bytes from mad07s25-in-f3.1e100.net ( 142 .250.201.67 ) : icmp_seq = 5 ttl = 127 time = 11 .0 ms 64 bytes from mad07s25-in-f3.1e100.net ( 142 .250.201.67 ) : icmp_seq = 6 ttl = 127 time = 12 .1 ms ^C --- www.google.es ping statistics --- 6 packets transmitted, 5 received, 16 .6667% packet loss, time 5051ms rtt min/avg/max/mdev = 7 .615/9.594/12.143/1.713 ms pi@raspberrypi:~ $","title":"Prueba de conexi\u00f3n por SSH a la Raspberry Pi desde la m\u00e1quina virtual"},{"location":"linux-kernel/config/#comprobacion-del-funcionamiento-de-la-placa-de-es-y-de-su-configuracion","text":"Concluiremos la preparaci\u00f3n del entorno de trabajo comprobando que las conexiones realizadas en la placa Bee v2.0 (punto 1 de esta gu\u00eda), son correctas, y que por tanto, los dispositivos correspondientes que se usar\u00e1n en las pr\u00e1cticas (ver imagen a continuaci\u00f3n) son completamente funcionales. Para realizar las comprobaciones pertinentes es preciso haber descargado primero los ficheros de la primera pr\u00e1ctica sobre drivers . Los comandos que se muestran a continuaci\u00f3n asumen que el fichero TAR.GZ correspondiente se ha extra\u00eddo en el directorio HOME del usuario kernel , por lo que existir\u00e1 un directorio TestBee en su interior, donde podr\u00e1n encontrarse cuatro scripts: pi@raspberrypi:~ $ cd TestBee/ pi@raspberrypi:~/TestBee $ ls 7sdisplay_test.py button_test.py buzzer_test.sh leds_test.py Estos scripts permiten controlar el estado del display 7 segmentos de la placa, modificar el estado de los LEDS D1-D3, reproducir notas musicales con el buzzer pasivo, y comprobar si el pulsador SW1 est\u00e1 o no pulsado, todo ello desde espacio de usuario. Cabe destacar que en las pr\u00e1cticas de este curso nos centraremos en el acceso a estos dispositivos desde el kernel Linux. Por lo tanto, se deja como ejercicio el estudio del c\u00f3digo de los scripts proporcionados, donde se accede a todos estos dispositivos desde espacio de usuario. Comenzaremos ejecutando el script ./leds_test.py . Si las conexiones se han realizado correctamente, el script encender\u00e1 y apagar\u00e1 alternativamente los tres LEDs de la placa Bee (D1, D2 y D3). La ejecuci\u00f3n del script tendr\u00e1 que cancelarse manualmente con CTRL+C, tras comprobar que los LEDs se apagan y enciencen alternativamente: pi@raspberrypi:~/TestBee $ ./leds_test.py ^CTraceback ( most recent call last ) : File \"/home/pi/TestBee/./leds_test.py\" , line 20 , in <module> time.sleep ( 0 .5 ) KeyboardInterrupt En segundo lugar probaremos el funcionamiento del pulsador SW1, que se encuentra debajo de los LEDs. El script ./button_test.py muestra periodicamente el estado del circuito del pulsador SW1, imprimiendo \"Closed\" cuando el pulsador no est\u00e9 pulsado, y \"Open\" al mantener presionado el pulsador. De nuevo, la ejecuci\u00f3n del script ha de interrumpirse manualmente con CTRL+C al finalizar la prueba: pi@raspberrypi:~/TestBee $ ./button_test.py Closed Closed Closed Closed Closed Closed Closed Closed Closed Closed Closed Closed Closed Open Open Open Open Open Open Open Open Open Closed Closed Closed Closed Open Open Open Open Open Open Closed Closed Closed Closed Closed Closed ^CTraceback ( most recent call last ) : File \"/home/pi/TestBee/./button_test.py\" , line 17 , in <module> time.sleep ( 0 .2 ) Probaremos ahora el display 7 segmentos mediante el script 7sdisplay_test.py . Si las conexiones se han realizado correctamente, el script mostrar\u00e1 continuamente la secuencia hexadecimal de n\u00fameros 0,1,2,..., F. La ejecuci\u00f3n del script tendr\u00e1 que cancelarse tecleando CTRL+C: pi@raspberrypi:~/Code/TestBee $ ./7sdisplay_test.py ======================================== | LEDs with 74HC595 | | | | Control LEDs with 74HC595 | | | ======================================== Program is running... Please press Ctrl+C to end the program... ^Cpi@raspberrypi:~/Code/TestBee $ Finalmente, se comprobar\u00e1 el funcionamiento del buzzer pasivo, mediante el script buzzer_test.sh . Este script configura el buzzer para la reproducci\u00f3n de la siguiente secuencia de notas: LA4, MI4 y LA4 (cada una de ellas durante un segundo). Este script, a diferencia de los anteriores, ha de ejecutarse con sudo : pi@raspberrypi:~/TestBee $ sudo ./buzzer_test.sh Exporting PWM0 channel Testing Passive Buzzer A4 .. E4 .. A4 Done Unexporting PWM0 channel","title":"Comprobaci\u00f3n del funcionamiento de la placa de E/S y de su configuraci\u00f3n"},{"location":"linux-kernel/config/#analisis-de-alternativas-para-desarrollo-en-la-raspberry-pi-desde-la-maquina-virtual-configuracion-de-vscode","text":"Por motivos de rendimiento se aconseja almacenar en el directorio HOME del usuario pi --en la propia Raspberry Pi (tarjeta SD)-- los ficheros fuente de los m\u00f3dulos del kernel a desarrollar en las pr\u00e1cticas. Tambi\u00e9n es recomendable hacer copia de seguridad de los ficheros cada cierto tiempo transfiri\u00e9ndolos al sistema host por red (p.ej., usando comando scp visto en clase). En este caso, usaremos el t\u00e9rmino \" host \" para referirnos a la m\u00e1quina virtual de Debian, que es desde donde nos comunicaremos por red con la placa Raspberry Pi. Conectarse a la placa por SSH desde la m\u00e1quina virtual ser\u00e1 algo muy frecuente durante la realizaci\u00f3n de las pr\u00e1cticas. Por este motivo, se aconseja configurar el acceso a la Raspberry Pi sin contrase\u00f1a, es decir usando una clave SSH. Para establecer la configuraci\u00f3n han de seguirse los siguientes pasos dentro de la m\u00e1quina virtual: Si el fichero ~/.ssh/id_rsa.pub no existe, ha de crearse uno mediante el comando ssh-keygen -t rsa -b 2048 . En nuestro caso teclearemos ENTER a continuaci\u00f3n para aceptar la ruta por defecto del fichero, y NO establecer passphrase : kernel@debian:~$ ssh-keygen -t rsa -b 2048 Generating public/private rsa key pair. Enter file in which to save the key ( /home/kernel/.ssh/id_rsa ) : Enter passphrase ( empty for no passphrase ) : Enter same passphrase again: Your identification has been saved in /home/kernel/.ssh/id_rsa. Your public key has been saved in /home/kernel/.ssh/id_rsa.pub. The key fingerprint is: SHA256:6IdQ3RHxf8QeyZRmCgN1j2l7u5v/Dx18VPLjmxamRy8 kernel@debian The key ' s randomart image is: +--- [ RSA 2048 ] ----+ | .*+ ...o | | . . = . *Bo | | . . . +++* = | | . . .o++o | | . . S ..O+ | | o . = oO | | o . .E*o | | . ooo | | +O | +---- [ SHA256 ] -----+ Dar de alta la clave SSH generada en el registro del usuario pi dentro de la Raspberry Pi. Para ello haremos uso del comando ssh-copy-id como se muestra a continuaci\u00f3n, y tecleando la contrase\u00f1a del usuario ( raspberry ) cuando nos lo solicite: kernel@debian:~$ ssh-copy-id pi@pi /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key ( s ) , to filter out any that are already installed /usr/bin/ssh-copy-id: INFO: 1 key ( s ) remain to be installed -- if you are prompted now it is to install the new keys pi@pi 's password: Number of key(s) added: 1 Now try logging into the machine, with: \"ssh ' pi@pi ' \" and check to make sure that only the key(s) you wanted were added. Llegados a este punto ya podremos conectarnos por SSH a la Raspberry Pi sin teclear la contrase\u00f1a, y usando por debajo la clave SSH generada: kernel@debian:~$ ssh pi@pi Linux raspberrypi 5 .10.92-v7+ #1514 SMP Mon Jan 17 17:36:39 GMT 2022 armv7l The programs included with the Debian GNU/Linux system are free software ; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Sat Sep 24 18 :07:44 2022 from 192 .168.2.1 SSH is enabled and the default password for the 'pi' user has not been changed. This is a security risk - please login as the 'pi' user and type 'passwd' to set a new password. Wi-Fi is currently blocked by rfkill. Use raspi-config to set the country before use. pi@raspberrypi:~ $ Existen esencialmente tres alternativas para desarrollar las pr\u00e1cticas sobre la Raspberry Pi, compilando los m\u00f3dulos del kernel desde la propia placa^[Tambi\u00e9n es posible almacenar, editar los ficheros, y compilar los m\u00f3dulos desde el sistema host , empleando compilaci\u00f3n cruzada. Sin embargo esto conlleva copiar los .ko correspondientes a la placa para testear su funcionalidad.]. A continuaci\u00f3n se describen las distintas opciones.","title":"An\u00e1lisis de alternativas para desarrollo en la Raspberry Pi desde la m\u00e1quina virtual. Configuraci\u00f3n de VSCode."},{"location":"linux-kernel/config/#opcion-1-ejecucion-del-editor-en-la-propia-placa","text":"Editar los ficheros con programa editor instalado en la propia placa, lanzando el editor por SSH. Pueden utilizarse para ello editores de l\u00ednea de comandos (como vim o nano ) o incluso editores gr\u00e1ficos como geany (esto exige activar la opci\u00f3n -X al conectarse por SSH: ssh -X pi@pi ). La compilaci\u00f3n debe llevarse a cabo desde un shell SSH dentro de la propia Raspberry Pi.","title":"Opci\u00f3n 1: Ejecuci\u00f3n del editor en la propia placa"},{"location":"linux-kernel/config/#opcion-2-sshfs-y-edicion-de-ficheros-desde-el-host","text":"El sistema de ficheros de la Raspberry Pi se puede montar en el host (m\u00e1quina virtual de Debian) por SSH usando el comando sshfs , como en el siguiente ejemplo: kernel@debian:~$ mkdir home-raspberry kernel@debian:~$ sshfs pi@pi:/home/pi home-raspberry kernel@debian:~$ ls home-raspberry/ Bookshelf Desktop Downloads Pictures Videos Documents Music Public Templates En el ejemplo se crea un directorio vac\u00edo home-raspberry (puede usarse el nombre que se desee), que se emplea como punto de montaje. Gracias al comando sshfs del ejemplo se monta el directorio HOME del usuario pi de la Raspberry en el directorio ~/home-raspberry del host . Una vez montada la carpeta por SSH se pueden editar los ficheros con cualquier editor en el host, ya sea por l\u00ednea de comandos o gr\u00e1ficamente (p.ej., con Sublime Text o VSCode). SSHFS transfiere autom\u00e1ticamente los ficheros a la Raspberry cuando detecta cambios en los mismos, y sin requerir intervenci\u00f3n del usuario. Cuando se haya acabado de trabajar con los ficheros, o cuando se desee reiniciar o apagar la Raspberry Pi, se ha de desmontar la carpeta montada usando fusermount : kernel@debian:~$ fusermount -u home-raspberry kernel@debian:~$","title":"Opci\u00f3n 2: SSHFS y edici\u00f3n de ficheros desde el host"},{"location":"linux-kernel/config/#opcion-3-uso-de-extension-remote-de-vscode-para-trabajar-con-raspberry-pi-de-forma-transparente","text":"VSCode posee una extensi\u00f3n llamada Remote que permite trabajar con una o varias carpetas de un sistema accesible por SSH^[Este plugin de VSCode tambi\u00e9n soporta trabajar con WSL y contenedores Docker.] como si de una carpeta local se tratara. Una vez se ha establecido la conexi\u00f3n de VSCode con el sistema remoto, los terminales abiertos dentro del propio entorno se ejecutar\u00e1n en la m\u00e1quina a la que nos hemos conectado. Por lo tanto, cada terminal se corresponde con un shell SSH en la m\u00e1quina target (la Raspberry Pi en nuestro caso). En definitiva, de esta forma tendremos la ilusi\u00f3n de que trabajamos con VSCode desde dentro del propio sistema target , pero usando el entorno gr\u00e1fico del host de desarrollo. La extensi\u00f3n Remote ya est\u00e1 instalada en la m\u00e1quina virtual del laboratorio. No obstante, hemos de configurar dicha extensi\u00f3n para trabajar con la Raspberry Pi. Para ilustrar el proceso de configuraci\u00f3n de Remote desde la m\u00e1quina virtual se proporciona el v\u00eddeo mostrado a continuaci\u00f3n. En el v\u00eddeo se asume que se ha habilitado el acceso por SSH sin contrase\u00f1a (v\u00eda clave SSH) a la Raspberry Pi siguiendo las instrucciones mostradas m\u00e1s arriba. Una vez que la Raspberry Pi se ha dado de alta como remote dentro de VSCode --como se ilustra en el v\u00eddeo--, dicho remote permanecer\u00e1 registrado en futuras ejecuciones de VSCode. Por lo tanto, para trabajar con ficheros en la placa bastar\u00e1 abrir la carpeta deseada desde el explorador de Remotes . Por \u00faltimo, se ha de tener presente que cuando hacemos uso de la extensi\u00f3n Remote , es necesario instalar las extensiones de VSCode que deseemos para desarrollar desde ese target al que nos conectamos. Para trabajar con la Raspberry Pi, se recomienda instalar las extensiones est\u00e1ndar de VSCode para desarollo C/C++. La instalaci\u00f3n debe hacerse desde una ventana de Remote.","title":"Opci\u00f3n 3: Uso de extensi\u00f3n Remote de VSCode para trabajar con Raspberry Pi de forma transparente"},{"location":"linux-kernel/drivers/","text":"Drivers en Linux. Aspectos b\u00e1sicos y GPIO \u00b6 Objetivos \u00b6 Los principales objetivos de esta pr\u00e1ctica son los siguientes: Familiarizarse con las principales estructuras y abstracciones que se emplean en la implementaci\u00f3n de drivers de dispositivos de caracteres en Linux. Introducirse en el uso de la descriptor API para el sistema GPIO en Linux Aprender a gestionar los LEDs y el display 7 segmentos de la placa Bee v2.0 desde el kernel Linux. El c\u00f3digo para esta pr\u00e1ctica puede descargarse aqu\u00ed . Se recomienda al estudiante seguir un orden particular al desarrollar la pr\u00e1ctica. Los pasos recomendados son los siguientes: Seguir el tutorial de preparaci\u00f3n del entorno de pr\u00e1cticas con la Raspberry Pi, la placa de E/S y la m\u00e1quina virtual de Debian Realizar los ejercicios 1-6 de este gui\u00f3n, que se centran en ilustrar el funcionamiento de los drivers de dispositivos de caracteres y la API de GPIO en Linux. Desarrollar el m\u00f3dulo del kernel solicitado en la Parte A de la pr\u00e1ctica. Realizar el ejercicio 7 del gui\u00f3n, que ilustra el funcionamiento a bajo nivel del display 7 segmentos de la placa Bee v2.0. Desarrollar la Parte B de la pr\u00e1ctica, en la que ser\u00e1 preciso modificar el m\u00f3dulo del kernel proporcionado en el ejercicio 7 Teor\u00eda de la pr\u00e1ctica La teor\u00eda asociada a esta pr\u00e1ctica se imparte en la asignatura \"Arquitectura Interna de Linux y Android\", ofertada en las distintas titulaciones de grado en la Facultad de Inform\u00e1tica de la Universidad Complutense de Madrid. Para m\u00e1s informaci\u00f3n sobre la asignatura consultad a Juan Carlos S\u00e1ez Alcaide . Para documentarse sobre la tem\u00e1tica de forma aut\u00f3noma se proporcionan las siguientes referencias: Peter Jay Salzman, Michael Burian, Ori Pomerantz, Bob Mottram, Jim Huang. Linux Kernel Module Programming Guide . 2025. Disponible online . Versi\u00f3n en PDF Kaiwan N. Billimoria. Linux Kernel Programming . Packt Publishing. 1st edition. 2021 Kaiwan N. Billimoria. Linux Kernel Programming. Part 2 - Char Device Drivers and Kernel Synchronization . Packt Publishing. 1st edition. 2021 Robert Love; Linux Kernel Development . Addison Wesley, 3rd Edition. Julio 2010 Ejercicios \u00b6 Ejercicio 1 \u00b6 Probar y analizar el c\u00f3digo de los m\u00f3dulos de ejemplo Chardev2 y ChardevMisc . Compilar y cargar cada uno de los m\u00f3dulos del kernel y responder a las siguientes preguntas para cada uno de ellos: \u00bfCu\u00e1l es la ruta ( path ) del fichero de dispositivo que se crea autom\u00e1ticamente al cargar el m\u00f3dulo? \u00bfEn qu\u00e9 fichero especial del sistema puede consultarse el major number asignado al driver correspondiente? \u00bfQu\u00e9 minor number tiene asociado cada uno de los ficheros especiales creados al cargar los m\u00f3dulos del kernel? \u00bfQu\u00e9 llamada del driver se encarga de asignar ese minor number ? \u00bfQu\u00e9 sucede al escribir en el fichero especial de dispositivo (p.ej., echo hello > /dev/chardev )? \u00bfPor que se produce este comportamiento? Ejercicio 2 \u00b6 Algunas funciones de la API del kernel Linux retornan un puntero a una estructura, que representa un objeto del kernel. En algunos casos, como en la funci\u00f3n proc_create() , un valor de retorno igual a NULL indica que se ha producido un error. Un valor distinto de NULL refleja que la funci\u00f3n se ha ejecutado correctamente, y que por tanto, la estructura devuelta es v\u00e1lida. El problema de esta aproximaci\u00f3n a la gesti\u00f3n de errores es que la funci\u00f3n invocadora desconoce el error concreto que se ha producido, ya que solo puede saber si ha habido error o no. Para ofrecer mayor robustez en la gesti\u00f3n de errores en funciones que retornan un puntero a una estructura, es posible usar el propio puntero retornado para almacenar el c\u00f3digo del error que se ha producido usando la macro ERR_PTR() . Consulta la implementaci\u00f3n de la funci\u00f3n class_create() cuya implementaci\u00f3n, que puede encontrarse aqu\u00ed , hace uso de la citada macro. Al usar funciones que codifican errores de esta forma es posible comprobar desde la funci\u00f3n invocadora si el valor de retorno almacena un c\u00f3digo de error usando la macro IS_ERR() . Adem\u00e1s, en caso de que se haya producido un error la macro PTR_ERR() permite recuperar el c\u00f3digo (negativo) de error a partir del puntero. Analiza detenidamente el uso de las macros IS_ERR() y PTR_ERR() en el m\u00f3dulo de ejemplo Chardev2 . Ejercicio 3 \u00b6 El m\u00f3dulo del kernel de ejemplo ChardevData constituye una variante de Chardev2 , donde las variables globales a las que se accede en las operaciones open() , read() y release() se han reemplazado por una estructura privada asociada al struct device_data que crea el driver. Consulta la implementaci\u00f3n del m\u00f3dulo ChardevData y responde a las siguientes preguntas. \u00bfQu\u00e9 ventaja crees que tiene reemplazar las citadas variables globales por la estructura privada? \u00bfQue llamada de la API de Linux permite asociar en esta implementaci\u00f3n la estructura privada al al struct device que crea el driver? \u00bfC\u00f3mo es posible recuperar dicha estructura privada en las operaciones open() , read() y release() ? Pista: La estructura struct file* que se pasa como par\u00e1metro a estas operaciones representa el fichero abierto sobre el que se invocan las operaciones desde espacio de usuario, y su campo private_data se utiliza en el driver para almacenar un puntero. Ejercicio 4 \u00b6 Analizar la implementaci\u00f3n del m\u00f3dulo de ejemplo Clipboard-dev . Se trata de una variante del ejemplo Clipboard de la pr\u00e1ctica 1, donde el \"clipboard\" se expone usando un fichero especial de caracteres /dev/clipboard en lugar de un fichero en /proc . Identifica las diferencias entre la implementaci\u00f3n de ambos m\u00f3dulos del kernel: diff -u <ruta clipboard.c> <ruta clipboard-dev.c> En ambos m\u00f3dulos del kernel est\u00e1n presentes las funciones clipboard_write() y clipboard_read() para gestionar las acciones de lectura y escritura sobre el fichero especial que representa el \"clipboard\" en cada caso. \u00bfQu\u00e9 diferencias encuentras entre la implementaci\u00f3n de estas funciones presentes tanto en Clipboard como en Clipboard-dev ? Ejercicio 5 \u00b6 En el directorio del m\u00f3dulo de ejemplo Clipboard de la pr\u00e1ctica 1 pueden encontrarse dos ficheros de GNU Make: Makefile y Makefile.cross . El segundo de ellos sirve para realizar compilaci\u00f3n cruzada del m\u00f3dulo del kernel para la Raspberry Pi desde nuestro host de desarrollo (la m\u00e1quina virtual de Debian). Este ejercicio consiste en realizar una compilaci\u00f3n cruzada del m\u00f3dulo del kernel Clipboard para la Raspberry Pi y probar el fichero .ko resultante de dicha compilaci\u00f3n en la placa. Para ello han de seguirse los siguientes pasos: Abrir un navegador web en la m\u00e1quina virtual y descargar el fichero linux-raspberry.tgz usando este enlace . El fichero comprimido contiene un kernel Linux ya compilado para la Raspberry Pi, que nos permite realizar compilaci\u00f3n cruzada de m\u00f3dulos del kernel. Extraer el fichero comprimido en el HOME del usuario kernel . (Se asume que el fichero descargado se almacena en ~/Descargas ). $ cd $ tar xzvf ./ Descargas / linux-raspberry . tgz Instalar el compilador cruzado (deber\u00eda encontrarse ya instalado en la m\u00e1quina virtual): $ sudo apt install gcc-8-arm-linux-gnueabihf gcc-arm-linux-gnueabihf Ir al directorio Clipboard y borrar ficheros resultantes de compilaciones previas usando el Makefile convencional: kernel @debian :~$ cd FicherosP1 / Clipboard kernel @debian :~/ FicherosP1 $ make clean Generar el .ko adecuado para el kernel de la Raspberry pi usando el comando make -f Makefile.cross desde el mismo directorio donde nos encontramos. N\u00f3tese que con la opci\u00f3n -f de GNU Make se escoge manualmente el fichero Makefile para realizar la compilaci\u00f3n. Finalmente, copiar el fichero .ko a la Raspberry Pi usando scp y probar dicho m\u00f3dulo en la placa Comando de copia del fichero al directorio HOME del usuario pi en la placa: scp clipboard.ko pi@pi:. Ejercicio 6 \u00b6 El m\u00f3dulo del kernel ModledsPi_gpiod modifica el estado de los LEDs D1, D2 y D3 de la placa Bee v2.0. En particular, al cargar este m\u00f3dulo en la Raspberry Pi, los citados LEDs se encienden; al descargar el m\u00f3dulo, estos LEDs se apagan. En este ejercicio se plantea analizar la implementaci\u00f3n de este m\u00f3dulo, cuyo c\u00f3digo deber\u00e1 reutilizarse para la implementaci\u00f3n de la pr\u00e1ctica. Para ello se ha de prestar especial atenci\u00f3n a la siguiente funci\u00f3n: static inline int set_pi_leds ( unsigned int mask ) { int i ; for ( i = 0 ; i < NR_GPIO_LEDS ; i ++ ) gpiod_set_value ( gpio_descriptors [ i ], ( mask >> i ) & 0x1 ); return 0 ; } La funci\u00f3n set_pi_leds() acepta como par\u00e1metro una m\u00e1scara de bits que especifica el estado de cada LED. Si el bit correspondiente est\u00e1 a \"1\", el LED asociado se enciende; si est\u00e1 a \"0\" se apagar\u00e1. La correspondencia entre los bits de la m\u00e1scara ( unsigned int ) y los LEDs es la siguiente: Bit 0: Led D3 Bit 1: Led D2 Bit 2: Led D1 Bits 3-31: Se ignoran Ejercicio 7 \u00b6 Estudiar el funcionamiento e implementaci\u00f3n del m\u00f3dulo de ejemplo Misc7seg , que al igual que el del ejercicio anterior ha sido creado especificamente para la placa de E/S Bee 2.0. Este driver --m\u00f3dulo del kernel--, al cargarse, expone el display 7 segmentos de la placa al usuario mediante el fichero especial de caracteres /dev/display7s , perteneciente a la clase misc del LDM. El driver permite alterar el estado del display escribiendo desde espacio de usuario en dicho fichero especial. La implementaci\u00f3n, no obstante, ignora la cadena o secuencia de bytes escrita en el fichero de dispositivo con write() , y simplemente altera el estado del display encendiendo segmentos espec\u00edficos siguiendo un patr\u00f3n determinado. Para averiguar el patr\u00f3n de encendido de los segmentos, que se realiza en display7s_write() , se pueden realizar escrituras con echo > /dev/display7s de forma manual, o empleando un bucle infinito (a terminar con CTRL+C) como en el siguiente comando: $ while true ; do echo > /dev/display7s ; sleep 0 .4 ; done Una parte cr\u00edtica de este ejercicio es comprender c\u00f3mo el m\u00f3dulo del kernel controla el estado del display 7 segmentos, usando pines espec\u00edficos de la Raspberry Pi. El display integrado en la placa tiene los 7 segmentos habituales ( a , b , c , ...., g ) y uno extra para el punto --llamado dp --. Ya que dedicar 8 pines para controlar estos segmentos limita enormemente el uso simult\u00e1neo de otros dispositivos de E/S, la placa Bee v2.0 integra un circuito para controlar el display que solo requiere 3 pines. La siguiente figura muestra un diagrama del circuito: El circuito consta de 3 m\u00f3dulos fundamentales: un registro de desplazamiento (etapa de entrada), un registro convencional con carga paralela, y el m\u00f3dulo del display 7 segmentos propiamente dicho, que integra los LEDs correspondientes y una serie de resistencias de entrada (no mostradas en el diagrama, por simplicidad). El sistema consta de las siguientes 3 entradas: SDI ( Serial Data Input ): codifica el bit de entrada serie al registro de desplazamiento Esta entrada se controla con el GPIO 18 de la Raspberry Pi SRCLK ( Shift Register Clock ): se\u00f1al de reloj del registro de desplazamiento Esta se\u00f1al de reloj se controla con el GPIO 23 de la Raspberry Pi RCLK ( Register Clock ): se\u00f1al de reloj del registro de salida Esta se\u00f1al de reloj se controla con el GPIO 24 de la Raspberry Pi Como podemos observar en el diagrama, las se\u00f1ales de enable (EN) del registro de desplazamiento, y de carga (LOAD) del registro de salida est\u00e1n a 1, por lo que los m\u00f3dulos realizar\u00e1n su acci\u00f3n espec\u00edfica --desplazamiento, y carga paralela, respectivamente-- siempre que se produzca un flanco de subida en su se\u00f1al de reloj correspondiente. El estado de los segmentos se representa mediante un n\u00famero de 8 bits, estando representado el segmento a mediante el bit m\u00e1s significativo, y dp por el bit menos significativo. Como los LEDs del m\u00f3dulo que implementa el display 7 segmentos est\u00e1n en configuraci\u00f3n de c\u00e1todo com\u00fan , un bit a 1 enciende el segmento correspondiente, y un 0 lo apaga. Intuitivamente, para actualizar el estado del display desde la CPU han de seguirse estos pasos: Asegurarse de que los pines que controlan la se\u00f1al de reloj SRCLK y RCLK est\u00e1n a cero al principio del procedimiento Para cada bit del n\u00famero de estado (8 bits), recorriendo los bits de izquierda a derecha: Escribir el bit actual en la entrada SDI usando el GPIO asociado Generar un pulso de reloj en el registro de desplazamiento con la entrada SRCLK modulando la se\u00f1al (\"dibujando el pulso\") mediante el pin GPIO correspondiente RCLK estar\u00e1 siempre a cero durante esta etapa. Al final del punto anterior, la entrada paralela del registro de salida ya tiene los bits en el orden deseado ya que se han ido desplazando todos hacia la izquierda. Por lo tanto, basta generar un pulso de reloj en la se\u00f1al RCLK , para cargar el n\u00famero en el registro. Al hacer esto, se actualizar\u00e1 autom\u00e1ticamente la salida del registro, y por tanto el estado de los segmentos en el display. La funci\u00f3n del driver que implementa el citado procedimiento de actualizaci\u00f3n del estado del display es update_7sdisplay() : #define SEGMENT_COUNT 8 static void update_7sdisplay ( unsigned char data ) { int i = 0 ; int value = 0 ; for ( i = 0 ; i < SEGMENT_COUNT ; i ++ ) { /* Explore current bit (from most significant to least significant) */ if ( 0x80 & ( data << i )) value = 1 ; else value = 0 ; /* Set value of serial input */ gpiod_set_value ( gpio_descriptors [ SDI_IDX ], value ); /* Generate clock cycle in shift register */ gpiod_set_value ( gpio_descriptors [ SRCLK_IDX ], 1 ); msleep ( 1 ); gpiod_set_value ( gpio_descriptors [ SRCLK_IDX ], 0 ); } /* Generate clock cycle in output register to update 7-seg display */ gpiod_set_value ( gpio_descriptors [ RCLK_IDX ], 1 ); msleep ( 1 ); gpiod_set_value ( gpio_descriptors [ RCLK_IDX ], 0 ); } La alteraci\u00f3n de las se\u00f1ales SDI, SRCLK y RCLK se realiza mediante bit banging , es decir modificando el valor del pin manualmente desde la CPU, pero de forma temporizada, realizando las esperas necesarias para garantizar que la se\u00f1al se mantenga un cierto tiempo en el valor l\u00f3gico deseado. En particular, para garantizar que el pulso de reloj tenga una duraci\u00f3n m\u00ednima garantizada de 1ms, el driver hace uso de la funci\u00f3n msleep() del kernel, que bloquea al flujo de ejecuci\u00f3n invocador durante el periodo de tiempo en ms indicado como argumento. Desarrollo de la pr\u00e1ctica \u00b6 Esta pr\u00e1ctica consta de dos partes: A y B Parte A \u00b6 Implementar un driver de dispositivo de caracteres Modleds-dev-pi que permita establecer el estado de los LEDS D1-D3 de la placa Bee v2.0. Al cargar dicho driver se crear\u00e1 autom\u00e1ticamente un fichero especial de caracteres /dev/leds . El estado de los LEDs podr\u00e1 alterarse escribiendo un n\u00famero del 0 al 7 (m\u00e1scara de 3 bits) al fichero especial. La correspondencia entre los bits de esta m\u00e1scara y los LEDs ser\u00e1 la siguiente: Bit 2: encender/apagar LED D3 Bit 1: encender/apagar LED D2 Bit 0: encender/apagar LED D1 La siguiente tabla muestra algunos ejemplos: N\u00famero escrito en /dev/leds D3 D2 D1 4 ON OFF OFF 7 ON ON ON 3 OFF ON ON 0 OFF OFF OFF 2 OFF ON OFF Si el usuario escribe una cadena de caracteres que no sea 0-7 la escritura sobre el dispositivo deber\u00e1 devolver un error: $ pi@raspberrypi:~ $ echo 9 > /dev/leds -bash: echo: write error: Invalid argument $ pi@raspberrypi:~ $ echo potato > /dev/leds -bash: echo: write error: Invalid argument Para probar el funcionamiento del driver Modleds-dev se aconseja ejecutar el siguiente script BASH, que altera peri\u00f3dicamente el estado de los LEDs para emular un contador binario m\u00f3dulo 7: #!/bin/bash while true do for (( i = 0 ; $i < 8 ; i++ )) do echo $i > /dev/leds sleep 0 .4 done done Parte opcional \u00b6 Modificar el ejemplo ChardevData , de tal forma que se creen 3 dispositivos de caracteres independientes al cargar el m\u00f3dulo: /dev/chardev0 , /dev/chardev1 y /dev/chardev2 . Cada uno de estos dispositivos tiene que tener asociado una estructura independiente de tipo device_data : struct device_data { int Device_Open ; /* Is device open? Used to prevent multiple access to device */ char msg [ BUF_LEN ]; /* The msg the device will give when asked */ char * msg_Ptr ; /* This will be initialized every time the device is opened successfully */ int counter ; /* Tracks the number of times the character device has been opened */ struct device * device ; dev_t major_minor ; }; Al asociar una estructura independiente a cada dispositivo \"virtual\" de caracteres, cada uno de ellos ser\u00e1 completamente independiente de cara al usuario, como se ilustra en el siguiente ejemplo de ejecuci\u00f3n: ## Compilaci\u00f3n y carga del m\u00f3dulo modificado pi@raspberrypi:~/Solutions/ChardevDataMulti $ make make -C /lib/modules/5.10.92-v7+/build M = /home/pi/Solutions/ChardevDataMulti modules make [ 1 ] : Entering directory '/usr/src/linux-headers-5.10.92-v7+' CC [ M ] /home/pi/Solutions/ChardevDataMulti/chardev_data.o MODPOST /home/pi/Solutions/ChardevDataMulti/Module.symvers CC [ M ] /home/pi/Solutions/ChardevDataMulti/chardev_data.mod.o LD [ M ] /home/pi/Solutions/chardev_data.ko make [ 1 ] : Leaving directory '/usr/src/linux-headers-5.10.92-v7+' pi@raspberrypi:~/Solutions/ChardevDataMulti $ sudo insmod chardev_data.ko ## Interacci\u00f3n con dispositivos de caracteres independientes pi@raspberrypi:~/Solutions/ChardevDataMulti $ cd pi@raspberrypi:~ $ ls /dev/chardev* /dev/chardev0 /dev/chardev1 /dev/chardev2 pi@raspberrypi:~ $ cat /dev/chardev0 I already told you 0 times Hello world! pi@raspberrypi:~ $ cat /dev/chardev1 I already told you 0 times Hello world! pi@raspberrypi:~ $ cat /dev/chardev2 I already told you 0 times Hello world! pi@raspberrypi:~ $ cat /dev/chardev2 I already told you 1 times Hello world! pi@raspberrypi:~ $ cat /dev/chardev0 I already told you 1 times Hello world! Parte B \u00b6 Extender la funcionalidad del m\u00f3dulo de ejemplo Misc7seg (Ejercicio 7), para que el usuario pueda especificar el d\u00edgito hexadecimal (de 0 a F) que se desea mostrar en el display 7 segmentos escribiendo en el fichero especial de caracteres /dev/display7s . Para ello se ha de modificar la funci\u00f3n display7s_write() . Tambi\u00e9n se recomienda definir macros que codifiquen el n\u00famero de 8 bits que ha de escribirse en el display para representar cada d\u00edgito hexadecimal. Ejemplo de ejecuci\u00f3n \u00b6 $ pi@raspberrypi:~ $ echo 9 > /dev/display7s ## Deber\u00eda mostrar el n\u00famero 9 en el display $ pi@raspberrypi:~ $ echo A > /dev/display7s ## Deber\u00eda mostrar la letra A (n\u00famero 10) en el display $ pi@raspberrypi:~ $ echo f > /dev/display7s ## Deber\u00eda mostrar la letra F (n\u00famero 15) en el display ## Casos de error $ pi@raspberrypi:~ $ echo 27 > /dev/display7s -bash: echo: write error: Invalid argument $ pi@raspberrypi:~ $ echo h > /dev/display7s -bash: echo: write error: Invalid argument $ pi@raspberrypi:~ $ echo potato > /dev/display7s -bash: echo: write error: Invalid argument","title":"Drivers en Linux. Aspectos b\u00e1sicos y GPIO"},{"location":"linux-kernel/drivers/#drivers-en-linux-aspectos-basicos-y-gpio","text":"","title":"Drivers en Linux. Aspectos b\u00e1sicos y GPIO"},{"location":"linux-kernel/drivers/#objetivos","text":"Los principales objetivos de esta pr\u00e1ctica son los siguientes: Familiarizarse con las principales estructuras y abstracciones que se emplean en la implementaci\u00f3n de drivers de dispositivos de caracteres en Linux. Introducirse en el uso de la descriptor API para el sistema GPIO en Linux Aprender a gestionar los LEDs y el display 7 segmentos de la placa Bee v2.0 desde el kernel Linux. El c\u00f3digo para esta pr\u00e1ctica puede descargarse aqu\u00ed . Se recomienda al estudiante seguir un orden particular al desarrollar la pr\u00e1ctica. Los pasos recomendados son los siguientes: Seguir el tutorial de preparaci\u00f3n del entorno de pr\u00e1cticas con la Raspberry Pi, la placa de E/S y la m\u00e1quina virtual de Debian Realizar los ejercicios 1-6 de este gui\u00f3n, que se centran en ilustrar el funcionamiento de los drivers de dispositivos de caracteres y la API de GPIO en Linux. Desarrollar el m\u00f3dulo del kernel solicitado en la Parte A de la pr\u00e1ctica. Realizar el ejercicio 7 del gui\u00f3n, que ilustra el funcionamiento a bajo nivel del display 7 segmentos de la placa Bee v2.0. Desarrollar la Parte B de la pr\u00e1ctica, en la que ser\u00e1 preciso modificar el m\u00f3dulo del kernel proporcionado en el ejercicio 7 Teor\u00eda de la pr\u00e1ctica La teor\u00eda asociada a esta pr\u00e1ctica se imparte en la asignatura \"Arquitectura Interna de Linux y Android\", ofertada en las distintas titulaciones de grado en la Facultad de Inform\u00e1tica de la Universidad Complutense de Madrid. Para m\u00e1s informaci\u00f3n sobre la asignatura consultad a Juan Carlos S\u00e1ez Alcaide . Para documentarse sobre la tem\u00e1tica de forma aut\u00f3noma se proporcionan las siguientes referencias: Peter Jay Salzman, Michael Burian, Ori Pomerantz, Bob Mottram, Jim Huang. Linux Kernel Module Programming Guide . 2025. Disponible online . Versi\u00f3n en PDF Kaiwan N. Billimoria. Linux Kernel Programming . Packt Publishing. 1st edition. 2021 Kaiwan N. Billimoria. Linux Kernel Programming. Part 2 - Char Device Drivers and Kernel Synchronization . Packt Publishing. 1st edition. 2021 Robert Love; Linux Kernel Development . Addison Wesley, 3rd Edition. Julio 2010","title":"Objetivos"},{"location":"linux-kernel/drivers/#ejercicios","text":"","title":"Ejercicios"},{"location":"linux-kernel/drivers/#ejercicio-1","text":"Probar y analizar el c\u00f3digo de los m\u00f3dulos de ejemplo Chardev2 y ChardevMisc . Compilar y cargar cada uno de los m\u00f3dulos del kernel y responder a las siguientes preguntas para cada uno de ellos: \u00bfCu\u00e1l es la ruta ( path ) del fichero de dispositivo que se crea autom\u00e1ticamente al cargar el m\u00f3dulo? \u00bfEn qu\u00e9 fichero especial del sistema puede consultarse el major number asignado al driver correspondiente? \u00bfQu\u00e9 minor number tiene asociado cada uno de los ficheros especiales creados al cargar los m\u00f3dulos del kernel? \u00bfQu\u00e9 llamada del driver se encarga de asignar ese minor number ? \u00bfQu\u00e9 sucede al escribir en el fichero especial de dispositivo (p.ej., echo hello > /dev/chardev )? \u00bfPor que se produce este comportamiento?","title":"Ejercicio 1"},{"location":"linux-kernel/drivers/#ejercicio-2","text":"Algunas funciones de la API del kernel Linux retornan un puntero a una estructura, que representa un objeto del kernel. En algunos casos, como en la funci\u00f3n proc_create() , un valor de retorno igual a NULL indica que se ha producido un error. Un valor distinto de NULL refleja que la funci\u00f3n se ha ejecutado correctamente, y que por tanto, la estructura devuelta es v\u00e1lida. El problema de esta aproximaci\u00f3n a la gesti\u00f3n de errores es que la funci\u00f3n invocadora desconoce el error concreto que se ha producido, ya que solo puede saber si ha habido error o no. Para ofrecer mayor robustez en la gesti\u00f3n de errores en funciones que retornan un puntero a una estructura, es posible usar el propio puntero retornado para almacenar el c\u00f3digo del error que se ha producido usando la macro ERR_PTR() . Consulta la implementaci\u00f3n de la funci\u00f3n class_create() cuya implementaci\u00f3n, que puede encontrarse aqu\u00ed , hace uso de la citada macro. Al usar funciones que codifican errores de esta forma es posible comprobar desde la funci\u00f3n invocadora si el valor de retorno almacena un c\u00f3digo de error usando la macro IS_ERR() . Adem\u00e1s, en caso de que se haya producido un error la macro PTR_ERR() permite recuperar el c\u00f3digo (negativo) de error a partir del puntero. Analiza detenidamente el uso de las macros IS_ERR() y PTR_ERR() en el m\u00f3dulo de ejemplo Chardev2 .","title":"Ejercicio 2"},{"location":"linux-kernel/drivers/#ejercicio-3","text":"El m\u00f3dulo del kernel de ejemplo ChardevData constituye una variante de Chardev2 , donde las variables globales a las que se accede en las operaciones open() , read() y release() se han reemplazado por una estructura privada asociada al struct device_data que crea el driver. Consulta la implementaci\u00f3n del m\u00f3dulo ChardevData y responde a las siguientes preguntas. \u00bfQu\u00e9 ventaja crees que tiene reemplazar las citadas variables globales por la estructura privada? \u00bfQue llamada de la API de Linux permite asociar en esta implementaci\u00f3n la estructura privada al al struct device que crea el driver? \u00bfC\u00f3mo es posible recuperar dicha estructura privada en las operaciones open() , read() y release() ? Pista: La estructura struct file* que se pasa como par\u00e1metro a estas operaciones representa el fichero abierto sobre el que se invocan las operaciones desde espacio de usuario, y su campo private_data se utiliza en el driver para almacenar un puntero.","title":"Ejercicio 3"},{"location":"linux-kernel/drivers/#ejercicio-4","text":"Analizar la implementaci\u00f3n del m\u00f3dulo de ejemplo Clipboard-dev . Se trata de una variante del ejemplo Clipboard de la pr\u00e1ctica 1, donde el \"clipboard\" se expone usando un fichero especial de caracteres /dev/clipboard en lugar de un fichero en /proc . Identifica las diferencias entre la implementaci\u00f3n de ambos m\u00f3dulos del kernel: diff -u <ruta clipboard.c> <ruta clipboard-dev.c> En ambos m\u00f3dulos del kernel est\u00e1n presentes las funciones clipboard_write() y clipboard_read() para gestionar las acciones de lectura y escritura sobre el fichero especial que representa el \"clipboard\" en cada caso. \u00bfQu\u00e9 diferencias encuentras entre la implementaci\u00f3n de estas funciones presentes tanto en Clipboard como en Clipboard-dev ?","title":"Ejercicio 4"},{"location":"linux-kernel/drivers/#ejercicio-5","text":"En el directorio del m\u00f3dulo de ejemplo Clipboard de la pr\u00e1ctica 1 pueden encontrarse dos ficheros de GNU Make: Makefile y Makefile.cross . El segundo de ellos sirve para realizar compilaci\u00f3n cruzada del m\u00f3dulo del kernel para la Raspberry Pi desde nuestro host de desarrollo (la m\u00e1quina virtual de Debian). Este ejercicio consiste en realizar una compilaci\u00f3n cruzada del m\u00f3dulo del kernel Clipboard para la Raspberry Pi y probar el fichero .ko resultante de dicha compilaci\u00f3n en la placa. Para ello han de seguirse los siguientes pasos: Abrir un navegador web en la m\u00e1quina virtual y descargar el fichero linux-raspberry.tgz usando este enlace . El fichero comprimido contiene un kernel Linux ya compilado para la Raspberry Pi, que nos permite realizar compilaci\u00f3n cruzada de m\u00f3dulos del kernel. Extraer el fichero comprimido en el HOME del usuario kernel . (Se asume que el fichero descargado se almacena en ~/Descargas ). $ cd $ tar xzvf ./ Descargas / linux-raspberry . tgz Instalar el compilador cruzado (deber\u00eda encontrarse ya instalado en la m\u00e1quina virtual): $ sudo apt install gcc-8-arm-linux-gnueabihf gcc-arm-linux-gnueabihf Ir al directorio Clipboard y borrar ficheros resultantes de compilaciones previas usando el Makefile convencional: kernel @debian :~$ cd FicherosP1 / Clipboard kernel @debian :~/ FicherosP1 $ make clean Generar el .ko adecuado para el kernel de la Raspberry pi usando el comando make -f Makefile.cross desde el mismo directorio donde nos encontramos. N\u00f3tese que con la opci\u00f3n -f de GNU Make se escoge manualmente el fichero Makefile para realizar la compilaci\u00f3n. Finalmente, copiar el fichero .ko a la Raspberry Pi usando scp y probar dicho m\u00f3dulo en la placa Comando de copia del fichero al directorio HOME del usuario pi en la placa: scp clipboard.ko pi@pi:.","title":"Ejercicio 5"},{"location":"linux-kernel/drivers/#ejercicio-6","text":"El m\u00f3dulo del kernel ModledsPi_gpiod modifica el estado de los LEDs D1, D2 y D3 de la placa Bee v2.0. En particular, al cargar este m\u00f3dulo en la Raspberry Pi, los citados LEDs se encienden; al descargar el m\u00f3dulo, estos LEDs se apagan. En este ejercicio se plantea analizar la implementaci\u00f3n de este m\u00f3dulo, cuyo c\u00f3digo deber\u00e1 reutilizarse para la implementaci\u00f3n de la pr\u00e1ctica. Para ello se ha de prestar especial atenci\u00f3n a la siguiente funci\u00f3n: static inline int set_pi_leds ( unsigned int mask ) { int i ; for ( i = 0 ; i < NR_GPIO_LEDS ; i ++ ) gpiod_set_value ( gpio_descriptors [ i ], ( mask >> i ) & 0x1 ); return 0 ; } La funci\u00f3n set_pi_leds() acepta como par\u00e1metro una m\u00e1scara de bits que especifica el estado de cada LED. Si el bit correspondiente est\u00e1 a \"1\", el LED asociado se enciende; si est\u00e1 a \"0\" se apagar\u00e1. La correspondencia entre los bits de la m\u00e1scara ( unsigned int ) y los LEDs es la siguiente: Bit 0: Led D3 Bit 1: Led D2 Bit 2: Led D1 Bits 3-31: Se ignoran","title":"Ejercicio 6"},{"location":"linux-kernel/drivers/#ejercicio-7","text":"Estudiar el funcionamiento e implementaci\u00f3n del m\u00f3dulo de ejemplo Misc7seg , que al igual que el del ejercicio anterior ha sido creado especificamente para la placa de E/S Bee 2.0. Este driver --m\u00f3dulo del kernel--, al cargarse, expone el display 7 segmentos de la placa al usuario mediante el fichero especial de caracteres /dev/display7s , perteneciente a la clase misc del LDM. El driver permite alterar el estado del display escribiendo desde espacio de usuario en dicho fichero especial. La implementaci\u00f3n, no obstante, ignora la cadena o secuencia de bytes escrita en el fichero de dispositivo con write() , y simplemente altera el estado del display encendiendo segmentos espec\u00edficos siguiendo un patr\u00f3n determinado. Para averiguar el patr\u00f3n de encendido de los segmentos, que se realiza en display7s_write() , se pueden realizar escrituras con echo > /dev/display7s de forma manual, o empleando un bucle infinito (a terminar con CTRL+C) como en el siguiente comando: $ while true ; do echo > /dev/display7s ; sleep 0 .4 ; done Una parte cr\u00edtica de este ejercicio es comprender c\u00f3mo el m\u00f3dulo del kernel controla el estado del display 7 segmentos, usando pines espec\u00edficos de la Raspberry Pi. El display integrado en la placa tiene los 7 segmentos habituales ( a , b , c , ...., g ) y uno extra para el punto --llamado dp --. Ya que dedicar 8 pines para controlar estos segmentos limita enormemente el uso simult\u00e1neo de otros dispositivos de E/S, la placa Bee v2.0 integra un circuito para controlar el display que solo requiere 3 pines. La siguiente figura muestra un diagrama del circuito: El circuito consta de 3 m\u00f3dulos fundamentales: un registro de desplazamiento (etapa de entrada), un registro convencional con carga paralela, y el m\u00f3dulo del display 7 segmentos propiamente dicho, que integra los LEDs correspondientes y una serie de resistencias de entrada (no mostradas en el diagrama, por simplicidad). El sistema consta de las siguientes 3 entradas: SDI ( Serial Data Input ): codifica el bit de entrada serie al registro de desplazamiento Esta entrada se controla con el GPIO 18 de la Raspberry Pi SRCLK ( Shift Register Clock ): se\u00f1al de reloj del registro de desplazamiento Esta se\u00f1al de reloj se controla con el GPIO 23 de la Raspberry Pi RCLK ( Register Clock ): se\u00f1al de reloj del registro de salida Esta se\u00f1al de reloj se controla con el GPIO 24 de la Raspberry Pi Como podemos observar en el diagrama, las se\u00f1ales de enable (EN) del registro de desplazamiento, y de carga (LOAD) del registro de salida est\u00e1n a 1, por lo que los m\u00f3dulos realizar\u00e1n su acci\u00f3n espec\u00edfica --desplazamiento, y carga paralela, respectivamente-- siempre que se produzca un flanco de subida en su se\u00f1al de reloj correspondiente. El estado de los segmentos se representa mediante un n\u00famero de 8 bits, estando representado el segmento a mediante el bit m\u00e1s significativo, y dp por el bit menos significativo. Como los LEDs del m\u00f3dulo que implementa el display 7 segmentos est\u00e1n en configuraci\u00f3n de c\u00e1todo com\u00fan , un bit a 1 enciende el segmento correspondiente, y un 0 lo apaga. Intuitivamente, para actualizar el estado del display desde la CPU han de seguirse estos pasos: Asegurarse de que los pines que controlan la se\u00f1al de reloj SRCLK y RCLK est\u00e1n a cero al principio del procedimiento Para cada bit del n\u00famero de estado (8 bits), recorriendo los bits de izquierda a derecha: Escribir el bit actual en la entrada SDI usando el GPIO asociado Generar un pulso de reloj en el registro de desplazamiento con la entrada SRCLK modulando la se\u00f1al (\"dibujando el pulso\") mediante el pin GPIO correspondiente RCLK estar\u00e1 siempre a cero durante esta etapa. Al final del punto anterior, la entrada paralela del registro de salida ya tiene los bits en el orden deseado ya que se han ido desplazando todos hacia la izquierda. Por lo tanto, basta generar un pulso de reloj en la se\u00f1al RCLK , para cargar el n\u00famero en el registro. Al hacer esto, se actualizar\u00e1 autom\u00e1ticamente la salida del registro, y por tanto el estado de los segmentos en el display. La funci\u00f3n del driver que implementa el citado procedimiento de actualizaci\u00f3n del estado del display es update_7sdisplay() : #define SEGMENT_COUNT 8 static void update_7sdisplay ( unsigned char data ) { int i = 0 ; int value = 0 ; for ( i = 0 ; i < SEGMENT_COUNT ; i ++ ) { /* Explore current bit (from most significant to least significant) */ if ( 0x80 & ( data << i )) value = 1 ; else value = 0 ; /* Set value of serial input */ gpiod_set_value ( gpio_descriptors [ SDI_IDX ], value ); /* Generate clock cycle in shift register */ gpiod_set_value ( gpio_descriptors [ SRCLK_IDX ], 1 ); msleep ( 1 ); gpiod_set_value ( gpio_descriptors [ SRCLK_IDX ], 0 ); } /* Generate clock cycle in output register to update 7-seg display */ gpiod_set_value ( gpio_descriptors [ RCLK_IDX ], 1 ); msleep ( 1 ); gpiod_set_value ( gpio_descriptors [ RCLK_IDX ], 0 ); } La alteraci\u00f3n de las se\u00f1ales SDI, SRCLK y RCLK se realiza mediante bit banging , es decir modificando el valor del pin manualmente desde la CPU, pero de forma temporizada, realizando las esperas necesarias para garantizar que la se\u00f1al se mantenga un cierto tiempo en el valor l\u00f3gico deseado. En particular, para garantizar que el pulso de reloj tenga una duraci\u00f3n m\u00ednima garantizada de 1ms, el driver hace uso de la funci\u00f3n msleep() del kernel, que bloquea al flujo de ejecuci\u00f3n invocador durante el periodo de tiempo en ms indicado como argumento.","title":"Ejercicio 7"},{"location":"linux-kernel/drivers/#desarrollo-de-la-practica","text":"Esta pr\u00e1ctica consta de dos partes: A y B","title":"Desarrollo de la pr\u00e1ctica"},{"location":"linux-kernel/drivers/#parte-a","text":"Implementar un driver de dispositivo de caracteres Modleds-dev-pi que permita establecer el estado de los LEDS D1-D3 de la placa Bee v2.0. Al cargar dicho driver se crear\u00e1 autom\u00e1ticamente un fichero especial de caracteres /dev/leds . El estado de los LEDs podr\u00e1 alterarse escribiendo un n\u00famero del 0 al 7 (m\u00e1scara de 3 bits) al fichero especial. La correspondencia entre los bits de esta m\u00e1scara y los LEDs ser\u00e1 la siguiente: Bit 2: encender/apagar LED D3 Bit 1: encender/apagar LED D2 Bit 0: encender/apagar LED D1 La siguiente tabla muestra algunos ejemplos: N\u00famero escrito en /dev/leds D3 D2 D1 4 ON OFF OFF 7 ON ON ON 3 OFF ON ON 0 OFF OFF OFF 2 OFF ON OFF Si el usuario escribe una cadena de caracteres que no sea 0-7 la escritura sobre el dispositivo deber\u00e1 devolver un error: $ pi@raspberrypi:~ $ echo 9 > /dev/leds -bash: echo: write error: Invalid argument $ pi@raspberrypi:~ $ echo potato > /dev/leds -bash: echo: write error: Invalid argument Para probar el funcionamiento del driver Modleds-dev se aconseja ejecutar el siguiente script BASH, que altera peri\u00f3dicamente el estado de los LEDs para emular un contador binario m\u00f3dulo 7: #!/bin/bash while true do for (( i = 0 ; $i < 8 ; i++ )) do echo $i > /dev/leds sleep 0 .4 done done","title":"Parte A"},{"location":"linux-kernel/drivers/#parte-b","text":"Extender la funcionalidad del m\u00f3dulo de ejemplo Misc7seg (Ejercicio 7), para que el usuario pueda especificar el d\u00edgito hexadecimal (de 0 a F) que se desea mostrar en el display 7 segmentos escribiendo en el fichero especial de caracteres /dev/display7s . Para ello se ha de modificar la funci\u00f3n display7s_write() . Tambi\u00e9n se recomienda definir macros que codifiquen el n\u00famero de 8 bits que ha de escribirse en el display para representar cada d\u00edgito hexadecimal.","title":"Parte B"},{"location":"linux-kernel/interrupt-timers-pwm/","text":"Drivers en Linux. Gesti\u00f3n de interrupciones, temporizadores, y trabajos diferidos \u00b6 Objetivos \u00b6 El principal objetivo de esta pr\u00e1ctica es familiarizarse con la gesti\u00f3n de interrupciones en el kernel Linux, los temporizadores del kernel, y la creaci\u00f3n y planificaci\u00f3n de tareas diferidas mediante workqueues . Como objetivo secundario, se estudiar\u00e1n los fundamentos sobre generaci\u00f3n de se\u00f1ales PWM por hardware en Linux. El c\u00f3digo para esta pr\u00e1ctica puede descargarse aqu\u00ed . Antes de comenzar con los ejercicios de esta pr\u00e1ctica es preciso consultar la introducci\u00f3n al uso de PWM por hardware en Linux, que se encuentra en la siguiente secci\u00f3n. Teor\u00eda de la pr\u00e1ctica La teor\u00eda asociada a esta pr\u00e1ctica se imparte en la asignatura \"Arquitectura Interna de Linux y Android\", ofertada en las distintas titulaciones de grado en la Facultad de Inform\u00e1tica de la Universidad Complutense de Madrid. Para m\u00e1s informaci\u00f3n sobre la asignatura consultad a Juan Carlos S\u00e1ez Alcaide . Para documentarse sobre la tem\u00e1tica de forma aut\u00f3noma se proporcionan las siguientes referencias: Peter Jay Salzman, Michael Burian, Ori Pomerantz, Bob Mottram, Jim Huang. Linux Kernel Module Programming Guide . 2025. Disponible online . Versi\u00f3n en PDF Kaiwan N. Billimoria. Linux Kernel Programming . Packt Publishing. 1st edition. 2021 Kaiwan N. Billimoria. Linux Kernel Programming. Part 2 - Char Device Drivers and Kernel Synchronization . Packt Publishing. 1st edition. 2021 Robert Love; Linux Kernel Development . Addison Wesley, 3rd Edition. Julio 2010 PWM por hardware en Linux \u00b6 Una se\u00f1al PWM ( Pulse Width Modulation ) es una se\u00f1al digital caracterizada por dos par\u00e1metros: el periodo ( period ) y el ciclo de trabajo ( duty cycle ), que pueden ajustarse a lo largo del tiempo. Como se muestra en la siguiente figura, el periodo es el intervalo de tiempo transcurrido entre dos flancos consecutivos de subida (o de bajada), y el duty cycle es la fracci\u00f3n de tiempo dentro de un periodo en la que la se\u00f1al est\u00e1 a \"1\" . Este tipo de se\u00f1ales tienen un amplio espectro de aplicaciones, como el control de servomotores y ventiladores, o el ajuste de intensidad de los distintos componentes de color de LEDs RGB. Las se\u00f1ales PWM se pueden generar por software en dispositivos equipados con pines GPIO, mediante bit banging , es decir ajustando manualmente la se\u00f1al de salida de un pin a lo largo del tiempo. Por ejemplo, en el m\u00f3dulo Misc7seg que se distribuye con el material de la Pr\u00e1ctica 3 de la asignatura, las se\u00f1ales que gobiernan el display 7 segmentos de la placa --que no son PWM-- se controlan mediante bit banging . Generar se\u00f1ales PWM mediante bit banging tiene asociado un alto consumo de CPU; un flujo de ejecuci\u00f3n debe dedicarse a generar cada se\u00f1al a grano fino y controlar de forma precisa el tiempo entre flancos. Adem\u00e1s, esta t\u00e9cnica no resulta adecuada para sistemas que no tienen garant\u00edas de tiempo real, como la versi\u00f3n vanilla del kernel Linux. En este tipo de sistemas nada impide que el c\u00f3digo generador de la se\u00f1al PWM que se ejecuta en una CPU o n\u00facleo espec\u00edfico de la m\u00e1quina (incluso siendo parte del sistema operativo) pueda ser interrumpido por c\u00f3digo m\u00e1s prioritario (p.ej., manejador de una interrupci\u00f3n no enmascarable); en tal caso no es posible garantizar suficiente precisi\u00f3n para imponer un periodo o un duty cycle espec\u00edfico, lo cual puede desencadenar un mal funcionamiento del sistema gobernado por la se\u00f1al PWM. Para solventar este problema existen dispositivos hardware espec\u00edficos dedicados a la generaci\u00f3n de se\u00f1ales PWM, que no requieren la intervenci\u00f3n continuada de la CPU. El estudio de la API de Linux para el uso de estos dispositivos es el foco principal de esta introducci\u00f3n. En Linux hay dos agentes involucrados en el uso del hardware PWM: los drivers PWM y los usuarios PMW (tambi\u00e9n llamados PWM consumers ). Los drivers PWM implementan el soporte necesario en Linux para interactuar directamente con el hardware PWM. Para la implementaci\u00f3n de estos drivers se emplean las funciones pwmchip_add() y pwmchip_remove() , que registran y desregistran respectivamente una estructura struct pwm_chip . Esta estructura --adecuadamente inicializada por el driver-- describe al kernel las caracteristicas del chip PWM espec\u00edfico (incluyendo el n\u00famero de canales PWM que soporta), y proporciona una implementaci\u00f3n espec\u00edfica del driver para interactuar con el chip PWM en cuesti\u00f3n. Los usuarios o consumers PWM hacen uso de una interfaz de programaci\u00f3n de Linux que garantiza portabilidad, abstrayendo los detalles de bajo nivel asociados a la configuraci\u00f3n de un chip PWM espec\u00edfico. Numerosos drivers en Linux actuan como consumers de PWM. A continuaci\u00f3n se describe la interfaz de programaci\u00f3n usada por los consumers PWM, que ser\u00e1 necesario utilizar en la pr\u00e1ctica. Pulse Width Modulation (PWM) Consumer Interface \u00b6 Para poder usar uno de los canales PWM disponibles en la plataforma es necesario obtener primero un descriptor del dispositivo PWM, representado por el tipo de datos struct pwm_device* . Una de las formas m\u00e1s directas para obtener tal descriptor es mediante la funci\u00f3n pwm_request() declarada en <linux/pwm.h> : struct pwm_device * pwm_request ( int pwm , const char * label ); Par\u00e1metros: pwm : \u00cdndice global del dispositivo PWM en el sistema label : Etiqueta descriptiva del dispositivo PWM Nota: En la Raspberry Pi, puede usarse cualquier cadena de caracteres arbitraria para este par\u00e1metro. El dispositivo PWM solicitado mediante pwm_request() queda reservado para uso exclusivo del driver ( consumer ) que invoc\u00f3 la llamada. Cuando el dispositivo deje de estar en uso (p.ej., en la funci\u00f3n cleanup() del m\u00f3dulo del kernel correspondiente), el driver debe liberarlo usando la funci\u00f3n pwm_free() , que acepta como par\u00e1metro el descriptor retornado por pwm_request() : void pwm_free ( struct pwm_device * pwm ); Para configurar una se\u00f1al PWM con el dispositivo, el driver ha de crear una variable (local) de tipo struct pwm_state , que representa el estado de un canal PWM. La definici\u00f3n y documentaci\u00f3n sobre esta estructura se encuentra en <linux/pwm.h> : /* * struct pwm_state - state of a PWM channel * @period: PWM period (in nanoseconds) * @duty_cycle: PWM duty cycle (in nanoseconds) * @polarity: PWM polarity * @enabled: PWM enabled status * @usage_power: If set, the PWM driver is only required to maintain the power * output but has more freedom regarding signal form. * If supported, the signal can be optimized, for example to * improve EMI by phase shifting individual channels. */ struct pwm_state { u64 period ; u64 duty_cycle ; enum pwm_polarity polarity ; bool enabled ; bool usage_power ; }; El procedimiento de configuraci\u00f3n de un canal PWM mediante esta estructura estado conlleva la realizaci\u00f3n de los siguientes pasos: Almacenamiento del estado actual del canal PWM en la estructura mediante la funci\u00f3n pwm_init_state() . Esta funci\u00f3n acepta como par\u00e1metro el descriptor del dispositivo PWM y la estructura cuyos campos se rellenar\u00e1n con la informaci\u00f3n actual del estado del canal: void pwm_init_state ( const struct pwm_device * pwm , struct pwm_state * state ) Modificaci\u00f3n manual de los campos de la estructura de estado, seg\u00fan las propiedades de la se\u00f1al PWM que se desee generar. Habitualmente se modifican los campos period (periodo de la se\u00f1al, especificado en nanosegundos), duty_cycle (longitud del pulso del \"1\" l\u00f3gico dentro del periodo), y enabled (indicador de canal PWM activado). Alternativamente, el valor del campo duty_cycle puede establecerse de forma indirecta como fracci\u00f3n sobre el periodo. Para ello ha de emplearse la siguiente funci\u00f3n: int pwm_set_relative_duty_cycle ( struct pwm_state * state , unsigned int duty_cycle , unsigned int scale ); Los par\u00e1metros duty_cycle y scale permiten especificar la fracci\u00f3n de duty cycle deseada, como cociente de ambos par\u00e1metros. As\u00ed, por ejemplo, para establecer un duty cycle del 70%, los valores de los citados par\u00e1metros pueden establecerse a 70 y 100 respectivamente. Una vez se han establecido los valores deseados en la estructura de estado, se ha de aplicar la configuraci\u00f3n al canal PWM usando la funci\u00f3n pwm_apply_state() : int pwm_apply_state ( struct pwm_device * pwm , const struct pwm_state * state ); Finalmente merece la pena mencionar la existencia de las funciones pwm_enable() y pwm_disable() que permiten respectivamente activar y desactivar la salida emitida por el canal PWM asociado al dispositivo pasado como par\u00e1metro: int pwm_enable ( struct pwm_device * pwm ); int pwm_disable ( struct pwm_device * pwm ); Las funciones PWM descritas en esta secci\u00f3n son las \u00fanicas que han de utilizarse para la implementaci\u00f3n de la pr\u00e1ctica. Para obtener informaci\u00f3n m\u00e1s extensa sobre \u00e9stas u otras llamadas de la API PWM, se puede consultar la documentaci\u00f3n oficial del kernel Linux . Ejercicios \u00b6 Ejercicio 1 \u00b6 Estudiar la implementaci\u00f3n del m\u00f3dulo de ejemplo GPIODInterrupt analizado en clase. Este m\u00f3dulo del kernel instala un manejador de interrupci\u00f3n que se ejecuta tras pulsar el bot\u00f3n SW1 de la placa Bee. Cuando se pulsa SW1, se genera una interrupci\u00f3n (controlada por flanco de subida). En respuesta a esta interrupci\u00f3n, el m\u00f3dulo del kernel conmuta el estado de los LEDs D1-D3 de la placa (ON/OFF). Ejercicio 2 \u00b6 Estudiar la implementaci\u00f3n de los m\u00f3dulos de ejemplo workqueue1.c , workqueue2.c y workqueue3.c (en directorio Workqueues ), que ilustran el proceso de creaci\u00f3n de tareas diferidas mediante el mecanismo de workqueues . Conteste a las siguientes preguntas: \u00bfQu\u00e9 diferencias existen entre el m\u00f3dulo del kernel workqueue1.c y workqueue1.c en lo que respecta a la workqueue empleada para diferir trabajo? \u00bfSe insertan las tareas diferidas en la misma cola? \u00bfCu\u00e1l es el prop\u00f3sito de la estructura espec\u00edfica ( my_work_t ) definida en el ejemplo worqueue3.c ? Ejercicio 3 \u00b6 Analizar el m\u00f3dulo ExampleTimer que gestiona un temporizador del kernel que se activa cada segundo e imprime un mensaje con printk() . Al igual que se hizo con el ejemplo de kernel thread de la pr\u00e1ctica anterior, se recomienda usar el comando : sudo dmesg -w , para poder observar la impresi\u00f3n peri\u00f3dica del mensaje del temporizador el fichero de log del kernel. kernel@debian:~$ sudo dmesg -w [ sudo ] password for kernel: ... Dec 4 14 :15:22 debian kernel: [ 233644 .504010 ] Tic Dec 4 14 :15:23 debian kernel: [ 233645 .524021 ] Tac Dec 4 14 :15:24 debian kernel: [ 233646 .544028 ] Tic Dec 4 14 :15:25 debian kernel: [ 233647 .564029 ] Tac Dec 4 14 :15:26 debian kernel: [ 233648 .584021 ] Tic Dec 4 14 :15:27 debian kernel: [ 233649 .604031 ] Tac ... Los temporizadores del kernel son one shot por defecto; es decir, una vez que se ejecuta la funci\u00f3n asociada, el temporizador no se reconfigura autom\u00e1ticamente para invocar de nuevo la funci\u00f3n en el futuro. Sin embargo, en el m\u00f3dulo del kernel de ejemplo, la funci\u00f3n del temporizador se invoca una vez por segundo hasta que el m\u00f3dulo se descarga del kernel. \u00bfC\u00f3mo se consigue que el m\u00f3dulo del kernel tenga este comportamiento? Ejercicio 4 \u00b6 Una de las aplicaciones del uso de PWM por hardware es la generaci\u00f3n de una se\u00f1al digital con frecuencia espec\u00edfica (y potencialmente variable) para reproducir notas musicales utilizando un zumbador o buzzer pasivo, como el que integra la placa Bee v2.0. La Raspberry Pi (modelos 3B+ o 4) integra dos canales PWM (0 y 1), que est\u00e1n asociados a los GPIOs 12 y 13 respectivamente seg\u00fan la configuraci\u00f3n actual del kernel (v\u00e9ase el fichero /boot/config.txt ). Con las conexiones fijadas actualmente en la placa, la se\u00f1al de entrada del buzzer est\u00e1 conectada directamente al GPIO 12 (canal PWM0). Este ejercicio consiste en estudiar el m\u00f3dulo del kernel de ejemplo test-buzzer.c , que al cargarse reproduce mediante el buzzer una melod\u00eda fija (hardcodeada en las fuentes) usando una se\u00f1al PWM desde una tarea diferida ( workqueue ). Nota importante: Cabe destacar que las funciones analizadas en la secci\u00f3n anterior que aceptan un par\u00e1metro de tipo struct pwm_device son bloqueantes, por lo que solo pueden invocarse desde contexto de proceso. \u00c9ste el tipo de contexto en el que se ejecutan las tareas diferidas mediante workqueues . Para la realizaci\u00f3n de la pr\u00e1ctica es preciso reusar el c\u00f3digo de este m\u00f3dulo de ejemplo. Por ello, se proporciona a continuaci\u00f3n una breve descripci\u00f3n de las estructuras, definiciones y funciones auxiliares m\u00e1s importantes del m\u00f3dulo. Para representar cada nota o silencio que forma parte de la melod\u00eda se emplea la siguiente estructura de 32 bits: struct music_step { unsigned int freq : 24 ; /* Frequency in centihertz */ unsigned int len : 8 ; /* Duration of the note */ }; El campo freq (24 bits) codifica la frecuencia de la nota en centihercios (el valor 0 se usa para representar los silencios). El campo len (de 8 bits) almacena la duraci\u00f3n de la nota o silencio. Esta duraci\u00f3n se representa mediante una m\u00e1scara de bits, donde los siete primeros bits se asocian a la presencia de alguna de las siguientes figuras b\u00e1sicas en la especificaci\u00f3n de la duraci\u00f3n de la nota: Bit 0: Redonda (1)^[Los valores entre par\u00e9ntesis denotan el n\u00famero de figuras del tipo en cuesti\u00f3n que equivalen a la duraci\u00f3n de una redonda, la figura de referencia habitual en m\u00fasica.] Bit 1: Blanca (2) Bit 2: Negra (4) Bit 3: Corchea (8) Bit 4: Semicorchea (16) Bit 5: Fusa (32) Bit 6: Semifusa (64) El bit 7 del campo len se emplea para indicar si la figura en cuesti\u00f3n se encuentra dentro de un tresillo : figura musical irregular que agrupa 3 figuras musicales en el tiempo de 2 equivalentes regulares. Esta representaci\u00f3n de la duraci\u00f3n con 8 bits hace posible cubrir un amplio espectro de duraciones de notas presentes en melod\u00edas de la m\u00fasica popular. As\u00ed por ejemplo: Para representar la duraci\u00f3n de una negra el campo len tendr\u00e1 el valor 4 (bit 2 activo, \u00fanicamente) Para representar una corchea en nuestra \"partitura\" usaremos len=8 (bit 2 activo \u00fanicamente). Si esta corchea formara parte de un tresillo, se habilitar\u00eda tambi\u00e9n el bit 7 ( len=0x88 ). Para las figuras con puntillo, que representan 1.5 veces la duraci\u00f3n de la figura original a la que se aplica el puntillo, es preciso activar dos bits en el campo len . En particular, si queremos representar una negra con puntillo, es necesario reflejar la duraci\u00f3n de una negra m\u00e1s la mitad de \u00e9sta (corchea), para lo cual se han de activar los bits 2 y 3 en el campo len ( len=0x0C ). La melod\u00eda que el m\u00f3dulo del kernel reproduce se encuentra definida como variable local melodic_line de la funci\u00f3n my_wq_function() que representa el trabajo diferido: /* Frequency of selected notes in centihertz */ #define C4 26163 #define D4 29366 #define E4 32963 #define F4 34923 #define G4 39200 #define C5 52325 ... static void my_wq_function ( struct work_struct * work ) { struct music_step melodic_line [] = { { C4 , 4 }, { E4 , 4 }, { G4 , 4 }, { C5 , 4 }, { 0 , 2 }, { C5 , 4 }, { G4 , 4 }, { E4 , 4 }, { C4 , 4 }, { 0 , 0 } /* Terminator */ }; const int beat = 120 ; /* 120 quarter notes per minute */ struct music_step * next = melodic_line ; /* Play notes sequentially until end marker is found */ for ( next = melodic_line ; ! is_end_marker ( next ); next ++ ) { ... Code to play the current note ... } } La melod\u00eda (array) se define mediante un inicializador est\u00e1tico de \"C\". Dicho array consta de una entrada por cada nota o silencio de la melod\u00eda, con un music_step terminador al final. Por simplicidad en la representaci\u00f3n de la melod\u00eda se hace referencia a las notas de la misma mediante una macro que asocia la representaci\u00f3n en ingl\u00e9s de la nota (por ejemplo, E4 es la nota mi con altura 4) con su frecuencia en centihercios correspondiente a la afinaci\u00f3n temperada est\u00e1ndar. Para consultar la frecuencia de otras notas musicales se puede visitar esta p\u00e1gina . La tarea diferida recorre secuencialmente la cada paso ( music_step ) de la melod\u00eda. Si el paso actual es un silencio (frecuencia igual 0) se desactiva la se\u00f1al PWM, y si es una nota (frecuencia distinta de 0) se establece adecuadamente el periodo de la se\u00f1al PWM con el valor inverso de la frecuencia de la nota. A continuaci\u00f3n se ejecuta la funci\u00f3n msleep() para que el kernel thread que ejecuta esta tarea diferida se bloquee durante el tiempo asociado a la nota o silencio actual de la melod\u00eda. Para el c\u00e1lculo del tiempo es preciso que haya una referencia de la duraci\u00f3n de cada figura musical (blanca, negra, etc.). Por simplicidad, la variable local beat almacena el n\u00famero de negras por minuto a modo de indicaci\u00f3n de metr\u00f3nomo, que en este caso se fija a 120. La funci\u00f3n calculate_delay_ms() definida en el m\u00f3dulo del kernel calcula la duraci\u00f3n de la nota (retardo especificado en milisegundos) en base a los bits activados en el campo len y considerando el valor actual de beat como referencia (segundo par\u00e1metro de la llamada): /** * Transform note length into ms, * taking the beat of a quarter note as reference */ static inline int calculate_delay_ms ( unsigned int note_len , unsigned int qnote_ref ){ unsigned char duration = ( note_len & 0x7f ); unsigned char triplet = ( note_len & 0x80 ); unsigned char i = 0 ; unsigned char current_duration ; int total = 0 ; /* Calculate the total duration of the note * as the summation of the figures that make * up this note (bits 0-6) */ while ( duration ){ current_duration = ( duration ) & ( 1 << i ); if ( current_duration ){ /* Scale note accordingly */ if ( triplet ) current_duration = ( current_duration * 3 ) / 2 ; /** * 24000/qnote_ref denote number of ms associated * with a whole note (redonda) */ total += ( 240000 ) / ( qnote_ref * current_duration ); /* Clear bit */ duration &=~ ( 1 << i ); } i ++ ; } return total ; } Tras analizar el c\u00f3digo del m\u00f3dulo, trata de responder a las siguientes preguntas: \u00bfPor qu\u00e9 la melod\u00eda se reproduce una sola vez al cargar el m\u00f3dulo del kernel? \u00bfQu\u00e9 cambio deber\u00eda realizarse en la implementaci\u00f3n para que la melod\u00eda se reprodujera m\u00e1s r\u00e1pido (por ejemplo al doble de velocidad)? \u00bfQu\u00e9 sucede si intentamos descargar el m\u00f3dulo mientras la melod\u00eda est\u00e1 a\u00fan reproduci\u00e9ndose? \u00bfC\u00f3mo se consigue este comportamiento? Desarrollo de la pr\u00e1ctica \u00b6 Esta pr\u00e1ctica consta de dos partes. En la primera parte se ejercitar\u00e1 el uso de manejadores de interrupci\u00f3n y temporizadores del kernel. En la segunda parte, se emplear\u00e1n estas dos abstracciones del kernel en combinaci\u00f3n con las workqueues y la API de PWM. Parte A \u00b6 Desarrollar un m\u00f3dulo del kernel SMP-safe llamado timerleds.c que establezca la configuraci\u00f3n de los LEDs de la placa Bee para que se enciendan/apaguen usando una secuencia prefijada, como un contador binario, o el encendido de un LED distinto en cada paso de la secuencia (desplazamiento). La transici\u00f3n entre cada paso de la secuencia debe realizarse autom\u00e1ticamente utilizando un temporizador del kernel, que actualice peri\u00f3dicamente el estado de los LEDs. El periodo del temporizador (dado en milisegundos) ha de ser configurable mediante un par\u00e1metro timer_period_ms a establecer durante la carga del m\u00f3dulo. Adem\u00e1s, el m\u00f3dulo del kernel debe permitir al usuario pausar y reanudar la actividad del temporizador del kernel mediante el uso del pulsador SW1 de la placa. Implementar esta funcionalidad conlleva instalar un manejador de interrupci\u00f3n asociado al GPIO del pulsador SW1. Nota importante: t\u00e9ngase en cuenta que la funci\u00f3n del_timer_sync() para desactivar un temporizador del kernel activo es bloqueante, por lo que NO puede ejecutarse en contexto de interrupci\u00f3n. Por simplicidad en el desarrollo de este apartado se aconseja reutilizar c\u00f3digo de los siguientes ejemplos: TimerExample : Ejercicio 3 de esta pr\u00e1ctica GPIODInterrupt : C\u00f3digo analizado en clase (Ejercicio 1) , donde se hace uso combinado de los LEDs y el pulsador Hello5 : M\u00f3dulo de ejemplo de la Pr\u00e1ctica 1, donde se ilustra el uso de par\u00e1metros de los m\u00f3dulos del kernel. Parte B \u00b6 Desarrollar un driver SMP-safe en Linux ( buzzer.c ) que permita reproducir melod\u00edas proporcionadas por el usuario empleando el buzzer presente en la placa Bee v2.0. El driver exportar\u00e1 un fichero especial de caracteres /dev/buzzer que permitir\u00e1 configurar tanto la melod\u00eda a reproducir, como la velocidad de reproducci\u00f3n de \u00e9sta. Adem\u00e1s, el usuario podr\u00e1 iniciar la reproducci\u00f3n de la melod\u00eda, detenerla o reanudarla presionando el pulsador SW1 de la placa Bee. El usuario especificar\u00e1 al m\u00f3dulo del kernel la melod\u00eda a reproducir escribiendola en el fichero /dev/buzzer . La melod\u00eda se representa mediante una cadena de caracteres, que comienza por el prefijo \"music \" seguido de una lista de notas musicales o silencios con una duraci\u00f3n determinada. Cada nota en la melodia se denota mediante un par \"frecuencia:duraci\u00f3n\", donde ambos componentes del par tendr\u00e1n la misma sem\u00e1ntica que en el m\u00f3dulo del kernel TestBuzzer del Ejercicio 4 (estructura music_step ). Dos notas consecutivas de una l\u00ednea mel\u00f3dica se separar\u00e1n mediante una coma. Para ilustrar esta representaci\u00f3n de las melod\u00edas, consid\u00e9rese el siguiente comando, que permite configurar la misma melod\u00eda que se encuentra hardcodeada en el ejemplo TestBuzzer : $ echo music 26163 :0x4,32963:0x4,39200:0x4,52325:0x4,0:0x2,52325:0x4,39200:0x4,32963:0x4,26163:0x4 > /dev/buzzer El driver tambi\u00e9n permitir\u00e1 la configuraci\u00f3n del ritmo de reproducci\u00f3n de la melod\u00eda escribiendo en /dev/buzzer el valor de un par\u00e1metro beat que indique cu\u00e1ntas negras por minuto han de reproducirse (como la variable beat del ejemplo TestBuzzer ). Para modificar o consultar el valor actual de este par\u00e1metro se deber\u00e1 escribir o leer del fichero especial de caracteres del siguiente modo: ## Establecer valor de beat a 150 $ echo beat 150 > /dev/buzzer ## Consultar el valor actual de beat $ cat /dev/buzzer beat = 150 ... Para simplificar el desarrollo de la pr\u00e1ctica y la configuraci\u00f3n de melod\u00edas se proporcionan algunos ficheros en el directorio Util de los ejemplos de esta pr\u00e1ctica. En particular, en este directorio se encuentra la utilidad music_converter.py , y una serie de melod\u00edas en un formato de mayor nivel de abstracci\u00f3n (ficheros \".music\") que el que el driver usa como entrada. Se deja como ejercicio analizar ese formato de alto nivel y tratar de escribir nuevas melod\u00edas usando este sencillo formato. La utilidad music_converter.py permite convertir las melod\u00edas \".music\" al formato de entrada del driver usando como argumentos un fichero donde se encuentra la tabla de frecuencias que corresponde a cada nota musical, y el fichero de extensi\u00f3n \".music\" a convertir. El modo de uso del programa es el siguiente: music_converter.py freq_table.csv <fichero.music> Como la utilidad imprime el resultado de la conversi\u00f3n por la salida est\u00e1ndar, es preciso usar una sentencia de redirecci\u00f3n para escribir la configuraci\u00f3n en /dev/buzzer , como en el siguiente ejemplo: pi@raspberrypi:~/P5/Util$ ./music_converter.py freq_table.csv ode_to_joy.music > /dev/buzzer Por simplicidad se recomienda almacenar la melod\u00eda en una variable global melody : un array de estructuras music_step , cuya memoria ha de reservarse con vmalloc(PAGE_SIZE) en la funci\u00f3n de inicializaci\u00f3n del m\u00f3dulo del kernel. Para concluir la descripci\u00f3n de la pr\u00e1ctica se proporcionan a continuaci\u00f3n detalles adicionales de su funcionamiento, as\u00ed como restricciones de implementaci\u00f3n. Gesti\u00f3n del pulsador SW1 \u00b6 Inicialmente al cargar el m\u00f3dulo no se reproducir\u00e1 ninguna melod\u00eda. El usuario deber\u00e1 pulsar SW1 para que se inicie la reproducci\u00f3n de la melod\u00eda actual (establecida por defecto, o configurada previamente por el usuario escribiendo en /dev/buzzer ). Si la reproducci\u00f3n de la melod\u00eda no ha terminado, las pulsaciones sucesivas de SW1 detendr\u00e1n y reanudar\u00e1n (respectivamente) la reproducci\u00f3n en/desde el punto donde se encontrase. Si la melod\u00eda acab\u00f3 de reproducirse, una nueva pulsaci\u00f3n de SW1 reiniciar\u00e1 la reproducci\u00f3n de la melod\u00eda desde el principio. Reproducci\u00f3n de la melod\u00eda mediante tarea diferida y temporizador del kernel \u00b6 En el ejemplo TestBuzzer la ejecuci\u00f3n de la tarea diferida se encarga de la reproducci\u00f3n de la melod\u00eda completa. Para ello se hace uso de un bucle, con una iteraci\u00f3n por nota, en el que la se\u00f1al PWM se mantiene con la misma configuraci\u00f3n durante el tiempo que corresponde a la duraci\u00f3n de la nota. La llamada msleep() bloquea al kernel thread que ejecuta la tarea diferida durante el tiempo necesario pasado como par\u00e1metro. En un contexto donde el usuario puede configurar melod\u00edas muy largas esto genera tareas diferidas con un elevado tiempo de ejecuci\u00f3n, lo cual adem\u00e1s dificulta la implementaci\u00f3n del control de la reproducci\u00f3n (parar, reanudar, etc.). Para solventar esta limitaci\u00f3n, en esta parte de la pr\u00e1ctica se usar\u00e1 una tarea diferida m\u00e1s ligera y un temporizador del kernel, que trabajar\u00e1n de forma cooperativa para reproducir la melod\u00eda paso a paso. La tarea diferida se encargar\u00e1 de establecer la frecuencia de la nota actual (periodo se\u00f1al PWM), mientras que el temporizador controlar\u00e1 la duraci\u00f3n de la nota. M\u00e1s concretamente, el funcionamiento ser\u00e1 el siguiente: Cuando el usuario presione el pulsador SW1 (y se genere la interrupci\u00f3n correspondiente), ser\u00e1 necesario planificar la tarea diferida. Al ejecutarse, la tarea diferida reproducir\u00e1 la primera nota de la melod\u00eda, configurando adecuadamente el canal PWM conectado al buzzer . Para garantizar que la nota se mantenga el tiempo suficiente, la tarea diferida programar\u00e1 un temporizador del kernel que expire al finalizar la duraci\u00f3n de la nota, y retornar\u00e1 de la funci\u00f3n correspondiente (fin de tarea diferida). Cuando el temporizador se active, la funci\u00f3n del timer comprobar\u00e1 si la reproducci\u00f3n sigue en estado activo, y en tal caso planificar\u00e1 de nuevo la tarea diferida que procesar\u00e1 la siguiente nota o silencio de la melod\u00eda, dando de nuevo paso al temporizador, as\u00ed hasta el final de la reproducci\u00f3n. Gesti\u00f3n de la concurrencia \u00b6 Uno de los mayores retos de implementaci\u00f3n de la pr\u00e1ctica es la gesti\u00f3n adecuada de la concurrencia. Considerando la especificaci\u00f3n presentada en las secciones anteriores, existen 4 flujos de ejecuci\u00f3n concurrentes en el m\u00f3dulo del kernel: Funci\u00f3n de escritura en /dev/buzzer . El usuario puede alterar la melod\u00eda actual siempre y cuando el buzzer no est\u00e9 reproduciendo actualmente ninguna melod\u00eda (estado BUZZER_PLAYING que se describe m\u00e1s abajo). Cualquier intento de modificar la melod\u00eda cuando est\u00e1 reproduci\u00e9ndose debe gestionarse retornando -EBUSY en la operaci\u00f3n write del fichero especial de caracteres. Manejador de interrupci\u00f3n del pulsador SW1 . El estado de la reproducci\u00f3n de la melod\u00eda puede alterarse de forma as\u00edncrona a petici\u00f3n del usuario Temporizador del kernel . Este temporizador se activar\u00e1 al finalizar la duraci\u00f3n de la nota actual, siempre y cuando la reproducci\u00f3n est\u00e9 activa Tarea diferida que reproduce la nota actual . La configuraci\u00f3n del canal PWM se ha de hacer en este contexto por la naturaleza bloqueante de las funciones del API PWM. Para simplificar la labor de desarrollo, se recomienda la utilizaci\u00f3n de al menos cuatro variables globales ( lock , next_note , buzzer_state y buzzer_request ), las dos \u00faltimas de tipo enumerado: ::: {fontsize=footnotesize} #include <linux/spinlock.h> ... static spinlock_t lock ; /* Cerrojo para proteger actualizaci\u00f3n/consulta de variables buzzer_state y buzzer_request */ static struct music_step * next_note = NULL ; /* Puntero a la siguiente nota de la melod\u00eda actual (solo alterado por tarea diferida) */ typedef enum { BUZZER_STOPPED , /* Buzzer no reproduce nada (la melod\u00eda termin\u00f3 o no ha comenzado) */ BUZZER_PAUSED , /* Reproducci\u00f3n pausada por el usuario */ BUZZER_PLAYING /* Buzzer reproduce actualmente la melod\u00eda */ } buzzer_state_t ; static buzzer_state_t buzzer_state = BUZZER_STOPPED ; /* Estado actual de la reproducci\u00f3n */ typedef enum { REQUEST_START , /* Usuario puls\u00f3 SW1 durante estado BUZZER_STOPPED */ REQUEST_RESUME , /* Usuario puls\u00f3 SW1 durante estado BUZZER_PAUSED */ REQUEST_PAUSE , /* Usuario puls\u00f3 SW1 durante estado BUZZER_PLAYING */ REQUEST_CONFIG , /* Usuario est\u00e1 configurando actualmente una nueva melod\u00eda v\u00eda /dev/buzzer */ REQUEST_NONE /* Indicador de petici\u00f3n ya gestionada (a establecer por tarea diferida) */ } buzzer_request_t ; static buzzer_request_t buzzer_request = REQUEST_NONE ; ::: La idea general es que s\u00f3lo la tarea diferida altere el estado de la variable buzzer_state , y los otros 3 flujos de ejecuci\u00f3n solo consulten el valor de esa variable de estado. Para modificar el estado de la reproducci\u00f3n o inhibir cambios en \u00e9ste (p.ej., si se est\u00e1 alterando la melod\u00eda a reproducir), el manejador de interrupci\u00f3n y la funci\u00f3n de escritura sobre /dev/buzzer deber\u00e1n actualizar la variable buzzer_request . La tarea diferida tendr\u00e1 en cuenta la petici\u00f3n recibida y alterar\u00e1 adecuadamente el estado buzzer_state , estableciendo posteriormente la variable buzzer_request a REQUEST_NONE (petici\u00f3n gestionada). Por \u00faltimo, n\u00f3tese que para proteger el acceso concurrente a las variables globales buzzer_state y buzzer_request ha de usarse un spin lock (variable global lock ). Adem\u00e1s, para evitar interbloqueos en el acceso concurrente a estas variables desde contexto de proceso e interrupci\u00f3n se deben usar las primitivas spin_lock_irqsave() y spin_unlock_irqrestore() vistas en clase. Partes opcionales \u00b6 Opcional 1 \u00b6 Modificar el c\u00f3digo del m\u00f3dulo del kernel GPIODInterrupt del kernel de tal forma que haya un cierto retardo (p.ej. 100ms) entre la conmutaci\u00f3n del estado de cada LED tras realizar la pulsaci\u00f3n de SW1. Es decir que los LEDs conmuten uno detr\u00e1s del otro, en lugar de simult\u00e1neamente como lo percibe el usuario. Opcional 2 \u00b6 Implementar un m\u00f3dulo del kernel que al cargarse muestre una secuencia continua y prefijada de colores (a escoger por el estudiante) usando el LED RGB D4 de la placa Bee. Este LED est\u00e1 situado justo debajo del display 7 segmentos. Para controlar el LED han de usarse sus tres pines de entrada (R, G y B) --situados a la izquierda--, que es preciso conectar a tres GPIOs libres de la Raspberry Pi mediante cables dupont . Por ejemplo, para este prop\u00f3sito pueden usarse los pines B26, B21 y B20, situados en la esquina superior izquierda de la placa. La intensidad de los componentes rojo (R), verde (G) y azul (B) del color del LED D4 se controlan mediante 3 se\u00f1ales PWM, que pueden generarse por software ( bit banging ) y/o por hardware (usando los canales PWM0 y/o PWM1). Existen distintas alternativas de implementaci\u00f3n para esta parte opcional (p.ej., emplear un kernel thread para alterar los colores a lo largo del tiempo, o usar de forma combinada temporizadores del kernel y tareas diferidas). Queda a elecci\u00f3n del estudiante c\u00f3mo llevar a cabo la implementaci\u00f3n, as\u00ed como el tipo de secuencia de colores utilizada. Opcional 3 \u00b6 Extender la funcionalidad del m\u00f3dulo desarrollado en la parte B de la pr\u00e1ctica para integrar de forma creativa el uso de otros dispositivos de la placa Bee en combinaci\u00f3n con los ya usados en ese m\u00f3dulo del kernel ( buzzer , LEDS D1-D3 y pulsador SW1). Aunque se deja a elecci\u00f3n del estudiante los dispositivos extra a utilizar, y su integraci\u00f3n con el reproductor de melod\u00edas, a continuaci\u00f3n se proporcionan algunas sugerencias: Uso de los pulsadores SW3 y SW2 para, respectivamente, ralentizar o acelerar el tempo de reproducci\u00f3n de la melod\u00eda tras su pulsaci\u00f3n. Es decir, se propone el uso de estos pulsadores para ajustar el valor del par\u00e1metro beat usando controles hardware. Uso del LED D4 para mostrar un color particular al mismo tiempo que se reproduce cada nota espec\u00edfica de la melod\u00eda. Marcar el comp\u00e1s de la melod\u00eda que se est\u00e9 reproduciendo, mediante el parpadeo de alg\u00fan LED (D1-D4)","title":"Drivers en Linux. Gesti\u00f3n de interrupciones, temporizadores, y trabajos diferidos"},{"location":"linux-kernel/interrupt-timers-pwm/#drivers-en-linux-gestion-de-interrupciones-temporizadores-y-trabajos-diferidos","text":"","title":"Drivers en Linux. Gesti\u00f3n de interrupciones, temporizadores, y trabajos diferidos"},{"location":"linux-kernel/interrupt-timers-pwm/#objetivos","text":"El principal objetivo de esta pr\u00e1ctica es familiarizarse con la gesti\u00f3n de interrupciones en el kernel Linux, los temporizadores del kernel, y la creaci\u00f3n y planificaci\u00f3n de tareas diferidas mediante workqueues . Como objetivo secundario, se estudiar\u00e1n los fundamentos sobre generaci\u00f3n de se\u00f1ales PWM por hardware en Linux. El c\u00f3digo para esta pr\u00e1ctica puede descargarse aqu\u00ed . Antes de comenzar con los ejercicios de esta pr\u00e1ctica es preciso consultar la introducci\u00f3n al uso de PWM por hardware en Linux, que se encuentra en la siguiente secci\u00f3n. Teor\u00eda de la pr\u00e1ctica La teor\u00eda asociada a esta pr\u00e1ctica se imparte en la asignatura \"Arquitectura Interna de Linux y Android\", ofertada en las distintas titulaciones de grado en la Facultad de Inform\u00e1tica de la Universidad Complutense de Madrid. Para m\u00e1s informaci\u00f3n sobre la asignatura consultad a Juan Carlos S\u00e1ez Alcaide . Para documentarse sobre la tem\u00e1tica de forma aut\u00f3noma se proporcionan las siguientes referencias: Peter Jay Salzman, Michael Burian, Ori Pomerantz, Bob Mottram, Jim Huang. Linux Kernel Module Programming Guide . 2025. Disponible online . Versi\u00f3n en PDF Kaiwan N. Billimoria. Linux Kernel Programming . Packt Publishing. 1st edition. 2021 Kaiwan N. Billimoria. Linux Kernel Programming. Part 2 - Char Device Drivers and Kernel Synchronization . Packt Publishing. 1st edition. 2021 Robert Love; Linux Kernel Development . Addison Wesley, 3rd Edition. Julio 2010","title":"Objetivos"},{"location":"linux-kernel/interrupt-timers-pwm/#pwm-por-hardware-en-linux","text":"Una se\u00f1al PWM ( Pulse Width Modulation ) es una se\u00f1al digital caracterizada por dos par\u00e1metros: el periodo ( period ) y el ciclo de trabajo ( duty cycle ), que pueden ajustarse a lo largo del tiempo. Como se muestra en la siguiente figura, el periodo es el intervalo de tiempo transcurrido entre dos flancos consecutivos de subida (o de bajada), y el duty cycle es la fracci\u00f3n de tiempo dentro de un periodo en la que la se\u00f1al est\u00e1 a \"1\" . Este tipo de se\u00f1ales tienen un amplio espectro de aplicaciones, como el control de servomotores y ventiladores, o el ajuste de intensidad de los distintos componentes de color de LEDs RGB. Las se\u00f1ales PWM se pueden generar por software en dispositivos equipados con pines GPIO, mediante bit banging , es decir ajustando manualmente la se\u00f1al de salida de un pin a lo largo del tiempo. Por ejemplo, en el m\u00f3dulo Misc7seg que se distribuye con el material de la Pr\u00e1ctica 3 de la asignatura, las se\u00f1ales que gobiernan el display 7 segmentos de la placa --que no son PWM-- se controlan mediante bit banging . Generar se\u00f1ales PWM mediante bit banging tiene asociado un alto consumo de CPU; un flujo de ejecuci\u00f3n debe dedicarse a generar cada se\u00f1al a grano fino y controlar de forma precisa el tiempo entre flancos. Adem\u00e1s, esta t\u00e9cnica no resulta adecuada para sistemas que no tienen garant\u00edas de tiempo real, como la versi\u00f3n vanilla del kernel Linux. En este tipo de sistemas nada impide que el c\u00f3digo generador de la se\u00f1al PWM que se ejecuta en una CPU o n\u00facleo espec\u00edfico de la m\u00e1quina (incluso siendo parte del sistema operativo) pueda ser interrumpido por c\u00f3digo m\u00e1s prioritario (p.ej., manejador de una interrupci\u00f3n no enmascarable); en tal caso no es posible garantizar suficiente precisi\u00f3n para imponer un periodo o un duty cycle espec\u00edfico, lo cual puede desencadenar un mal funcionamiento del sistema gobernado por la se\u00f1al PWM. Para solventar este problema existen dispositivos hardware espec\u00edficos dedicados a la generaci\u00f3n de se\u00f1ales PWM, que no requieren la intervenci\u00f3n continuada de la CPU. El estudio de la API de Linux para el uso de estos dispositivos es el foco principal de esta introducci\u00f3n. En Linux hay dos agentes involucrados en el uso del hardware PWM: los drivers PWM y los usuarios PMW (tambi\u00e9n llamados PWM consumers ). Los drivers PWM implementan el soporte necesario en Linux para interactuar directamente con el hardware PWM. Para la implementaci\u00f3n de estos drivers se emplean las funciones pwmchip_add() y pwmchip_remove() , que registran y desregistran respectivamente una estructura struct pwm_chip . Esta estructura --adecuadamente inicializada por el driver-- describe al kernel las caracteristicas del chip PWM espec\u00edfico (incluyendo el n\u00famero de canales PWM que soporta), y proporciona una implementaci\u00f3n espec\u00edfica del driver para interactuar con el chip PWM en cuesti\u00f3n. Los usuarios o consumers PWM hacen uso de una interfaz de programaci\u00f3n de Linux que garantiza portabilidad, abstrayendo los detalles de bajo nivel asociados a la configuraci\u00f3n de un chip PWM espec\u00edfico. Numerosos drivers en Linux actuan como consumers de PWM. A continuaci\u00f3n se describe la interfaz de programaci\u00f3n usada por los consumers PWM, que ser\u00e1 necesario utilizar en la pr\u00e1ctica.","title":"PWM por hardware en Linux"},{"location":"linux-kernel/interrupt-timers-pwm/#ejercicios","text":"","title":"Ejercicios"},{"location":"linux-kernel/interrupt-timers-pwm/#ejercicio-1","text":"Estudiar la implementaci\u00f3n del m\u00f3dulo de ejemplo GPIODInterrupt analizado en clase. Este m\u00f3dulo del kernel instala un manejador de interrupci\u00f3n que se ejecuta tras pulsar el bot\u00f3n SW1 de la placa Bee. Cuando se pulsa SW1, se genera una interrupci\u00f3n (controlada por flanco de subida). En respuesta a esta interrupci\u00f3n, el m\u00f3dulo del kernel conmuta el estado de los LEDs D1-D3 de la placa (ON/OFF).","title":"Ejercicio 1"},{"location":"linux-kernel/interrupt-timers-pwm/#ejercicio-2","text":"Estudiar la implementaci\u00f3n de los m\u00f3dulos de ejemplo workqueue1.c , workqueue2.c y workqueue3.c (en directorio Workqueues ), que ilustran el proceso de creaci\u00f3n de tareas diferidas mediante el mecanismo de workqueues . Conteste a las siguientes preguntas: \u00bfQu\u00e9 diferencias existen entre el m\u00f3dulo del kernel workqueue1.c y workqueue1.c en lo que respecta a la workqueue empleada para diferir trabajo? \u00bfSe insertan las tareas diferidas en la misma cola? \u00bfCu\u00e1l es el prop\u00f3sito de la estructura espec\u00edfica ( my_work_t ) definida en el ejemplo worqueue3.c ?","title":"Ejercicio 2"},{"location":"linux-kernel/interrupt-timers-pwm/#ejercicio-3","text":"Analizar el m\u00f3dulo ExampleTimer que gestiona un temporizador del kernel que se activa cada segundo e imprime un mensaje con printk() . Al igual que se hizo con el ejemplo de kernel thread de la pr\u00e1ctica anterior, se recomienda usar el comando : sudo dmesg -w , para poder observar la impresi\u00f3n peri\u00f3dica del mensaje del temporizador el fichero de log del kernel. kernel@debian:~$ sudo dmesg -w [ sudo ] password for kernel: ... Dec 4 14 :15:22 debian kernel: [ 233644 .504010 ] Tic Dec 4 14 :15:23 debian kernel: [ 233645 .524021 ] Tac Dec 4 14 :15:24 debian kernel: [ 233646 .544028 ] Tic Dec 4 14 :15:25 debian kernel: [ 233647 .564029 ] Tac Dec 4 14 :15:26 debian kernel: [ 233648 .584021 ] Tic Dec 4 14 :15:27 debian kernel: [ 233649 .604031 ] Tac ... Los temporizadores del kernel son one shot por defecto; es decir, una vez que se ejecuta la funci\u00f3n asociada, el temporizador no se reconfigura autom\u00e1ticamente para invocar de nuevo la funci\u00f3n en el futuro. Sin embargo, en el m\u00f3dulo del kernel de ejemplo, la funci\u00f3n del temporizador se invoca una vez por segundo hasta que el m\u00f3dulo se descarga del kernel. \u00bfC\u00f3mo se consigue que el m\u00f3dulo del kernel tenga este comportamiento?","title":"Ejercicio 3"},{"location":"linux-kernel/interrupt-timers-pwm/#ejercicio-4","text":"Una de las aplicaciones del uso de PWM por hardware es la generaci\u00f3n de una se\u00f1al digital con frecuencia espec\u00edfica (y potencialmente variable) para reproducir notas musicales utilizando un zumbador o buzzer pasivo, como el que integra la placa Bee v2.0. La Raspberry Pi (modelos 3B+ o 4) integra dos canales PWM (0 y 1), que est\u00e1n asociados a los GPIOs 12 y 13 respectivamente seg\u00fan la configuraci\u00f3n actual del kernel (v\u00e9ase el fichero /boot/config.txt ). Con las conexiones fijadas actualmente en la placa, la se\u00f1al de entrada del buzzer est\u00e1 conectada directamente al GPIO 12 (canal PWM0). Este ejercicio consiste en estudiar el m\u00f3dulo del kernel de ejemplo test-buzzer.c , que al cargarse reproduce mediante el buzzer una melod\u00eda fija (hardcodeada en las fuentes) usando una se\u00f1al PWM desde una tarea diferida ( workqueue ). Nota importante: Cabe destacar que las funciones analizadas en la secci\u00f3n anterior que aceptan un par\u00e1metro de tipo struct pwm_device son bloqueantes, por lo que solo pueden invocarse desde contexto de proceso. \u00c9ste el tipo de contexto en el que se ejecutan las tareas diferidas mediante workqueues . Para la realizaci\u00f3n de la pr\u00e1ctica es preciso reusar el c\u00f3digo de este m\u00f3dulo de ejemplo. Por ello, se proporciona a continuaci\u00f3n una breve descripci\u00f3n de las estructuras, definiciones y funciones auxiliares m\u00e1s importantes del m\u00f3dulo. Para representar cada nota o silencio que forma parte de la melod\u00eda se emplea la siguiente estructura de 32 bits: struct music_step { unsigned int freq : 24 ; /* Frequency in centihertz */ unsigned int len : 8 ; /* Duration of the note */ }; El campo freq (24 bits) codifica la frecuencia de la nota en centihercios (el valor 0 se usa para representar los silencios). El campo len (de 8 bits) almacena la duraci\u00f3n de la nota o silencio. Esta duraci\u00f3n se representa mediante una m\u00e1scara de bits, donde los siete primeros bits se asocian a la presencia de alguna de las siguientes figuras b\u00e1sicas en la especificaci\u00f3n de la duraci\u00f3n de la nota: Bit 0: Redonda (1)^[Los valores entre par\u00e9ntesis denotan el n\u00famero de figuras del tipo en cuesti\u00f3n que equivalen a la duraci\u00f3n de una redonda, la figura de referencia habitual en m\u00fasica.] Bit 1: Blanca (2) Bit 2: Negra (4) Bit 3: Corchea (8) Bit 4: Semicorchea (16) Bit 5: Fusa (32) Bit 6: Semifusa (64) El bit 7 del campo len se emplea para indicar si la figura en cuesti\u00f3n se encuentra dentro de un tresillo : figura musical irregular que agrupa 3 figuras musicales en el tiempo de 2 equivalentes regulares. Esta representaci\u00f3n de la duraci\u00f3n con 8 bits hace posible cubrir un amplio espectro de duraciones de notas presentes en melod\u00edas de la m\u00fasica popular. As\u00ed por ejemplo: Para representar la duraci\u00f3n de una negra el campo len tendr\u00e1 el valor 4 (bit 2 activo, \u00fanicamente) Para representar una corchea en nuestra \"partitura\" usaremos len=8 (bit 2 activo \u00fanicamente). Si esta corchea formara parte de un tresillo, se habilitar\u00eda tambi\u00e9n el bit 7 ( len=0x88 ). Para las figuras con puntillo, que representan 1.5 veces la duraci\u00f3n de la figura original a la que se aplica el puntillo, es preciso activar dos bits en el campo len . En particular, si queremos representar una negra con puntillo, es necesario reflejar la duraci\u00f3n de una negra m\u00e1s la mitad de \u00e9sta (corchea), para lo cual se han de activar los bits 2 y 3 en el campo len ( len=0x0C ). La melod\u00eda que el m\u00f3dulo del kernel reproduce se encuentra definida como variable local melodic_line de la funci\u00f3n my_wq_function() que representa el trabajo diferido: /* Frequency of selected notes in centihertz */ #define C4 26163 #define D4 29366 #define E4 32963 #define F4 34923 #define G4 39200 #define C5 52325 ... static void my_wq_function ( struct work_struct * work ) { struct music_step melodic_line [] = { { C4 , 4 }, { E4 , 4 }, { G4 , 4 }, { C5 , 4 }, { 0 , 2 }, { C5 , 4 }, { G4 , 4 }, { E4 , 4 }, { C4 , 4 }, { 0 , 0 } /* Terminator */ }; const int beat = 120 ; /* 120 quarter notes per minute */ struct music_step * next = melodic_line ; /* Play notes sequentially until end marker is found */ for ( next = melodic_line ; ! is_end_marker ( next ); next ++ ) { ... Code to play the current note ... } } La melod\u00eda (array) se define mediante un inicializador est\u00e1tico de \"C\". Dicho array consta de una entrada por cada nota o silencio de la melod\u00eda, con un music_step terminador al final. Por simplicidad en la representaci\u00f3n de la melod\u00eda se hace referencia a las notas de la misma mediante una macro que asocia la representaci\u00f3n en ingl\u00e9s de la nota (por ejemplo, E4 es la nota mi con altura 4) con su frecuencia en centihercios correspondiente a la afinaci\u00f3n temperada est\u00e1ndar. Para consultar la frecuencia de otras notas musicales se puede visitar esta p\u00e1gina . La tarea diferida recorre secuencialmente la cada paso ( music_step ) de la melod\u00eda. Si el paso actual es un silencio (frecuencia igual 0) se desactiva la se\u00f1al PWM, y si es una nota (frecuencia distinta de 0) se establece adecuadamente el periodo de la se\u00f1al PWM con el valor inverso de la frecuencia de la nota. A continuaci\u00f3n se ejecuta la funci\u00f3n msleep() para que el kernel thread que ejecuta esta tarea diferida se bloquee durante el tiempo asociado a la nota o silencio actual de la melod\u00eda. Para el c\u00e1lculo del tiempo es preciso que haya una referencia de la duraci\u00f3n de cada figura musical (blanca, negra, etc.). Por simplicidad, la variable local beat almacena el n\u00famero de negras por minuto a modo de indicaci\u00f3n de metr\u00f3nomo, que en este caso se fija a 120. La funci\u00f3n calculate_delay_ms() definida en el m\u00f3dulo del kernel calcula la duraci\u00f3n de la nota (retardo especificado en milisegundos) en base a los bits activados en el campo len y considerando el valor actual de beat como referencia (segundo par\u00e1metro de la llamada): /** * Transform note length into ms, * taking the beat of a quarter note as reference */ static inline int calculate_delay_ms ( unsigned int note_len , unsigned int qnote_ref ){ unsigned char duration = ( note_len & 0x7f ); unsigned char triplet = ( note_len & 0x80 ); unsigned char i = 0 ; unsigned char current_duration ; int total = 0 ; /* Calculate the total duration of the note * as the summation of the figures that make * up this note (bits 0-6) */ while ( duration ){ current_duration = ( duration ) & ( 1 << i ); if ( current_duration ){ /* Scale note accordingly */ if ( triplet ) current_duration = ( current_duration * 3 ) / 2 ; /** * 24000/qnote_ref denote number of ms associated * with a whole note (redonda) */ total += ( 240000 ) / ( qnote_ref * current_duration ); /* Clear bit */ duration &=~ ( 1 << i ); } i ++ ; } return total ; } Tras analizar el c\u00f3digo del m\u00f3dulo, trata de responder a las siguientes preguntas: \u00bfPor qu\u00e9 la melod\u00eda se reproduce una sola vez al cargar el m\u00f3dulo del kernel? \u00bfQu\u00e9 cambio deber\u00eda realizarse en la implementaci\u00f3n para que la melod\u00eda se reprodujera m\u00e1s r\u00e1pido (por ejemplo al doble de velocidad)? \u00bfQu\u00e9 sucede si intentamos descargar el m\u00f3dulo mientras la melod\u00eda est\u00e1 a\u00fan reproduci\u00e9ndose? \u00bfC\u00f3mo se consigue este comportamiento?","title":"Ejercicio 4"},{"location":"linux-kernel/interrupt-timers-pwm/#desarrollo-de-la-practica","text":"Esta pr\u00e1ctica consta de dos partes. En la primera parte se ejercitar\u00e1 el uso de manejadores de interrupci\u00f3n y temporizadores del kernel. En la segunda parte, se emplear\u00e1n estas dos abstracciones del kernel en combinaci\u00f3n con las workqueues y la API de PWM.","title":"Desarrollo de la pr\u00e1ctica"},{"location":"linux-kernel/interrupt-timers-pwm/#parte-a","text":"Desarrollar un m\u00f3dulo del kernel SMP-safe llamado timerleds.c que establezca la configuraci\u00f3n de los LEDs de la placa Bee para que se enciendan/apaguen usando una secuencia prefijada, como un contador binario, o el encendido de un LED distinto en cada paso de la secuencia (desplazamiento). La transici\u00f3n entre cada paso de la secuencia debe realizarse autom\u00e1ticamente utilizando un temporizador del kernel, que actualice peri\u00f3dicamente el estado de los LEDs. El periodo del temporizador (dado en milisegundos) ha de ser configurable mediante un par\u00e1metro timer_period_ms a establecer durante la carga del m\u00f3dulo. Adem\u00e1s, el m\u00f3dulo del kernel debe permitir al usuario pausar y reanudar la actividad del temporizador del kernel mediante el uso del pulsador SW1 de la placa. Implementar esta funcionalidad conlleva instalar un manejador de interrupci\u00f3n asociado al GPIO del pulsador SW1. Nota importante: t\u00e9ngase en cuenta que la funci\u00f3n del_timer_sync() para desactivar un temporizador del kernel activo es bloqueante, por lo que NO puede ejecutarse en contexto de interrupci\u00f3n. Por simplicidad en el desarrollo de este apartado se aconseja reutilizar c\u00f3digo de los siguientes ejemplos: TimerExample : Ejercicio 3 de esta pr\u00e1ctica GPIODInterrupt : C\u00f3digo analizado en clase (Ejercicio 1) , donde se hace uso combinado de los LEDs y el pulsador Hello5 : M\u00f3dulo de ejemplo de la Pr\u00e1ctica 1, donde se ilustra el uso de par\u00e1metros de los m\u00f3dulos del kernel.","title":"Parte A"},{"location":"linux-kernel/interrupt-timers-pwm/#parte-b","text":"Desarrollar un driver SMP-safe en Linux ( buzzer.c ) que permita reproducir melod\u00edas proporcionadas por el usuario empleando el buzzer presente en la placa Bee v2.0. El driver exportar\u00e1 un fichero especial de caracteres /dev/buzzer que permitir\u00e1 configurar tanto la melod\u00eda a reproducir, como la velocidad de reproducci\u00f3n de \u00e9sta. Adem\u00e1s, el usuario podr\u00e1 iniciar la reproducci\u00f3n de la melod\u00eda, detenerla o reanudarla presionando el pulsador SW1 de la placa Bee. El usuario especificar\u00e1 al m\u00f3dulo del kernel la melod\u00eda a reproducir escribiendola en el fichero /dev/buzzer . La melod\u00eda se representa mediante una cadena de caracteres, que comienza por el prefijo \"music \" seguido de una lista de notas musicales o silencios con una duraci\u00f3n determinada. Cada nota en la melodia se denota mediante un par \"frecuencia:duraci\u00f3n\", donde ambos componentes del par tendr\u00e1n la misma sem\u00e1ntica que en el m\u00f3dulo del kernel TestBuzzer del Ejercicio 4 (estructura music_step ). Dos notas consecutivas de una l\u00ednea mel\u00f3dica se separar\u00e1n mediante una coma. Para ilustrar esta representaci\u00f3n de las melod\u00edas, consid\u00e9rese el siguiente comando, que permite configurar la misma melod\u00eda que se encuentra hardcodeada en el ejemplo TestBuzzer : $ echo music 26163 :0x4,32963:0x4,39200:0x4,52325:0x4,0:0x2,52325:0x4,39200:0x4,32963:0x4,26163:0x4 > /dev/buzzer El driver tambi\u00e9n permitir\u00e1 la configuraci\u00f3n del ritmo de reproducci\u00f3n de la melod\u00eda escribiendo en /dev/buzzer el valor de un par\u00e1metro beat que indique cu\u00e1ntas negras por minuto han de reproducirse (como la variable beat del ejemplo TestBuzzer ). Para modificar o consultar el valor actual de este par\u00e1metro se deber\u00e1 escribir o leer del fichero especial de caracteres del siguiente modo: ## Establecer valor de beat a 150 $ echo beat 150 > /dev/buzzer ## Consultar el valor actual de beat $ cat /dev/buzzer beat = 150 ... Para simplificar el desarrollo de la pr\u00e1ctica y la configuraci\u00f3n de melod\u00edas se proporcionan algunos ficheros en el directorio Util de los ejemplos de esta pr\u00e1ctica. En particular, en este directorio se encuentra la utilidad music_converter.py , y una serie de melod\u00edas en un formato de mayor nivel de abstracci\u00f3n (ficheros \".music\") que el que el driver usa como entrada. Se deja como ejercicio analizar ese formato de alto nivel y tratar de escribir nuevas melod\u00edas usando este sencillo formato. La utilidad music_converter.py permite convertir las melod\u00edas \".music\" al formato de entrada del driver usando como argumentos un fichero donde se encuentra la tabla de frecuencias que corresponde a cada nota musical, y el fichero de extensi\u00f3n \".music\" a convertir. El modo de uso del programa es el siguiente: music_converter.py freq_table.csv <fichero.music> Como la utilidad imprime el resultado de la conversi\u00f3n por la salida est\u00e1ndar, es preciso usar una sentencia de redirecci\u00f3n para escribir la configuraci\u00f3n en /dev/buzzer , como en el siguiente ejemplo: pi@raspberrypi:~/P5/Util$ ./music_converter.py freq_table.csv ode_to_joy.music > /dev/buzzer Por simplicidad se recomienda almacenar la melod\u00eda en una variable global melody : un array de estructuras music_step , cuya memoria ha de reservarse con vmalloc(PAGE_SIZE) en la funci\u00f3n de inicializaci\u00f3n del m\u00f3dulo del kernel. Para concluir la descripci\u00f3n de la pr\u00e1ctica se proporcionan a continuaci\u00f3n detalles adicionales de su funcionamiento, as\u00ed como restricciones de implementaci\u00f3n.","title":"Parte B"},{"location":"linux-kernel/interrupt-timers-pwm/#partes-opcionales","text":"","title":"Partes opcionales"},{"location":"linux-kernel/sincronizacion/","text":"Drivers en Linux. Sincronizaci\u00f3n en el kernel \u00b6 Objetivos \u00b6 El objetivo de esta pr\u00e1ctica es familiarizarse con las siguientes abstracciones de Linux: Spinlocks Sem\u00e1foros Wait queues Kernel threads Buffers circulares del kernel ( struct kfifo ) El c\u00f3digo para esta pr\u00e1ctica puede descargarse aqu\u00ed . Teor\u00eda de la pr\u00e1ctica La teor\u00eda asociada a esta pr\u00e1ctica se imparte en la asignatura \"Arquitectura Interna de Linux y Android\", ofertada en las distintas titulaciones de grado en la Facultad de Inform\u00e1tica de la Universidad Complutense de Madrid. Para m\u00e1s informaci\u00f3n sobre la asignatura consultad a Juan Carlos S\u00e1ez Alcaide . Para documentarse sobre la tem\u00e1tica de forma aut\u00f3noma se proporcionan las siguientes referencias: Peter Jay Salzman, Michael Burian, Ori Pomerantz, Bob Mottram, Jim Huang. Linux Kernel Module Programming Guide . 2025. Disponible online . Versi\u00f3n en PDF Kaiwan N. Billimoria. Linux Kernel Programming . Packt Publishing. 1st edition. 2021 Kaiwan N. Billimoria. Linux Kernel Programming. Part 2 - Char Device Drivers and Kernel Synchronization . Packt Publishing. 1st edition. 2021 Robert Love; Linux Kernel Development . Addison Wesley, 3rd Edition. Julio 2010 Ejercicios \u00b6 Ejercicio 1 \u00b6 El m\u00f3dulo de ejemplo refmod.c ilustra la importancia del contador de referencia asociado a un m\u00f3dulo del kernel. Este m\u00f3dulo, al cargarse, expone al usuario un fichero especial de caracteres /dev/refmod . Al leer de dicho fichero especial con cat , el proceso lector se bloquea durante unos segundos, y a continuaci\u00f3n retorna devolviendo 0 bytes en la operaci\u00f3n de lectura. El periodo de bloqueo durante la lectura --especificado en milisegundos-- es configurable, gracias al par\u00e1metro stime_ms que exporta el m\u00f3dulo, y que puede establecerse en tiempo de carga en el kernel. Consultar la implementaci\u00f3n de la operaci\u00f3n de lectura del fichero especial de caracteres (funci\u00f3n refmod_read() del m\u00f3dulo). Como puede observarse, el bloqueo se lleva a cabo llamando a la funci\u00f3n msleep() vista en clase. Responder de forma razonada a las siguientes preguntas: \u00bfCu\u00e1nto dura el periodo de bloqueo si el m\u00f3dulo del kernel se carga sin establecer el valor del par\u00e1metro configurable stime_ms ? Ejecutar el comando cat /proc/refmod en un terminal. \u00bfQu\u00e9 sucede al intentar interrumpir la ejecuci\u00f3n de cat con CTRL + C ? \u00bfTermina la ejecuci\u00f3n de cat si se env\u00eda una se\u00f1al SIGTERM o SIGKILL con kill a este proceso (usar otra terminal para ello, e incrementar el periodo de bloqueo para tener m\u00e1s tiempo para comprobarlo)? \u00bfEn qu\u00e9 estado se bloquea un proceso cuando la llamada al sistema invocada hace uso de msleep() ? \u00bfCu\u00e1l es el valor del contador de referencia del m\u00f3dulo del kernel mientras NO se est\u00e9 accediendo al fichero de dispositivo? Usar el comando lsmod para consultar el valor de este contador. \u00bfSigue siendo el valor del contador de referencias el mismo mientras ejecutamos cat /proc/refmod en otra terminal (y antes de que ese comando termine)? \u00bfEs posible descargar satisfactoriamente el m\u00f3dulo del kernel mientras \u00e9ste est\u00e1 en uso? Para comprobarlo pueden abrirse 2 terminales, usando el primero de ellos para ejecutar cat /proc/refmod , y el segundo para descargar el m\u00f3dulo ( sudo rmmod refmod ). En caso de que el comando de descarga funcione, comprobar si la ejecuci\u00f3n del comando cat /proc/refmod termina correctamente, y si se muestran o no mensajes de error en el fichero de log del kernel a ra\u00edz de haber tratado de descargar el m\u00f3dulo cuando est\u00e1 en uso. \u00bfCu\u00e1l es la causa de este comportamiento? Modificar el c\u00f3digo de refmod.c para que el contador de referencia del m\u00f3dulo del kernel se incremente al hacer open() en el fichero especial de dispositivo, y se decremente al hacer close() del mismo. Recordad que las funciones que permiten incrementar y decrementar el contador de referencia son try_module_get() y module_put() , respectivamente. Para m\u00e1s informaci\u00f3n se aconseja consultar cualquiera de las variantes del m\u00f3dulo chardev proporcionadas en la pr\u00e1ctica anterior, donde se usan estas funciones. Tras llevar a cabo las modificaciones propuestas, comprobar ahora el valor del contador de referencia del m\u00f3dulo del kernel mientras haya un \"cat\" en curso sobre el fichero de dispositivo. \u00bfEs posible descargar ahora el m\u00f3dulo mientras un proceso est\u00e9 leyendo del fichero especial de dispositivo? Ejercicio 2 \u00b6 Probar el funcionamiento del m\u00f3dulo de ejemplo kthread-mod.c , que al cargarse con insmod crea un kernel thread . Este kernel thread pasa casi todo el tiempo bloqueado, y se despierta cada segundo para imprimir un mensaje en el fichero de log del kernel. Para poder percibir esta impresi\u00f3n peri\u00f3dica del mensaje (tras cargar el m\u00f3dulo) se recomienda abrir una ventana de terminal adicional y ejecutar el siguiente comando: sudo dmesg -w . Este comando permite mostrar en tiempo real los mensajes que se van imprimiendo en el fichero de log del kernel: kernel@debian:~$ sudo dmesg -w [ sudo ] password for kernel: ... Dec 4 14 :15:22 debian kernel: [ 233644 .504010 ] Tic Dec 4 14 :15:23 debian kernel: [ 233645 .524021 ] Tac Dec 4 14 :15:24 debian kernel: [ 233646 .544028 ] Tic Dec 4 14 :15:25 debian kernel: [ 233647 .564029 ] Tac Dec 4 14 :15:26 debian kernel: [ 233648 .584021 ] Tic Dec 4 14 :15:27 debian kernel: [ 233649 .604031 ] Tac ... Ejercicio 3 \u00b6 Analizar el c\u00f3digo del m\u00f3dulo de ejemplo Clipboard-update que hace uso de wait queues para dotar de sem\u00e1ntica bloqueante al dispositivo especial de caracteres que el m\u00f3dulo gestiona. Al cargar el m\u00f3dulo Clibpoard-update en el n\u00facleo, se crea autom\u00e1ticamente el fichero de dispositivo /dev/clipboard_update . A pesar de que la lectura y escritura en este fichero especial de caracteres tiene un comportamiento similar a la entrada /dev/clipboard del m\u00f3dulo en el que se basa (consulta y modificaci\u00f3n, respectivamente del \"clipboard\") el fichero especial implementado en este caso tiene sem\u00e1ntica bloqueante. Todo proceso que lee de la entrada /dev/clipboard_update se queda bloqueado en la operacion clipboard_read() hasta que se produce una actualizaci\u00f3n (escritura) del contenido del \"clipboard\". El proceso escritor, que invoca clipboard_write() es el encargado de despertar a los procesos lectores tras realizar una operaci\u00f3n de actualizaci\u00f3n. Para probar la funcionalidad de este ejemplo se han de abrir tantas ventanas de terminal como procesos acceden al \"clipboard\". A continuaci\u00f3n se muestra un ejemplo con cuatro terminales. Para observar los bloqueos se aconseja hacer primero tres lecturas con cat y a continuaci\u00f3n la escritura con echo : Terminal 1 pi@raspberrypi:~ $ cat /dev/clipboard_update new clipboard Terminal 2 pi@raspberrypi:~ $ cat /dev/clipboard_update new clipboard Terminal 3 pi@raspberrypi:~ $ cat /dev/clipboard_update new clipboard Terminal 4 pi@raspberrypi:~ $ echo \"new clipboard\" > /dev/clipboard_update Tras estudiar el c\u00f3digo fuente, se ha de proporcionar una respuesta a las siguientes preguntas: \u00bfQu\u00e9 sucede si, mientras un proceso est\u00e1 bloqueado en clipboard_read() , tecleamos CTRL + C en la misma terminal (enviando la se\u00f1al SIGINT al proceso que ejecuta cat )? \u00bfPodr\u00eda conseguirse el mismo comportamiento si se hubiera usado wait_event() en lugar de wait_event_interruptible() en la implementaci\u00f3n? Justifica la respuesta. \u00bfGarantiza la implementaci\u00f3n exclusi\u00f3n mutua en el acceso a la variable clipboard? En caso de que no sea as\u00ed prop\u00f3n una soluci\u00f3n que garantice que la implementaci\u00f3n sea SMP-safe . Desarrollo de la pr\u00e1ctica \u00b6 Esta pr\u00e1ctica consta de dos partes: A y B Parte A \u00b6 Implementar el m\u00f3dulo ProdCons descrito en clase, que gestiona un buffer circular acotado de enteros, y permite a los procesos de usuario insertar y eliminar n\u00fameros en ese buffer realizando escrituras y lecturas en un fichero especial de caracteres ( /dev/prodcons ). Estas operaciones de lectura (eliminaci\u00f3n) y escritura (inserci\u00f3n) han de tener sem\u00e1ntica productor consumidor: Para insertar un n\u00famero (por ejemplo 7) al final del buffer se debe ejecutar el siguiente comando: $ echo 7 > /dev/prodcons Si el buffer circular est\u00e1 lleno, esta operaci\u00f3n debe bloquear al proceso, hasta que haya de nuevo hueco para realizar la operaci\u00f3n. Para extraer el primer elemento del buffer debe realizarse una lectura del fichero especial de caracteres: $ cat /dev/prodcons Esta operaci\u00f3n bloquear\u00e1 al proceso lector hasta que haya elementos que consumir del buffer. En dicho instante se deber\u00eda mostrar el valor extra\u00eddo del buffer por pantalla (esto requiere rellenar adecuadamente el buffer pasado como par\u00e1metro a la operaci\u00f3n read() del driver). Ejemplo de ejecuci\u00f3n (se asume que buffer puede alojar como mucho 4 enteros) kernel@debian:~/ProdCons$ echo 4 > /dev/prodcons kernel@debian:~/ProdCons$ echo 5 > /dev/prodcons kernel@debian:~/ProdCons$ echo 6 > /dev/prodcons kernel@debian:~/ProdCons$ cat /dev/prodcons 4 kernel@debian:~/ProdCons$ cat /dev/prodcons 5 kernel@debian:~/ProdCons$ cat /dev/prodcons 6 kernel@debian:~/ProdCons$ cat /dev/prodcons <<proceso se queda bloqueado>> Al igual que en el c\u00f3digo a desarrollar en la parte A, se debe garantizar que el m\u00f3dulo NO pueda descargarse si alg\u00fan proceso de usuario est\u00e1 utilizando sus servicios. Recursos para la implementaci\u00f3n \u00b6 Buffer circular \u00b6 El buffer circular de enteros gestionado por el m\u00f3dulo se implementar\u00e1 utilizando la estructura de datos struct kfifo del kernel, que representa un buffer circular de bytes. Para utilizar esta estructura de datos gen\u00e9rica del kernel ha de incluirse el fichero de cabecera <linux/kfifo.h> . Aunque existen varias formas para inicializar la estructura, se recomienda definir una variable global del tipo adecuado: struct kfifo nombre_variable ; y a continuaci\u00f3n inicializar la estructura con kfifo_alloc() . La memoria debe liberarse con kfifo_free() preferentemente en la funci\u00f3n de cleanup del m\u00f3dulo. En la pr\u00e1ctica se reservar\u00e1 espacio para alojar hasta 4 u 8 enteros en el buffer. El tama\u00f1o m\u00e1ximo del buffer circular se podr\u00e1 establecer mediante un par\u00e1metro configurable del m\u00f3dulo, a fijar en tiempo de carga. Como un entero ocupa 4 bytes, las inserciones y eliminaciones de n\u00fameros se realizar\u00e1n mediante las operaciones de inserci\u00f3n y eliminaci\u00f3n m\u00faltiple de esta estructura de datos: kfifo_in() y kfifo_out() . Ejemplo inserci\u00f3n y eliminaci\u00f3n (extraci\u00f3n) de entero en struct kfifo #include <linux/kfifo.h> void insertar_entero ( struct kfifo * cbuf , int n ){ kfifo_in ( cbuf , & n , sizeof ( int )); } int extraer_entero ( struct kfifo * cbuf , int n ){ int n ; kfifo_out ( cbuf , & n , sizeof ( int )); return n ; } Breve descripci\u00f3n de operaciones de struct kfifo ( pk denota un par\u00e1metro puntero a struct kfifo ) Funci\u00f3n/Macro Descripci\u00f3n kfifo_alloc(pk,size,mask) Inicializa kfifo y reserva memoria para almacenamiento interno. size ha de ser potencia de 2. mask es el par\u00e1metro que se pasa a la llamada subyacente a kmalloc() (opciones de reserva de memoria). Pasar GFP_KERNEL como tercer par\u00e1metro. kfifo_free(pk) Libera memoria asociada al kfifo kfifo_len(pk) Devuelve n\u00famero de elementos en kfifo kfifo_avail(pk) Devuelve n\u00famero de huecos libres en kfifo kfifo_size(pk) Devuelve capacidad m\u00e1xima de kfifo kfifo_is_full(pk) Devuelve !=0 si kfifo lleno, y 0 en caso contrario kfifo_is_empty(pk) Devuelve !=0 si kfifo vac\u00edo, y 0 en caso contrario kfifo_in(pk,from,n) Inserta n elementos (bytes) en kfifo. Los bytes se leen del buffer pasado como par\u00e1metro ( void* from ) kfifo_out(pk,to,n) Elimina n elementos (bytes) del kfifo. Los bytes eliminados se copian en el buffer pasado como par\u00e1metro ( void* to ) kfifo_reset(pk) Elimina todos los elementos de kfifo (vac\u00eda buffer) sin liberar la memoria. Para m\u00e1s informaci\u00f3n: Consultar la documentaci\u00f3n del kernel sobre esta estructura de datos Consultar c\u00f3digo fuente del kernel ( <linux/kfifo.h> ) Cap\u00edtulo 6 \"Kernel Data Structures\" de Linux Kernel Development Sem\u00e1foros \u00b6 Para implementar las operaciones de bloqueo en esta pr\u00e1ctica se emplear\u00e1n tres sem\u00e1foros del kernel: mtx : debe inicializarse a 1, y se usar\u00e1 a modo de mutex para garantizar exclusi\u00f3n mutua en el acceso al buffer circular. huecos : debe inicializarse a 0. Se utilizar\u00e1 para bloquear al productor (proceso que escribe en /dev/prodcons ) cuando no haya hueco para insertar nuevos elementos en el buffer circular. elementos : debe inicializarse a la capacidad m\u00e1xima del buffer (en elementos, no bytes) establecida por el usuario (4 u 8). Se utilizar\u00e1 para bloquear al consumidor (proceso que lee de /dev/prodcons ) cuando no haya elementos que consumir en el buffer circular. Parte B \u00b6 Crear una variante SMP-safe y thread-safe del driver desarrollado en la pr\u00e1ctica anterior ParteB -- driver que gestiona el display 7 segmentos de la placa Bee v2.0. Para ello se crear\u00e1 una variante de dicho driver que asegure lo siguiente: El driver no debe poder descargarse si alg\u00fan proceso de usuario est\u00e1 utilizando sus servicios. La implementaci\u00f3n debe garantizar que solo un proceso debe poder estar accediendo al fichero de dispositivo /dev/display7s en un instante determinado. Para ello, debe mantenerse un contador que lleve la cuenta del n\u00famero de procesos que est\u00e1n accediendo al dispositivo (a incrementar en open() , y decrementar en release() ). Si un proceso intenta abrir el dispositivo cuando est\u00e1 ya en uso, la operaci\u00f3n open() devolver\u00e1 un error ( -EBUSY ). El contador del n\u00famero de procesos que est\u00e1n usando el fichero especial de dispositivo (valor 0 o 1) debe actualizarse de forma segura usando un recurso de sincronizaci\u00f3n del kernel. El estudiante puede escoger el tipo de recurso que considere oportuno para permitir la actualizaci\u00f3n segura del contador. La implementaci\u00f3n de la operaci\u00f3n write() sobre el fichero especial de dispositivo debe ser thread-safe ; es decir, en caso de que varios hilos de un mismo proceso (con el descriptor compartido) quisieran hacer escrituras simult\u00e1neas sobre el fichero especial de dispositivo, debe serializarse la invocaci\u00f3n de la funci\u00f3n display7s_write() , que es la que realiza la modificaci\u00f3n del estado del display 7 segmentos. Se deja a elecci\u00f3n del estudiante el mecanismo o mecanismos de sincronizaci\u00f3n a utilizar para imponer esta restricci\u00f3n (que solo un hilo pueda ejecutar display7s_write() ). Nota importante : Se ha de tener en cuenta que la funci\u00f3n msleep() , que se invoca desde display7s_write() , es bloqueante. Parte opcional de la pr\u00e1ctica \u00b6 Crear una variante del ejemplo Clipboard-update donde se utilicen sem\u00e1foros del kernel en lugar de wait queues para dotar de sem\u00e1ntica bloqueante a la operaci\u00f3n de lectura en /dev/clipboard_update . Pista : Se aconseja la utilizaci\u00f3n de dos sem\u00e1foros, uno de ellos a utilizar como cerrojo (contador inicializado a 1), y el otro como cola de espera (contador inicializado a 0) para bloquear a los procesos que lean de /dev/clipboard_update . Asimismo debe mantenerse un contador global para llevar la cuenta de los procesos esperando en el segundo sem\u00e1foro.","title":"Drivers en Linux. Sincronizaci\u00f3n en el kernel"},{"location":"linux-kernel/sincronizacion/#drivers-en-linux-sincronizacion-en-el-kernel","text":"","title":"Drivers en Linux. Sincronizaci\u00f3n en el kernel"},{"location":"linux-kernel/sincronizacion/#objetivos","text":"El objetivo de esta pr\u00e1ctica es familiarizarse con las siguientes abstracciones de Linux: Spinlocks Sem\u00e1foros Wait queues Kernel threads Buffers circulares del kernel ( struct kfifo ) El c\u00f3digo para esta pr\u00e1ctica puede descargarse aqu\u00ed . Teor\u00eda de la pr\u00e1ctica La teor\u00eda asociada a esta pr\u00e1ctica se imparte en la asignatura \"Arquitectura Interna de Linux y Android\", ofertada en las distintas titulaciones de grado en la Facultad de Inform\u00e1tica de la Universidad Complutense de Madrid. Para m\u00e1s informaci\u00f3n sobre la asignatura consultad a Juan Carlos S\u00e1ez Alcaide . Para documentarse sobre la tem\u00e1tica de forma aut\u00f3noma se proporcionan las siguientes referencias: Peter Jay Salzman, Michael Burian, Ori Pomerantz, Bob Mottram, Jim Huang. Linux Kernel Module Programming Guide . 2025. Disponible online . Versi\u00f3n en PDF Kaiwan N. Billimoria. Linux Kernel Programming . Packt Publishing. 1st edition. 2021 Kaiwan N. Billimoria. Linux Kernel Programming. Part 2 - Char Device Drivers and Kernel Synchronization . Packt Publishing. 1st edition. 2021 Robert Love; Linux Kernel Development . Addison Wesley, 3rd Edition. Julio 2010","title":"Objetivos"},{"location":"linux-kernel/sincronizacion/#ejercicios","text":"","title":"Ejercicios"},{"location":"linux-kernel/sincronizacion/#ejercicio-1","text":"El m\u00f3dulo de ejemplo refmod.c ilustra la importancia del contador de referencia asociado a un m\u00f3dulo del kernel. Este m\u00f3dulo, al cargarse, expone al usuario un fichero especial de caracteres /dev/refmod . Al leer de dicho fichero especial con cat , el proceso lector se bloquea durante unos segundos, y a continuaci\u00f3n retorna devolviendo 0 bytes en la operaci\u00f3n de lectura. El periodo de bloqueo durante la lectura --especificado en milisegundos-- es configurable, gracias al par\u00e1metro stime_ms que exporta el m\u00f3dulo, y que puede establecerse en tiempo de carga en el kernel. Consultar la implementaci\u00f3n de la operaci\u00f3n de lectura del fichero especial de caracteres (funci\u00f3n refmod_read() del m\u00f3dulo). Como puede observarse, el bloqueo se lleva a cabo llamando a la funci\u00f3n msleep() vista en clase. Responder de forma razonada a las siguientes preguntas: \u00bfCu\u00e1nto dura el periodo de bloqueo si el m\u00f3dulo del kernel se carga sin establecer el valor del par\u00e1metro configurable stime_ms ? Ejecutar el comando cat /proc/refmod en un terminal. \u00bfQu\u00e9 sucede al intentar interrumpir la ejecuci\u00f3n de cat con CTRL + C ? \u00bfTermina la ejecuci\u00f3n de cat si se env\u00eda una se\u00f1al SIGTERM o SIGKILL con kill a este proceso (usar otra terminal para ello, e incrementar el periodo de bloqueo para tener m\u00e1s tiempo para comprobarlo)? \u00bfEn qu\u00e9 estado se bloquea un proceso cuando la llamada al sistema invocada hace uso de msleep() ? \u00bfCu\u00e1l es el valor del contador de referencia del m\u00f3dulo del kernel mientras NO se est\u00e9 accediendo al fichero de dispositivo? Usar el comando lsmod para consultar el valor de este contador. \u00bfSigue siendo el valor del contador de referencias el mismo mientras ejecutamos cat /proc/refmod en otra terminal (y antes de que ese comando termine)? \u00bfEs posible descargar satisfactoriamente el m\u00f3dulo del kernel mientras \u00e9ste est\u00e1 en uso? Para comprobarlo pueden abrirse 2 terminales, usando el primero de ellos para ejecutar cat /proc/refmod , y el segundo para descargar el m\u00f3dulo ( sudo rmmod refmod ). En caso de que el comando de descarga funcione, comprobar si la ejecuci\u00f3n del comando cat /proc/refmod termina correctamente, y si se muestran o no mensajes de error en el fichero de log del kernel a ra\u00edz de haber tratado de descargar el m\u00f3dulo cuando est\u00e1 en uso. \u00bfCu\u00e1l es la causa de este comportamiento? Modificar el c\u00f3digo de refmod.c para que el contador de referencia del m\u00f3dulo del kernel se incremente al hacer open() en el fichero especial de dispositivo, y se decremente al hacer close() del mismo. Recordad que las funciones que permiten incrementar y decrementar el contador de referencia son try_module_get() y module_put() , respectivamente. Para m\u00e1s informaci\u00f3n se aconseja consultar cualquiera de las variantes del m\u00f3dulo chardev proporcionadas en la pr\u00e1ctica anterior, donde se usan estas funciones. Tras llevar a cabo las modificaciones propuestas, comprobar ahora el valor del contador de referencia del m\u00f3dulo del kernel mientras haya un \"cat\" en curso sobre el fichero de dispositivo. \u00bfEs posible descargar ahora el m\u00f3dulo mientras un proceso est\u00e9 leyendo del fichero especial de dispositivo?","title":"Ejercicio 1"},{"location":"linux-kernel/sincronizacion/#ejercicio-2","text":"Probar el funcionamiento del m\u00f3dulo de ejemplo kthread-mod.c , que al cargarse con insmod crea un kernel thread . Este kernel thread pasa casi todo el tiempo bloqueado, y se despierta cada segundo para imprimir un mensaje en el fichero de log del kernel. Para poder percibir esta impresi\u00f3n peri\u00f3dica del mensaje (tras cargar el m\u00f3dulo) se recomienda abrir una ventana de terminal adicional y ejecutar el siguiente comando: sudo dmesg -w . Este comando permite mostrar en tiempo real los mensajes que se van imprimiendo en el fichero de log del kernel: kernel@debian:~$ sudo dmesg -w [ sudo ] password for kernel: ... Dec 4 14 :15:22 debian kernel: [ 233644 .504010 ] Tic Dec 4 14 :15:23 debian kernel: [ 233645 .524021 ] Tac Dec 4 14 :15:24 debian kernel: [ 233646 .544028 ] Tic Dec 4 14 :15:25 debian kernel: [ 233647 .564029 ] Tac Dec 4 14 :15:26 debian kernel: [ 233648 .584021 ] Tic Dec 4 14 :15:27 debian kernel: [ 233649 .604031 ] Tac ...","title":"Ejercicio 2"},{"location":"linux-kernel/sincronizacion/#ejercicio-3","text":"Analizar el c\u00f3digo del m\u00f3dulo de ejemplo Clipboard-update que hace uso de wait queues para dotar de sem\u00e1ntica bloqueante al dispositivo especial de caracteres que el m\u00f3dulo gestiona. Al cargar el m\u00f3dulo Clibpoard-update en el n\u00facleo, se crea autom\u00e1ticamente el fichero de dispositivo /dev/clipboard_update . A pesar de que la lectura y escritura en este fichero especial de caracteres tiene un comportamiento similar a la entrada /dev/clipboard del m\u00f3dulo en el que se basa (consulta y modificaci\u00f3n, respectivamente del \"clipboard\") el fichero especial implementado en este caso tiene sem\u00e1ntica bloqueante. Todo proceso que lee de la entrada /dev/clipboard_update se queda bloqueado en la operacion clipboard_read() hasta que se produce una actualizaci\u00f3n (escritura) del contenido del \"clipboard\". El proceso escritor, que invoca clipboard_write() es el encargado de despertar a los procesos lectores tras realizar una operaci\u00f3n de actualizaci\u00f3n. Para probar la funcionalidad de este ejemplo se han de abrir tantas ventanas de terminal como procesos acceden al \"clipboard\". A continuaci\u00f3n se muestra un ejemplo con cuatro terminales. Para observar los bloqueos se aconseja hacer primero tres lecturas con cat y a continuaci\u00f3n la escritura con echo : Terminal 1 pi@raspberrypi:~ $ cat /dev/clipboard_update new clipboard Terminal 2 pi@raspberrypi:~ $ cat /dev/clipboard_update new clipboard Terminal 3 pi@raspberrypi:~ $ cat /dev/clipboard_update new clipboard Terminal 4 pi@raspberrypi:~ $ echo \"new clipboard\" > /dev/clipboard_update Tras estudiar el c\u00f3digo fuente, se ha de proporcionar una respuesta a las siguientes preguntas: \u00bfQu\u00e9 sucede si, mientras un proceso est\u00e1 bloqueado en clipboard_read() , tecleamos CTRL + C en la misma terminal (enviando la se\u00f1al SIGINT al proceso que ejecuta cat )? \u00bfPodr\u00eda conseguirse el mismo comportamiento si se hubiera usado wait_event() en lugar de wait_event_interruptible() en la implementaci\u00f3n? Justifica la respuesta. \u00bfGarantiza la implementaci\u00f3n exclusi\u00f3n mutua en el acceso a la variable clipboard? En caso de que no sea as\u00ed prop\u00f3n una soluci\u00f3n que garantice que la implementaci\u00f3n sea SMP-safe .","title":"Ejercicio 3"},{"location":"linux-kernel/sincronizacion/#desarrollo-de-la-practica","text":"Esta pr\u00e1ctica consta de dos partes: A y B","title":"Desarrollo de la pr\u00e1ctica"},{"location":"linux-kernel/sincronizacion/#parte-a","text":"Implementar el m\u00f3dulo ProdCons descrito en clase, que gestiona un buffer circular acotado de enteros, y permite a los procesos de usuario insertar y eliminar n\u00fameros en ese buffer realizando escrituras y lecturas en un fichero especial de caracteres ( /dev/prodcons ). Estas operaciones de lectura (eliminaci\u00f3n) y escritura (inserci\u00f3n) han de tener sem\u00e1ntica productor consumidor: Para insertar un n\u00famero (por ejemplo 7) al final del buffer se debe ejecutar el siguiente comando: $ echo 7 > /dev/prodcons Si el buffer circular est\u00e1 lleno, esta operaci\u00f3n debe bloquear al proceso, hasta que haya de nuevo hueco para realizar la operaci\u00f3n. Para extraer el primer elemento del buffer debe realizarse una lectura del fichero especial de caracteres: $ cat /dev/prodcons Esta operaci\u00f3n bloquear\u00e1 al proceso lector hasta que haya elementos que consumir del buffer. En dicho instante se deber\u00eda mostrar el valor extra\u00eddo del buffer por pantalla (esto requiere rellenar adecuadamente el buffer pasado como par\u00e1metro a la operaci\u00f3n read() del driver). Ejemplo de ejecuci\u00f3n (se asume que buffer puede alojar como mucho 4 enteros) kernel@debian:~/ProdCons$ echo 4 > /dev/prodcons kernel@debian:~/ProdCons$ echo 5 > /dev/prodcons kernel@debian:~/ProdCons$ echo 6 > /dev/prodcons kernel@debian:~/ProdCons$ cat /dev/prodcons 4 kernel@debian:~/ProdCons$ cat /dev/prodcons 5 kernel@debian:~/ProdCons$ cat /dev/prodcons 6 kernel@debian:~/ProdCons$ cat /dev/prodcons <<proceso se queda bloqueado>> Al igual que en el c\u00f3digo a desarrollar en la parte A, se debe garantizar que el m\u00f3dulo NO pueda descargarse si alg\u00fan proceso de usuario est\u00e1 utilizando sus servicios.","title":"Parte A"},{"location":"linux-kernel/sincronizacion/#parte-b","text":"Crear una variante SMP-safe y thread-safe del driver desarrollado en la pr\u00e1ctica anterior ParteB -- driver que gestiona el display 7 segmentos de la placa Bee v2.0. Para ello se crear\u00e1 una variante de dicho driver que asegure lo siguiente: El driver no debe poder descargarse si alg\u00fan proceso de usuario est\u00e1 utilizando sus servicios. La implementaci\u00f3n debe garantizar que solo un proceso debe poder estar accediendo al fichero de dispositivo /dev/display7s en un instante determinado. Para ello, debe mantenerse un contador que lleve la cuenta del n\u00famero de procesos que est\u00e1n accediendo al dispositivo (a incrementar en open() , y decrementar en release() ). Si un proceso intenta abrir el dispositivo cuando est\u00e1 ya en uso, la operaci\u00f3n open() devolver\u00e1 un error ( -EBUSY ). El contador del n\u00famero de procesos que est\u00e1n usando el fichero especial de dispositivo (valor 0 o 1) debe actualizarse de forma segura usando un recurso de sincronizaci\u00f3n del kernel. El estudiante puede escoger el tipo de recurso que considere oportuno para permitir la actualizaci\u00f3n segura del contador. La implementaci\u00f3n de la operaci\u00f3n write() sobre el fichero especial de dispositivo debe ser thread-safe ; es decir, en caso de que varios hilos de un mismo proceso (con el descriptor compartido) quisieran hacer escrituras simult\u00e1neas sobre el fichero especial de dispositivo, debe serializarse la invocaci\u00f3n de la funci\u00f3n display7s_write() , que es la que realiza la modificaci\u00f3n del estado del display 7 segmentos. Se deja a elecci\u00f3n del estudiante el mecanismo o mecanismos de sincronizaci\u00f3n a utilizar para imponer esta restricci\u00f3n (que solo un hilo pueda ejecutar display7s_write() ). Nota importante : Se ha de tener en cuenta que la funci\u00f3n msleep() , que se invoca desde display7s_write() , es bloqueante.","title":"Parte B"},{"location":"linux-kernel/sincronizacion/#parte-opcional-de-la-practica","text":"Crear una variante del ejemplo Clipboard-update donde se utilicen sem\u00e1foros del kernel en lugar de wait queues para dotar de sem\u00e1ntica bloqueante a la operaci\u00f3n de lectura en /dev/clipboard_update . Pista : Se aconseja la utilizaci\u00f3n de dos sem\u00e1foros, uno de ellos a utilizar como cerrojo (contador inicializado a 1), y el otro como cola de espera (contador inicializado a 0) para bloquear a los procesos que lean de /dev/clipboard_update . Asimismo debe mantenerse un contador global para llevar la cuenta de los procesos esperando en el segundo sem\u00e1foro.","title":"Parte opcional de la pr\u00e1ctica"},{"location":"pwm_linux/","text":"Control PWM en Linux \u00b6 En esta pr\u00e1ctica vamos a estudiar c\u00f3mo podemos utilizar los controladores PWM desde un programa de usuario en Linux. Se\u00f1ales PWM \u00b6 Las se\u00f1ales de modulaci\u00f3n de ancho de pulso (Pulse Width Modulation, PWM) se describen en la siguiente figura: Se trata de una se\u00f1al rectangular de un periodo fijo, en la que la fracci\u00f3n del periodo en que la se\u00f1al toma un valor distinto de cero se define como duty cycle . Sin embargo, muchos interfaces de control PWM toman el duty cycle como el tiempo absoluto en que la se\u00f1al est\u00e1 activa, que debe ser menor que la duraci\u00f3n (absoluta) del periodo. Este tipo de se\u00f1ales se utilizan frecuentemente para el control de servos y la conversi\u00f3n digital anal\u00f3gica (en ausencia de DAC). Interfaz sysfs \u00b6 En la raspberry pi hay dos controladores pwm hardware, con la misma se\u00f1al de reloj (19.2 MHz). Aunque puede obtenerse su salida por varios pines distintos, para la placa de expansi\u00f3n BEE es conveniente usar para el pwm0 el pin 18 o el pin 12 y para el pwm1 el pin 13. Los dos controladores son usados por el sistema de audio. El driver de pwm ofrece actualmente un interfaz a trav\u00e9s del sistema virtual de ficheros sysfs. Debe ser habilitado cargando el overlay pwm-2chan. Esto puede hacerse de dos formas: Din\u00e1micamente con: sudo dtoverlay pwm-2chan pin = 18 func = 2 pin2 = 13 func2 = 4 En arranque, si a\u00f1adimos al fichero \\texttt{config.txt} la l\u00ednea: dtoverlay = pwm-2chan,pin = 18 ,func = 2 ,pin2 = 13 ,func2 = 4 Una vez habilitado nos aparecer\u00e1 el directorio /sys/class/pwm/pwmchip0 con los siguientes ficheros: device, export, npwm, power, subsystem, uevent y unexport. Para poder usar los canales pwm primero hay que exportarlos escribiendo el n\u00famero del canal a usar en el fichero export: $ echo 0 > /sys/class/pwm/pwmchip0/export $ echo 1 > /sys/class/pwm/pwmchip0/export Una vez exportados nos aparecer\u00e1n dos nuevos directorios: pwm0 y pwm1 , con los siguientes ficheros: capture , duty_cycle , enable , period , polarity , power y uevent . El sistema genera un evento udev cuando aparecen y hay que esperar este evento para poder continuar (ver ejemplo). Una vez que se dispare el evento podemos usar un canal. Para ello debemos seguir el siguiente procedimiento: Escribir el periodo en ns en el fichero period Escribir el duty cycle en ns en el fichero duty_cycle Escribir un 1 en el fichero enable Podemos cambiar din\u00e1micamente el periodo y/o el duty cycle o apagar un canal escribiendo un 0 en el fichero enable . Cuando queramos dejar de usar un canal deberemos escribir su n\u00famero en el fichero unexport . Como ejemplo, el script bash servo_cont_rot.sh ofrece un interfaz de l\u00ednea de comandos para el control de un servo de rotaci\u00f3n continual de parallax. Si se dispone de uno de estos servos, se puede probar conect\u00e1ndolo a los pines indicados arriba. Podemos ejecutar el script sin par\u00e1metros o con -h para ver la lista de opciones. El programa servo_control.c es un ejemplo de como controlar el mismo servo de rotaci\u00f3n continua de parallax desde un programa C. Utiliza 3 pulsadores conectados a tres pines del gpio para controlar el servo. El programa recibe como argumentos: el fichero del controlador gpio, el canal de pwm a usar y los tres pines a usar como entrada. Uno de los botones permite decrementar el duty cycle, otro incrementarlo y otro parar el servo. El programa exporta el canal pwm indicado y espera a que el kernel notifique que est\u00e1 montado (esperando eventos de udev). Si el pwm ya est\u00e1 exportado da un aviso pero sigue adelante. PWM por software \u00b6 En lugar de utilizar controladores PWM hardware, es posible utilizar pines gen\u00e9ricos del GPIO para generar una se\u00f1al PWM por software. Si es posible, ser\u00eda mejor crear para ello una tarea de tiempo real, aunque esto queda fuera del alcance de esta pr\u00e1ctica. Tenemos dos alternativas: Usar clock_nanosleep con el flag TIMER_ABSTIME , usando dos intervalos, uno para el periodo y otro para el duty cycle. De esta forma, se espera ( clock_nanosleep ) un periodo, Usar timers POSIX, con un timer peri\u00f3dico para el periodo y uno one shot para el duty cycle, activado en cada periodo. Probar estas alternativas se deja como ejercicio al estudiante interesado. La limitaci\u00f3n de esta estrategia es la precisi\u00f3n de la se\u00f1al, que estar\u00e1 expuesta a la variabilidad del tiempo de respuesta del kernel (jitter). Este jitter puede llegar a medirse con un osciloscopio. Puede mejorarse utilizando un kernel de tiempo real y tareas de tiempo real.","title":"Control PWM en Linux"},{"location":"pwm_linux/#control-pwm-en-linux","text":"En esta pr\u00e1ctica vamos a estudiar c\u00f3mo podemos utilizar los controladores PWM desde un programa de usuario en Linux.","title":"Control PWM en Linux"},{"location":"pwm_linux/#senales-pwm","text":"Las se\u00f1ales de modulaci\u00f3n de ancho de pulso (Pulse Width Modulation, PWM) se describen en la siguiente figura: Se trata de una se\u00f1al rectangular de un periodo fijo, en la que la fracci\u00f3n del periodo en que la se\u00f1al toma un valor distinto de cero se define como duty cycle . Sin embargo, muchos interfaces de control PWM toman el duty cycle como el tiempo absoluto en que la se\u00f1al est\u00e1 activa, que debe ser menor que la duraci\u00f3n (absoluta) del periodo. Este tipo de se\u00f1ales se utilizan frecuentemente para el control de servos y la conversi\u00f3n digital anal\u00f3gica (en ausencia de DAC).","title":"Se\u00f1ales PWM"},{"location":"pwm_linux/#interfaz-sysfs","text":"En la raspberry pi hay dos controladores pwm hardware, con la misma se\u00f1al de reloj (19.2 MHz). Aunque puede obtenerse su salida por varios pines distintos, para la placa de expansi\u00f3n BEE es conveniente usar para el pwm0 el pin 18 o el pin 12 y para el pwm1 el pin 13. Los dos controladores son usados por el sistema de audio. El driver de pwm ofrece actualmente un interfaz a trav\u00e9s del sistema virtual de ficheros sysfs. Debe ser habilitado cargando el overlay pwm-2chan. Esto puede hacerse de dos formas: Din\u00e1micamente con: sudo dtoverlay pwm-2chan pin = 18 func = 2 pin2 = 13 func2 = 4 En arranque, si a\u00f1adimos al fichero \\texttt{config.txt} la l\u00ednea: dtoverlay = pwm-2chan,pin = 18 ,func = 2 ,pin2 = 13 ,func2 = 4 Una vez habilitado nos aparecer\u00e1 el directorio /sys/class/pwm/pwmchip0 con los siguientes ficheros: device, export, npwm, power, subsystem, uevent y unexport. Para poder usar los canales pwm primero hay que exportarlos escribiendo el n\u00famero del canal a usar en el fichero export: $ echo 0 > /sys/class/pwm/pwmchip0/export $ echo 1 > /sys/class/pwm/pwmchip0/export Una vez exportados nos aparecer\u00e1n dos nuevos directorios: pwm0 y pwm1 , con los siguientes ficheros: capture , duty_cycle , enable , period , polarity , power y uevent . El sistema genera un evento udev cuando aparecen y hay que esperar este evento para poder continuar (ver ejemplo). Una vez que se dispare el evento podemos usar un canal. Para ello debemos seguir el siguiente procedimiento: Escribir el periodo en ns en el fichero period Escribir el duty cycle en ns en el fichero duty_cycle Escribir un 1 en el fichero enable Podemos cambiar din\u00e1micamente el periodo y/o el duty cycle o apagar un canal escribiendo un 0 en el fichero enable . Cuando queramos dejar de usar un canal deberemos escribir su n\u00famero en el fichero unexport . Como ejemplo, el script bash servo_cont_rot.sh ofrece un interfaz de l\u00ednea de comandos para el control de un servo de rotaci\u00f3n continual de parallax. Si se dispone de uno de estos servos, se puede probar conect\u00e1ndolo a los pines indicados arriba. Podemos ejecutar el script sin par\u00e1metros o con -h para ver la lista de opciones. El programa servo_control.c es un ejemplo de como controlar el mismo servo de rotaci\u00f3n continua de parallax desde un programa C. Utiliza 3 pulsadores conectados a tres pines del gpio para controlar el servo. El programa recibe como argumentos: el fichero del controlador gpio, el canal de pwm a usar y los tres pines a usar como entrada. Uno de los botones permite decrementar el duty cycle, otro incrementarlo y otro parar el servo. El programa exporta el canal pwm indicado y espera a que el kernel notifique que est\u00e1 montado (esperando eventos de udev). Si el pwm ya est\u00e1 exportado da un aviso pero sigue adelante.","title":"Interfaz sysfs"},{"location":"pwm_linux/#pwm-por-software","text":"En lugar de utilizar controladores PWM hardware, es posible utilizar pines gen\u00e9ricos del GPIO para generar una se\u00f1al PWM por software. Si es posible, ser\u00eda mejor crear para ello una tarea de tiempo real, aunque esto queda fuera del alcance de esta pr\u00e1ctica. Tenemos dos alternativas: Usar clock_nanosleep con el flag TIMER_ABSTIME , usando dos intervalos, uno para el periodo y otro para el duty cycle. De esta forma, se espera ( clock_nanosleep ) un periodo, Usar timers POSIX, con un timer peri\u00f3dico para el periodo y uno one shot para el duty cycle, activado en cada periodo. Probar estas alternativas se deja como ejercicio al estudiante interesado. La limitaci\u00f3n de esta estrategia es la precisi\u00f3n de la se\u00f1al, que estar\u00e1 expuesta a la variabilidad del tiempo de respuesta del kernel (jitter). Este jitter puede llegar a medirse con un osciloscopio. Puede mejorarse utilizando un kernel de tiempo real y tareas de tiempo real.","title":"PWM por software"},{"location":"robotica/","text":"Pr\u00e1cticas de Rob\u00f3tica \u00b6 Motores. Parte 1 \u00b6 Objetivos \u00b6 Familiarizarse con la Raspberry Pi y su entorno. Generaci\u00f3n de una se\u00f1al para control de un motor paso a paso. Generaci\u00f3n de una se\u00f1al (PWM) para control de un servomotor. La finalidad de esta pr\u00e1ctica es aprender a generar se\u00f1ales en el orden adecuado para mover un motor paso a paso y aplicar una se\u00f1al de PWM para controlar un motor de continua (servomotor de rotaci\u00f3n continua). Estos tipos de motores son muy utilizados en Rob\u00f3tica. En concreto, el servo de rotaci\u00f3n continua se utilizar\u00e1 para controlar un robot m\u00f3vil sencillo. Nota Antes de ejecutar un programa, verifique con su profesor que las conexiones est\u00e1n realizadas correctamente. Desarrollo de la pr\u00e1ctica \u00b6 Para familiarizarse con el entorno de programaci\u00f3n de la Raspberry Pi, primero vamos a realizar dos tareas sencillas. Tarea 1: Conocer el entorno de la Raspberry Alimenta la Raspberry Pi y conecta el port\u00e1til a ella (vea c\u00f3mo conectar con la Raspberry Pi). Una vez conectado, cambia al directorio wiringPi/examples . All\u00ed hay un archivo denominado blink.c . Lo que haremos ser\u00e1 comprobar que est\u00e1 funcionando correctamente la Raspberry: compila el programa escribiendo: make blink Observa que se crea un ejecutable. Tarea 2: \"Hola Mundo\" hardware El objetivo de esta tarea es programar el parpadeo de un LED. Para ello, en primer lugar, habr\u00e1 que realizar el montaje indicado en la siguiente figura: Conecta el LED al Pin GPIO 17 (el Wiring Pin 0). La resistencia utilizada es de 220 \u03a9. Dependiendo de la biblioteca software que usemos para programar la Raspberry, la numeraci\u00f3n de los pines cambia. En la siguiente figura pueden verse las distintas numeraciones seg\u00fan el conector f\u00edsico de 40 pines. La placa de conexiones Bee 2.0 sigue la numeraci\u00f3n BCM. De este modo, el pin serigrafiado en la placa como B17 corresponde al pin f\u00edsico 11 o al WiringPi 0. Si ahora ejecutamos el programa anterior: sudo ./blink Se ver\u00e1 que el LED parpadea. Edita el programa, cambia la frecuencia de parpadeo, vuelve a compilarlo y observa que su frecuencia cambia. Tambi\u00e9n puede conectarse el LED en otro Pin de la Raspberry, pero en ese caso hay que cambiar el pin asignado en el archivo blink.c: #define 0 LED Control de motores de rotaci\u00f3n continua \u00b6 El servomotor no debe ser alimentado directamente por la Raspberry Pi porque en caso de que requiera realizar un esfuerzo grande puede requerir un consumo que no puede proporcionar la Raspberry. La alimentaci\u00f3n del servo se realizar\u00e1 externamente y SOLO el pin de control del motor (PWM) se conectar\u00e1 a la Raspberry. Tarea 3: Control por pwm de servomotres usando C++ Para controlar los motores por pwm en C o C++ se puede usar la biblioteca WiringPi. Al igual que en python conviene tener en cuenta los siguientes aspectos: Es necesario incluir la librer\u00eda en el c\u00f3digo: #include <wiringPi.h> - La biblioteca WiringPi usa otra numeraci\u00f3n de pines, como se indicaba anteriormente. Los pines correspondientes seg\u00fan la numeraci\u00f3n WiringPi a los pwm_0 y pwm_1 son: #define PinMotor0 23 //pwm_1 #define PinMotor1 26 //for pwm_0 Es necesario inicializar la librer\u00eda Hay que configurar el pin como un pin pwm de salida Para dar un valor de pwm a la salida correspondiente basta con usar el comando Establece el rango de valores de PWM sirven para girar en un sentido u otro. Con este rango podr\u00e1s escoger un valor adecuado para usarlo en el futuro control del robot. Referencias \u00fatiles \u00b6 Control de servomotor usando Python 1 Control de servomotor usando Python 2 Referencia de WiringPi Utilidad gpio de Adafruit Motores. Parte 2 \u00b6 Objetivos \u00b6 La finalidad de esta pr\u00e1ctica es aplicar una se\u00f1al de PWM para controlar los actuadores (servomotores de rotaci\u00f3n continua) de un robot m\u00f3vil sencillo. Una vez que se mueven adecuadamente los dos motores del robot de tipo diferencial construido, se realizar\u00e1n varios movimientos para mostrar que se es capaz de controlar adecuadamente el robot. Desarrollo de la pr\u00e1ctica \u00b6 Preparaci\u00f3n \u00b6 El robot utilizar\u00e1 dos servos de rotaci\u00f3n cont\u00ednua. Aseguraos de que est\u00e1n alineados adecuadamente y las ruedas est\u00e1n fijadas para que el robot pueda moverse en l\u00ednea recta. Si el robot tiene una deriva alta, su control ser\u00e1 m\u00e1s complejo e impedir\u00e1 un correcto funcionamiento en futuras pr\u00e1cticas en las que se utilizar\u00e1. Colocad sobre la plataforma el circuito anterior y la Rasp Pi para mover los motores a la vez. Si el dise\u00f1o y sujeci\u00f3n de los motores es el adecuado debe ser capaz de moverse en l\u00ednea recta sin desviarse. Como m\u00ednimo deber\u00eda recorrer un tramo de unos 2 m con una desviaci\u00f3n m\u00e1xima de un 10% hacia cualquiera de los dos lados. Control en lazo abierto \u00b6 Una vez que se ha comprobado que sabe crear un programa utilizando la librer\u00eda wiringPi, se ha configurado y calibrado los servos de las ruedas del robot y movido el robot de forma b\u00e1sica para verificar que la posici\u00f3n de los motores es la adecuada, el objetivo ser\u00e1 crear un programa que mueva el robot una distancia y \u00e1ngulo deseados. Como el robot no tiene realimentaci\u00f3n de la posici\u00f3n cualquier error, deslizamiento o desviaci\u00f3n no se detectar\u00e1. Para mover el robot una distancia deseada, mediremos la velocidad con que se desplaza el robot (velocidad de las ruedas) y moveremos el robot (siempre a la misma velocidad) durante el tiempo que corresponda para la distancia deseada. Es decir: Poned las ruedas a girar y registrad el tiempo que tarda en dar 10 vueltas. Ese tiempo ser\u00e1 T_i Para obtener la velocidad de cada rueda por segundo bastar\u00e1 con realizar v_i=T_i/10 vueltas por segundo. Es necesario medir el radio de las ruedas para poder calcular la longitud de su circunferencia y as\u00ed saber la distancia que recorre el robot en una vuelta. Con estos datos ya se puede pasar una distancia recorrida por una rueda a n\u00famero de vueltas. Con la velocidad de la rueda que ya se ha calculado se puede saber el tiempo que ha de estar girando la rueda. Este tiempo es que se debe esperar antes de parar los motores para que el robot mueva las ruedas la distancia deseada. Con los c\u00e1lculos anteriores puede obtener el tiempo para que cada rueda gire la distancia deseada. Esta distancia se obtendr\u00e1 de las ecuaciones y del modelo de un robot diferencial, donde la distancia a desplazarse (o el \u00e1ngulo que queremos que gire) es la proporcionada por el usuario. Tarea 1: Movimiento en l\u00ednea recta. Programad el robot para que se mueva una distancia determinada a partir del tiempo que est\u00e1 en funcionamiento los motores (control en lazo abierto). Probadlo con la distancia del apartado anterior y ved si es capaz de parar a los 2 m. Tarea 2: Giro en lazo abierto Programad el robot para que gire el n\u00famero de \u00e1ngulos determinado. Probadlo con 90 grados. Tarea 3: Movimiento complejo del robot A continuaci\u00f3n realizaremos, utilizando las ecuaciones anteriores, un movimiento algo m\u00e1s complejo donde se combinen simult\u00e1neamente movimientos rectos y giros. El movimiento que el robot realizar\u00e1 ser\u00e1 un rect\u00e1ngulo. Tarea 4: Movimientos complejos El robot deber\u00eda quedar en la misma posici\u00f3n que al principio. Estimar el error cometido. \u00bfEst\u00e1 dentro de una bola de error de radio 10 cm? Sensores \u00b6 Objetivos \u00b6 Lectura de sensores digitales con la RaspberryPi. Lectura de sensores anal\u00f3gicos con la RaspberryPi. Integraci\u00f3n de sensores en el robot La finalidad de esta pr\u00e1ctica es que el alumno utilice distintos sensores t\u00edpicos en un robot m\u00f3vil. Se utilizar\u00e1n: Interruptor : se\u00f1al binaria (todo o nada) LDR : se\u00f1al de voltaje variable (anal\u00f3gica, requiere conversor A/D) Sensor de ultrasonidos : se\u00f1al procesada, salida digital Nota Antes de ejecutar un programa verifica con tu profesor que las conexiones est\u00e1n realizadas correctamente. Desarrollo de la pr\u00e1ctica \u00b6 Lectura de sensores digitales \u00b6 Botones \u00b6 Un sensor muy utilizado en los robots son los sensores de contacto. Estos pueden ser de distintos tipos siendo los m\u00e1s utilizados los de bot\u00f3n y los de palanca. Con ellos se reconoce la presencia de un objeto ubicado en la l\u00ednea de recorrido de un dispositivo. Tambi\u00e9n se pueden emplear (los botones) t\u00edpicamente como interfaz con el usuario. Su simplicidad de construcci\u00f3n y uso los hace muy empleados en rob\u00f3tica. En esta pr\u00e1ctica se van a usar los tres botones que est\u00e1n integrados en la placa Bee 2.0. Los botones integrados en la placa Bee 2.0 tienen tres patillas: GND 3.3 V (a trav\u00e9s de resistencia de 10k\u2126) Pin del conector J4 Los LEDs est\u00e1n conectados a GND y al conector J4 a trav\u00e9s de una resistencia de 220\u2126. Para poder usar los botones simplemente tendremos que unir con un cable la patilla libre del bot\u00f3n (aquella que est\u00e1 conectada con uno de los pines del conector J4 a una de las entradas digitales de la RaspberryPi (por ejemplo la entrada BCM0) Tarea 1: Activar el LED con el bot\u00f3n Conecta un bot\u00f3n y un LED a pines de entrada/salida digital de la RaspberryPi. Programa: encender LED si el bot\u00f3n est\u00e1 pulsado, apagar si no. Funciones WiringPi: digitalRead ( pinToRead ); digitalWrite ( pinToWrite , value ); // value = 1 (alto), 0 (bajo) Configura los pines como INPUT o OUTPUT . Sensor de infrarrojos CNY70 \u00b6 El CNY70 es un sensor \u00f3ptico reflexivo de infrarrojos de corto alcance (de 0, 3 a 10 mm.) basado en un diodo emisor de luz infrarroja y un receptor formado por un fototransistor, ambos apuntando en la misma direcci\u00f3n, y cuyo funcionamiento se basa en la capacidad de reflexi\u00f3n del objeto, y la detecci\u00f3n del rayo reflectado por el receptor (sensor \u00f3ptico de proximidad). Al tener un alcance tan corto, no se suele utilizar para detectar obst\u00e1culos, sino como sensor de proximidad, componente de lectura para un encoder, como elemento para detecci\u00f3n y seguimiento de l\u00edneas u otras aplicaciones similares. Podemos usar el CNY70 de dos formas: Como un sensor digital que nos proporciona un 0 o un 1 en caso de que haya objeto o en para distancias de entre [0, 10] mm. Como un sensor anal\u00f3gico, midiendo la se\u00f1al que proporciona el sensor dependiendo de la situaci\u00f3n que se desee. Vamos a emplearlo en primer lugar como sensor de proximidad, lo que quiere decir que ser\u00e1 un sensor digital que nos informar\u00e1 si hay objeto o no \u00fanicamente. Para poder usar este sensor hay que tener en cuenta dos cosas: Polarizar LED emisor con resistencia a GND Usa divisor de tensi\u00f3n si trabajas con Raspberry Pi (3.3V) Tarea 2: Lectura del sensor CNY70 Conecta sensor a entrada digital. Crea un for con delay (500 o 1000 ms) y muestra en pantalla la lectura. Tarea 3: Rango del sensor Prueba el rango de detecci\u00f3n del sensor. Tarea 4: Comportamiento con diferentes colores Usa objetos de diferentes colores. \u00bfDetecta todos? \u00bfPor qu\u00e9? Sensores anal\u00f3gicos \u00b6 Existen sensores que proporcionan una se\u00f1al anal\u00f3gica (normalmente una se\u00f1al de voltaje) que es proporcional a la medida que queremos leer. Este es el caso de muchos sensores de temperatura, de presi\u00f3n, de humedad, de luz, etc. Las RaspberryPi 3 no tiene entradas anal\u00f3gicas, de manera que necesitaremos usar un conversor AD para pasar la se\u00f1al anal\u00f3gica a la digital. La placa Bee v2.0 tiene integrado un conversor AD, el MCP3008 que permite conectarle una se\u00f1al anal\u00f3gica y transformarla en una digital que la Raspberry puede leer. Light-Dependent Resistor \u00b6 Un LDR (Light-Dependent Resistor) es un material que var\u00eda su valor de resistencia el\u00e9ctrica dependiendo de la cantidad de luz que incide sobre \u00e9l. Se le llama, tambi\u00e9n, fotorresistor o fotorresistencia. El valor de resistencia el\u00e9ctrica de un LDR es bajo cuando hay luz incidiendo en \u00e9l (en algunos casos puede descender a tan bajo como 50\u03a9 ) y muy alto cuando est\u00e1 a oscuras (puede ser de varios M \u03a9). Los LDR se fabrican con un cristal semiconductor fotosensible como el sulfuro de cadmio (CdS). Estas celdas son sensibles a un rango amplio de frecuencias lum\u00ednicas, desde la luz infrarroja, pasando por la luz visible, y hasta la ultravioleta. La variaci\u00f3n de valor resistivo de un LDR tiene cierto retardo, que es diferente si se pasa de oscuro a iluminado o de iluminado a oscuro. Por esta raz\u00f3n un LDR no se puede utilizar en algunas aplicaciones, en especial en aquellas en que la se\u00f1al luminosa var\u00eda con rapidez. El tiempo de respuesta t\u00edpico de un LDR est\u00e1 en el orden de una d\u00e9cima de segundo. La lentitud relativa del cambio es una ventaja en algunos casos, porque as\u00ed se filtran variaciones r\u00e1pidas de iluminaci\u00f3n que podr\u00edan hacer inestable un sensor (por ejemplo, cuando est\u00e1 iluminado por un tubo fluorescente alimentado por corriente alterna), En otras aplicaciones (como la detecci\u00f3n de luminosidad para saber si es de d\u00eda o es de noche) la lentitud de la detecci\u00f3n no es importante. Para ver c\u00f3mo cambia la resistencia con la luz, podemos hacer un circuito como el de la figura, donde el punto de lectura del voltaje se realiza en (1). Estos tipos de sensores son muy dependientes de la iluminaci\u00f3n ambiente, por lo que es necesario protegerlos de la luz o realizar una calibraci\u00f3n para tener en cuenta la iluminaci\u00f3n actual que ser\u00eda previa a su utilizaci\u00f3n, peri\u00f3dicamente, o cuando cambien las condiciones de trabajo. Para conectarlo a la Raspberry, utilizaremos como alimentaci\u00f3n los 3.3 voltios del GPIO para Vdc. En cuanto a la lectura del voltaje en el punto (1), dado que es una se\u00f1al anal\u00f3gica, necesitaremos un conversor A/D. Debido a que la Raspberry Pi no dispone de ninguno, en nuestro caso, utilizaremos el integrado MCP3008. El MCP3008 es un convertidor de anal\u00f3gico a digital, de 8 canales de 10 bits (conversor AD o ADC). Es barato, f\u00e1cil de conectar y no requiere ning\u00fan componente adicional. Se utiliza el protocolo de bus SPI que est\u00e1 soportado por el GPIO de la Raspberry Pi y por tanto puede utilizarse tambi\u00e9n con la librer\u00eda WiringPi. Como puede verse en la figura los pines del lado derecho del MCP3008 son las entradas anal\u00f3gicas (los 8 canales anal\u00f3gicos), AGND y DGND son la tierra anal\u00f3gica y digital, VDD la alimentaci\u00f3n del integrado y VREF el voltaje de referencia de la entrada anal\u00f3gica. Los pines 10-14 (CS,Din,Dout,Clk) corresponden a los pines del protocolo serie SPI por donde se lee la conversi\u00f3n del voltaje. Para conocer el voltaje en un canal se utilizar\u00e1 la f\u00f3rmula: F\u00f3rmula: \\[ V_{canal} = (LecturaSPI / 1024) * Vref \\] La placa Bee v2.0 tiene integrado el conversor MCP3008, figura 8. Para emplearlo hay que: Unir con un jumper los pines MOSI, MISO, SCLK y CE0 ADC del conector J2 con los B10, B9 B11 y B8 del mismo conector. Unir con un jumper los dos pines del conector J11 Unir con un jumper los pines Vcc y 3.3 del conector J18 Unir con un jumper los pines Vdd y 3.3 del conector J14 Una vez hecho esto, ya se puede conectar la salida anal\u00f3gica del sensor (con la resistencia R adecuada, que puede usarse de la red de polarizaci\u00f3n) a una de las entradas del conversor A/D Cargar drivers SPI: gpio load spi C\u00f3digo base (conversor.c): https://osoyoo.com/2017/06/29/raspberry-pi-mcp3008/ Tarea 5: Lectura sensor LDR Lee y muestra el voltaje del LDR. Tarea 6: Efecto de la luz ambien Observa efecto de luz ambiente. \u00bfC\u00f3mo afecta a la medida? \u00bfC\u00f3mo usarlo para encender una bombilla si baja la luz? Tarea 7: Comportamiento ante distintas fuentes de luz Comprueba variaci\u00f3n con distintas fuentes de luz. Tarea 8: Robot sigue-luz \u00bfC\u00f3mo construir\u00edas un robot que siga una fuente de luz (como una linterna)?","title":"Pr\u00e1cticas de Rob\u00f3tica"},{"location":"robotica/#practicas-de-robotica","text":"","title":"Pr\u00e1cticas de Rob\u00f3tica"},{"location":"robotica/#motores-parte-1","text":"","title":"Motores. Parte 1"},{"location":"robotica/#objetivos","text":"Familiarizarse con la Raspberry Pi y su entorno. Generaci\u00f3n de una se\u00f1al para control de un motor paso a paso. Generaci\u00f3n de una se\u00f1al (PWM) para control de un servomotor. La finalidad de esta pr\u00e1ctica es aprender a generar se\u00f1ales en el orden adecuado para mover un motor paso a paso y aplicar una se\u00f1al de PWM para controlar un motor de continua (servomotor de rotaci\u00f3n continua). Estos tipos de motores son muy utilizados en Rob\u00f3tica. En concreto, el servo de rotaci\u00f3n continua se utilizar\u00e1 para controlar un robot m\u00f3vil sencillo. Nota Antes de ejecutar un programa, verifique con su profesor que las conexiones est\u00e1n realizadas correctamente.","title":"Objetivos"},{"location":"robotica/#desarrollo-de-la-practica","text":"Para familiarizarse con el entorno de programaci\u00f3n de la Raspberry Pi, primero vamos a realizar dos tareas sencillas. Tarea 1: Conocer el entorno de la Raspberry Alimenta la Raspberry Pi y conecta el port\u00e1til a ella (vea c\u00f3mo conectar con la Raspberry Pi). Una vez conectado, cambia al directorio wiringPi/examples . All\u00ed hay un archivo denominado blink.c . Lo que haremos ser\u00e1 comprobar que est\u00e1 funcionando correctamente la Raspberry: compila el programa escribiendo: make blink Observa que se crea un ejecutable. Tarea 2: \"Hola Mundo\" hardware El objetivo de esta tarea es programar el parpadeo de un LED. Para ello, en primer lugar, habr\u00e1 que realizar el montaje indicado en la siguiente figura: Conecta el LED al Pin GPIO 17 (el Wiring Pin 0). La resistencia utilizada es de 220 \u03a9. Dependiendo de la biblioteca software que usemos para programar la Raspberry, la numeraci\u00f3n de los pines cambia. En la siguiente figura pueden verse las distintas numeraciones seg\u00fan el conector f\u00edsico de 40 pines. La placa de conexiones Bee 2.0 sigue la numeraci\u00f3n BCM. De este modo, el pin serigrafiado en la placa como B17 corresponde al pin f\u00edsico 11 o al WiringPi 0. Si ahora ejecutamos el programa anterior: sudo ./blink Se ver\u00e1 que el LED parpadea. Edita el programa, cambia la frecuencia de parpadeo, vuelve a compilarlo y observa que su frecuencia cambia. Tambi\u00e9n puede conectarse el LED en otro Pin de la Raspberry, pero en ese caso hay que cambiar el pin asignado en el archivo blink.c: #define 0 LED","title":"Desarrollo de la pr\u00e1ctica"},{"location":"robotica/#referencias-utiles","text":"Control de servomotor usando Python 1 Control de servomotor usando Python 2 Referencia de WiringPi Utilidad gpio de Adafruit","title":"Referencias \u00fatiles"},{"location":"robotica/#motores-parte-2","text":"","title":"Motores. Parte 2"},{"location":"robotica/#objetivos_1","text":"La finalidad de esta pr\u00e1ctica es aplicar una se\u00f1al de PWM para controlar los actuadores (servomotores de rotaci\u00f3n continua) de un robot m\u00f3vil sencillo. Una vez que se mueven adecuadamente los dos motores del robot de tipo diferencial construido, se realizar\u00e1n varios movimientos para mostrar que se es capaz de controlar adecuadamente el robot.","title":"Objetivos"},{"location":"robotica/#desarrollo-de-la-practica_1","text":"","title":"Desarrollo de la pr\u00e1ctica"},{"location":"robotica/#sensores","text":"","title":"Sensores"},{"location":"robotica/#objetivos_2","text":"Lectura de sensores digitales con la RaspberryPi. Lectura de sensores anal\u00f3gicos con la RaspberryPi. Integraci\u00f3n de sensores en el robot La finalidad de esta pr\u00e1ctica es que el alumno utilice distintos sensores t\u00edpicos en un robot m\u00f3vil. Se utilizar\u00e1n: Interruptor : se\u00f1al binaria (todo o nada) LDR : se\u00f1al de voltaje variable (anal\u00f3gica, requiere conversor A/D) Sensor de ultrasonidos : se\u00f1al procesada, salida digital Nota Antes de ejecutar un programa verifica con tu profesor que las conexiones est\u00e1n realizadas correctamente.","title":"Objetivos"},{"location":"robotica/#desarrollo-de-la-practica_2","text":"","title":"Desarrollo de la pr\u00e1ctica"},{"location":"spi_linux/","text":"Control de dispositivos SPI \u00b6 En esta pr\u00e1ctica vamos a ver c\u00f3mo podemos manejar dispositivos conectados al controlador spi utilizando el driver spi de Linux. Comenzaremos recordando brevemente el funcionamiento del bus spi, ya que es necesario entenrlo para manejar el driver y los dispositivos. Al final probaremos lo que hemos aprendido utilizando el ADC incluido en la placa BEE. Bus SPI \u00b6 El Serial Peripheral Interface (SPI) es un bus serie s\u00edncrono y bidirccional muy utilizado en sistemas empotrados para conectar un microcontrolador a sus perif\u00e9ricos. Puede trabajar con frecuencias de 1 a 20 MHz, pero s\u00f3lo un dispositivo puede ser m\u00e1ster del bus. El bus utiliza 4 l\u00edneas m\u00e1s una tierra com\u00fan: Master out/Slave in ( MOSI , SDI ) Master in/Slave out ( MISO , SDO ) Serial clock ( SCK ) Slave Select ( nSS ): activo a baja Los dispositivos SPI pueden funcionar en dos modos Master : es el que puede iniciar y controlar una transferencia Slave : es el que se comunica con un master que le active El m\u00e1ster selecciona al slave con el que quiere comunicarse activando su se\u00f1al SS (poni\u00e9ndola a 0). Si un dispositivo puede hacer de m\u00e1ster o slave, puede configurar el pin nSS como entrada para ver si otro m\u00f3dulo est\u00e1 actuando como master. Si se detecta otro m\u00e1ster el dispositivo debe configurarse en modo slave. En SPI el env\u00edo y la recepci\u00f3n suceden simult\u00e1neamente, el bus funciona como un registro de desplazamiento circular distribuido. Se suele utilizar un sistema de doble buffer. El master y el slave tienen un registro de datos de 8 bits utilizado por el software para escribir el dato a transmitir o leer el dato recibido. Tambi\u00e9n disponen de un registro de desplazamiento de 8 bits. El procediminto de transmisi\u00f3n se ilustra en la figura de abajo. Pongamos por ejemplo que el master quiere env\u00edar un byte a un esclavo. Para transmitir se empieza copiando el dato en el registro de datos, que despu\u00e9s se copia en el registro de desplazamiento. Luego, en cada pulso de la se\u00f1al SCK (generada por el m\u00e1ster) se desplaza una posici\u00f3n el contenido de \u00e9ste registro, enviando as\u00ed por la l\u00ednea MOSI un bit. El esclavo hace el mismo desplazamiento, enviando a su vez un bit al master por la linea MISO. Ambos dispositivos usan el bit recibido como bit de relleno de su registro de desplazamiento. Este procedimiento contin\u00faa hasta que se hayan transmitido los 8 bits. Es configurable si se rellena por el bit m\u00e1s significativo (MSB) o menos significativo (LSB). SPI tiene esencialmente dos modos de transmisi\u00f3n, ilustrados en la figura de abajo, que son: CPHA = 0: El slave puede poner el primer bit en MISO en cuanto es seleccionado Los bits son latcheados/capturados en flancos impares de SCK El shifter se desplaza en flancos pares de SCK , rellenando con el bit capturado y transmitiendo as\u00ed un nuevo bit CPHA = 1: El slave necesita un flanco en SCK para poner el primer bit en MISO Los bits son latcheados/capturados en flancos pares de SCK El shifter se desplaza en flancos impares de SCK , rellenando con el bit capturado y transmitiendo as\u00ed un nuevo bit Estos dos modos tienen a su vez dos variantes que determinan la polaridad de SCK : - CPOL = 0 : SCK activo a alta, inactivo a baja - CPOL = 1 : SCK activo a baja, inactivo a alta Driver SPI en Linux \u00b6 Linux proporciona un driver spi gen\u00e9rico, que expone controladores como dispositivos de caracteres ( /dev/spidev#.# ). Para realizar una transmisi\u00f3n, lo primero es abrir el fichero de dispositivo. Despu\u00e9s usaremos una serie de operaciones ioctl para configurar el modo de transmisi\u00f3n requerido por el dispositivo: SPI_IOC_RD_MODE , SPI_IOC_WR_MODE : recibe un puntero a byte para leer o escribir el modo de transmisi\u00f3n b\u00e1sico. Los valores v\u00e1lidos son: SPI_MODE_{0,1,2,3} SPI_IOC_RD_LSB_FIRST , SPI_IOC_WR_LSB_FIRST : recibe un puntero a byte para leer o escribir el bit order. Un valor 0 es MSB first y cualquier otro valor es LSB first. SPI_IOC_RD_BITS_PER_WORD , SPI_IOC_WR_BITS_PER_WORD : recibe un puntero a byte, para leer o escribir el n\u00famero de bits en cada palabra spi transferida. Un valor 0 significa 8 bits. PI_IOC_RD_MAX_SPEED_HZ , SPI_IOC_WR_MAX_SPEED_HZ : recibe un puntero a uint32 para leer o escribir la frecuencia de transmisi\u00f3n. Una vez configurado el modo de transmisi\u00f3n, usaremos una operaci\u00f3n SPI_IOC_MESSAGE(n) para realizar env\u00edo y recepci\u00f3n simult\u00e1neos. Esta operaci\u00f3n recibe un puntero a un array de n elementos del tipo struct spi_ioc_transfer : struct spi_ioc_transfer { __u64 tx_buf ; // direcci\u00f3n del buffer para transmision __u64 rx_buf ; // direcci\u00f3n del buffer para recepci\u00f3n __u32 len ; // longitud de tx_buf y rx_buf __u32 speed_hz ; // velocidad para esta transferencia __u16 delay_usecs ; // retardo para subir nCS __u8 bits_per_word ; // bits por palabra __u8 cs_change ; // subir nCS entre medias __u8 tx_nbits ; // num de bits a transmitir __u8 rx_nbits ; // num de bits a recibir __u8 word_delay_usecs ; // retardo entre palabras __u8 pad ; }; Ejemplos: MCP3008 y DAC MCP4911 \u00b6 El MCP3008 es un ADC de 10 bits y 8 canales, que pueden ser utilizados en modo diferencial o en modo independiente. Este ADC tiene un interfaz SPI. La placa BEE tiene montado uno de estos ADCs, que podemos conectar a la Raspberry Pi a trav\u00e9s de los jumpers en la tira de pines J2. La siguiente figura muestra un cronograma de una comunicaci\u00f3n SPI entre un microcontrolador y el ADC, extra\u00edda de la hoja de caracter\u00edsticas del MCP3008 ( datasheet ) proporcionada por el fabricante: El siguiente c\u00f3digo es un ejemplo de c\u00f3mo leer el ADC utilizando el driver SPI explicado arriba, siguiendo las directrices del cronograma: #define MCP3008_START 0x1 #define MCP3008_SIGL_DIFF (0x1 << 7) __u8 spi_mode = ( __u8 ) SPI_MODE_0 ; int channel = 0 ; struct spi_ioc_transfer xfer [ 1 ]; unsigned char buf [ 3 ]; int adcval ; fd = open ( \"/dev/spidev0.0\" , O_RDWR ); ioctl ( fd , SPI_IOC_WR_MODE , & spi_mode ); memset ( xfer , 0 , sizeof xfer ); memset ( buf , 0 , sizeof buf ); buf [ 0 ] = MCP3008_START ; buf [ 1 ] = MCP3008_SIGL_DIFF | (( channel & 0x7 ) << 4 ); xfer [ 0 ]. tx_buf = ( __u64 ) buf ; xfer [ 0 ]. rx_buf = ( __u64 ) buf ; xfer [ 0 ]. len = sizeof buf ; xfer [ 0 ]. speed_hz = 1350000 ; //1.35 MHz ioctl ( fd , SPI_IOC_MESSAGE ( 1 ), xfer ); adcval = (( buf [ 1 ] & 0x3 ) << 8 ) | buf [ 2 ]; El programa adc_read.c lee una vez por segundo el valor de uno de los canales del adc de la placa BEE y muestra la tensi\u00f3n correspondiente a la medida por la salida est\u00e1ndar. Para usarlo podemos ejecutar el programa con los siguientes par\u00e1metros: . / adc_read / dev / spidev0 .0 0 3300 - /dev/spidev0.0 : es el controlador spi a usar - 0 : el canal del adc que leer - 3300 : la tensi\u00f3n vdd que alimenta al ADC en mV. El programa dac_follow_adc.c es similar al anterior, pero adem\u00e1s copia en el dac el valor le\u00eddo del adc, de modo que la salida del dac va siguiendo la entrada del adc. Para comprobar el funcionamiento de estos programas deben conectarse una serie de jumpers en la BEE: Jumpers en la tira de pines J2 Jumpers para selecci\u00f3n de VDD y VCC en J14 y J18 (escoger 3.3V) Jumper de tensi\u00f3n de referencia del ADC en J11. Jumper de tensi\u00f3n de referencia del DAC (no numerado). Jumper J9 de nLDAC.","title":"Control de dispositivos SPI"},{"location":"spi_linux/#control-de-dispositivos-spi","text":"En esta pr\u00e1ctica vamos a ver c\u00f3mo podemos manejar dispositivos conectados al controlador spi utilizando el driver spi de Linux. Comenzaremos recordando brevemente el funcionamiento del bus spi, ya que es necesario entenrlo para manejar el driver y los dispositivos. Al final probaremos lo que hemos aprendido utilizando el ADC incluido en la placa BEE.","title":"Control de dispositivos SPI"},{"location":"spi_linux/#bus-spi","text":"El Serial Peripheral Interface (SPI) es un bus serie s\u00edncrono y bidirccional muy utilizado en sistemas empotrados para conectar un microcontrolador a sus perif\u00e9ricos. Puede trabajar con frecuencias de 1 a 20 MHz, pero s\u00f3lo un dispositivo puede ser m\u00e1ster del bus. El bus utiliza 4 l\u00edneas m\u00e1s una tierra com\u00fan: Master out/Slave in ( MOSI , SDI ) Master in/Slave out ( MISO , SDO ) Serial clock ( SCK ) Slave Select ( nSS ): activo a baja Los dispositivos SPI pueden funcionar en dos modos Master : es el que puede iniciar y controlar una transferencia Slave : es el que se comunica con un master que le active El m\u00e1ster selecciona al slave con el que quiere comunicarse activando su se\u00f1al SS (poni\u00e9ndola a 0). Si un dispositivo puede hacer de m\u00e1ster o slave, puede configurar el pin nSS como entrada para ver si otro m\u00f3dulo est\u00e1 actuando como master. Si se detecta otro m\u00e1ster el dispositivo debe configurarse en modo slave. En SPI el env\u00edo y la recepci\u00f3n suceden simult\u00e1neamente, el bus funciona como un registro de desplazamiento circular distribuido. Se suele utilizar un sistema de doble buffer. El master y el slave tienen un registro de datos de 8 bits utilizado por el software para escribir el dato a transmitir o leer el dato recibido. Tambi\u00e9n disponen de un registro de desplazamiento de 8 bits. El procediminto de transmisi\u00f3n se ilustra en la figura de abajo. Pongamos por ejemplo que el master quiere env\u00edar un byte a un esclavo. Para transmitir se empieza copiando el dato en el registro de datos, que despu\u00e9s se copia en el registro de desplazamiento. Luego, en cada pulso de la se\u00f1al SCK (generada por el m\u00e1ster) se desplaza una posici\u00f3n el contenido de \u00e9ste registro, enviando as\u00ed por la l\u00ednea MOSI un bit. El esclavo hace el mismo desplazamiento, enviando a su vez un bit al master por la linea MISO. Ambos dispositivos usan el bit recibido como bit de relleno de su registro de desplazamiento. Este procedimiento contin\u00faa hasta que se hayan transmitido los 8 bits. Es configurable si se rellena por el bit m\u00e1s significativo (MSB) o menos significativo (LSB). SPI tiene esencialmente dos modos de transmisi\u00f3n, ilustrados en la figura de abajo, que son: CPHA = 0: El slave puede poner el primer bit en MISO en cuanto es seleccionado Los bits son latcheados/capturados en flancos impares de SCK El shifter se desplaza en flancos pares de SCK , rellenando con el bit capturado y transmitiendo as\u00ed un nuevo bit CPHA = 1: El slave necesita un flanco en SCK para poner el primer bit en MISO Los bits son latcheados/capturados en flancos pares de SCK El shifter se desplaza en flancos impares de SCK , rellenando con el bit capturado y transmitiendo as\u00ed un nuevo bit Estos dos modos tienen a su vez dos variantes que determinan la polaridad de SCK : - CPOL = 0 : SCK activo a alta, inactivo a baja - CPOL = 1 : SCK activo a baja, inactivo a alta","title":"Bus SPI"},{"location":"spi_linux/#driver-spi-en-linux","text":"Linux proporciona un driver spi gen\u00e9rico, que expone controladores como dispositivos de caracteres ( /dev/spidev#.# ). Para realizar una transmisi\u00f3n, lo primero es abrir el fichero de dispositivo. Despu\u00e9s usaremos una serie de operaciones ioctl para configurar el modo de transmisi\u00f3n requerido por el dispositivo: SPI_IOC_RD_MODE , SPI_IOC_WR_MODE : recibe un puntero a byte para leer o escribir el modo de transmisi\u00f3n b\u00e1sico. Los valores v\u00e1lidos son: SPI_MODE_{0,1,2,3} SPI_IOC_RD_LSB_FIRST , SPI_IOC_WR_LSB_FIRST : recibe un puntero a byte para leer o escribir el bit order. Un valor 0 es MSB first y cualquier otro valor es LSB first. SPI_IOC_RD_BITS_PER_WORD , SPI_IOC_WR_BITS_PER_WORD : recibe un puntero a byte, para leer o escribir el n\u00famero de bits en cada palabra spi transferida. Un valor 0 significa 8 bits. PI_IOC_RD_MAX_SPEED_HZ , SPI_IOC_WR_MAX_SPEED_HZ : recibe un puntero a uint32 para leer o escribir la frecuencia de transmisi\u00f3n. Una vez configurado el modo de transmisi\u00f3n, usaremos una operaci\u00f3n SPI_IOC_MESSAGE(n) para realizar env\u00edo y recepci\u00f3n simult\u00e1neos. Esta operaci\u00f3n recibe un puntero a un array de n elementos del tipo struct spi_ioc_transfer : struct spi_ioc_transfer { __u64 tx_buf ; // direcci\u00f3n del buffer para transmision __u64 rx_buf ; // direcci\u00f3n del buffer para recepci\u00f3n __u32 len ; // longitud de tx_buf y rx_buf __u32 speed_hz ; // velocidad para esta transferencia __u16 delay_usecs ; // retardo para subir nCS __u8 bits_per_word ; // bits por palabra __u8 cs_change ; // subir nCS entre medias __u8 tx_nbits ; // num de bits a transmitir __u8 rx_nbits ; // num de bits a recibir __u8 word_delay_usecs ; // retardo entre palabras __u8 pad ; };","title":"Driver SPI en Linux"},{"location":"spi_linux/#ejemplos-mcp3008-y-dac-mcp4911","text":"El MCP3008 es un ADC de 10 bits y 8 canales, que pueden ser utilizados en modo diferencial o en modo independiente. Este ADC tiene un interfaz SPI. La placa BEE tiene montado uno de estos ADCs, que podemos conectar a la Raspberry Pi a trav\u00e9s de los jumpers en la tira de pines J2. La siguiente figura muestra un cronograma de una comunicaci\u00f3n SPI entre un microcontrolador y el ADC, extra\u00edda de la hoja de caracter\u00edsticas del MCP3008 ( datasheet ) proporcionada por el fabricante: El siguiente c\u00f3digo es un ejemplo de c\u00f3mo leer el ADC utilizando el driver SPI explicado arriba, siguiendo las directrices del cronograma: #define MCP3008_START 0x1 #define MCP3008_SIGL_DIFF (0x1 << 7) __u8 spi_mode = ( __u8 ) SPI_MODE_0 ; int channel = 0 ; struct spi_ioc_transfer xfer [ 1 ]; unsigned char buf [ 3 ]; int adcval ; fd = open ( \"/dev/spidev0.0\" , O_RDWR ); ioctl ( fd , SPI_IOC_WR_MODE , & spi_mode ); memset ( xfer , 0 , sizeof xfer ); memset ( buf , 0 , sizeof buf ); buf [ 0 ] = MCP3008_START ; buf [ 1 ] = MCP3008_SIGL_DIFF | (( channel & 0x7 ) << 4 ); xfer [ 0 ]. tx_buf = ( __u64 ) buf ; xfer [ 0 ]. rx_buf = ( __u64 ) buf ; xfer [ 0 ]. len = sizeof buf ; xfer [ 0 ]. speed_hz = 1350000 ; //1.35 MHz ioctl ( fd , SPI_IOC_MESSAGE ( 1 ), xfer ); adcval = (( buf [ 1 ] & 0x3 ) << 8 ) | buf [ 2 ]; El programa adc_read.c lee una vez por segundo el valor de uno de los canales del adc de la placa BEE y muestra la tensi\u00f3n correspondiente a la medida por la salida est\u00e1ndar. Para usarlo podemos ejecutar el programa con los siguientes par\u00e1metros: . / adc_read / dev / spidev0 .0 0 3300 - /dev/spidev0.0 : es el controlador spi a usar - 0 : el canal del adc que leer - 3300 : la tensi\u00f3n vdd que alimenta al ADC en mV. El programa dac_follow_adc.c es similar al anterior, pero adem\u00e1s copia en el dac el valor le\u00eddo del adc, de modo que la salida del dac va siguiendo la entrada del adc. Para comprobar el funcionamiento de estos programas deben conectarse una serie de jumpers en la BEE: Jumpers en la tira de pines J2 Jumpers para selecci\u00f3n de VDD y VCC en J14 y J18 (escoger 3.3V) Jumper de tensi\u00f3n de referencia del ADC en J11. Jumper de tensi\u00f3n de referencia del DAC (no numerado). Jumper J9 de nLDAC.","title":"Ejemplos: MCP3008 y DAC MCP4911"}]}