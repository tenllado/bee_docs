<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Prácticas de Robótica - BEE Docs</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Pr\u00e1cticas de Rob\u00f3tica";
        var mkdocs_page_input_path = "robotica/index.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> BEE Docs
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Placa de expansión BEE</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Prácticas</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../gpio_linux/">Control GPIO en Linux</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../pwm_linux/">Control PWM en Linux</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../spi_linux/">Control de dispositivos SPI</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../i2c_linux/">Control de dispositivos I2C</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../control_servomotores/">Control de servomotores con PWM</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Prácticas de Robótica</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#motores-parte-1">Motores. Parte 1</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#objetivos">Objetivos</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#desarrollo-de-la-practica">Desarrollo de la práctica</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#primer-contacto-con-la-raspberry">Primer contacto con la Raspberry</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#tarea-1-conocer-el-entorno-de-la-raspberry">Tarea 1: Conocer el entorno de la Raspberry</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#tarea-2-hola-mundo-hardware">Tarea 2: "Hola Mundo" hardware</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#control-de-motores-de-rotacion-continua">Control de motores de rotación continua</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#tarea-3-control-por-pwm-de-servomotres-usando-c">Tarea 3: Control por pwm de servomotres usando C++}</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#referencias-utiles">Referencias útiles</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#parte-2">Parte 2</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#control-en-lazo-abierto">Control en lazo abierto</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#movimiento-en-linea-recta">Movimiento en línea recta.</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#giro-en-lazo-abierto">Giro en lazo abierto</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#movimiento-complejo-del-robot">Movimiento complejo del robot</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#movimientos-complejos">Movimientos complejos</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#sensores">Sensores</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#1-objetivos">1. Objetivos</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#2-desarrollo-de-la-practica">2. Desarrollo de la práctica</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#21-lectura-de-sensores-digitales">2.1 Lectura de sensores digitales</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#22-sensores-analogicos">2.2 Sensores analógicos</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#221-ldr-light-dependent-resistor">2.2.1 LDR (Light-Dependent Resistor)</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">BEE Docs</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Prácticas</li>
      <li class="breadcrumb-item active">Prácticas de Robótica</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="practicas-de-robotica">Prácticas de Robótica</h1>
<h2 id="motores-parte-1">Motores. Parte 1</h2>
<h3 id="objetivos">Objetivos</h3>
<ol>
<li>Familiarizarse con la Raspberry Pi y su entorno.</li>
<li>Generación de una señal para control de un motor paso a paso.</li>
<li>Generación de una señal (PWM) para control de un servomotor.</li>
</ol>
<p>La finalidad de esta práctica es aprender a generar señales en el orden adecuado para mover un motor paso a paso y aplicar una señal de PWM para controlar un motor de continua (servomotor de rotación continua). Estos tipos de motores son muy utilizados en Robótica. En concreto, el servo de rotación continua se utilizará para controlar un robot móvil sencillo.</p>
<blockquote>
<p><strong>Nota:</strong> Antes de ejecutar un programa, verifique con su profesor que las conexiones están realizadas correctamente.</p>
</blockquote>
<hr />
<h2 id="desarrollo-de-la-practica">Desarrollo de la práctica</h2>
<h3 id="primer-contacto-con-la-raspberry">Primer contacto con la Raspberry</h3>
<p>Para familiarizarse con el entorno de programación de la Raspberry Pi, primero vamos a realizar dos tareas sencillas.</p>
<h4 id="tarea-1-conocer-el-entorno-de-la-raspberry">Tarea 1: Conocer el entorno de la Raspberry</h4>
<p>Alimenta la Raspberry Pi y conecta el portátil a ella (vea cómo conectar con la Raspberry Pi). Una vez conectado, cambia al directorio <code>wiringPi/examples</code>. Allí hay un archivo denominado <code>blink.c</code>.</p>
<p>Lo que haremos será comprobar que está funcionando correctamente la Raspberry: compila el programa escribiendo:</p>
<pre><code>bash
make blink
</code></pre>
<p>Observa que se crea un ejecutable.</p>
<h4 id="tarea-2-hola-mundo-hardware">Tarea 2: "Hola Mundo" hardware</h4>
<p>El objetivo de esta tarea es programar el parpadeo de un LED. Para ello, en primer lugar, habrá que realizar el montaje indicado en la siguiente figura:</p>
<p><img alt="Conexiones LED" src="figs/ConexionesLED.png" /></p>
<p>Conecta el LED al Pin GPIO 17 (el Wiring Pin 0). La resistencia utilizada es de 220 Ω.</p>
<p>Dependiendo de la biblioteca software que usemos para programar la Raspberry, la numeración de los pines cambia. En la siguiente figura pueden verse las distintas numeraciones según el conector físico de 40 pines. La placa de conexiones Bee 2.0 sigue la numeración BCM. De este modo, el pin serigrafiado en la placa como B17 corresponde al pin físico 11 o al WiringPi 0.</p>
<p><img alt="Pinout Raspberry Pi" src="figs/raspberrypi-gpio-wiringpi-pinout.png" /></p>
<p>Si ahora ejecutamos el programa anterior:</p>
<pre><code>sudo ./blink
</code></pre>
<p>Se verá que el LED parpadea.</p>
<p><strong>Edita el programa, cambia la frecuencia de parpadeo, vuelve a compilarlo y observa que su frecuencia cambia.</strong></p>
<p>También puede conectarse el LED en otro Pin de la Raspberry, pero en ese caso hay que cambiar el pin asignado en el archivo blink.c:</p>
<pre><code>#define 0 LED
</code></pre>
<h3 id="control-de-motores-de-rotacion-continua">Control de motores de rotación continua</h3>
<p>El servomotor no debe ser alimentado directamente por la Raspberry Pi porque en caso de que requiera realizar un esfuerzo grande puede requerir un consumo que no puede proporcionar la Raspberry. La alimentación del servo se realizará externamente y SOLO el pin de control del motor (PWM) se conectará a la Raspberry.</p>
<p><img alt="Servomotor" src="figs/Servomotor.png" /></p>
<h4 id="tarea-3-control-por-pwm-de-servomotres-usando-c">Tarea 3: Control por pwm de servomotres usando C++}</h4>
<p>Para controlar los motores por pwm en C o C++ se puede usar la biblioteca WiringPi. Al igual que en python conviene tener en cuenta los siguientes aspectos:
- Es necesario incluir la librería en el código:</p>
<pre><code>#include &lt;wiringPi.h&gt;
</code></pre>
<ul>
<li>La biblioteca WiringPi usa otra numeración de pines, como se indicaba anteriormente. Los pines correspondientes según la numeración WiringPi a los <em>pwm_0</em> y <em>pwm_1</em> son:</li>
</ul>
<pre><code>#define PinMotor0 23 //pwm_1
#define PinMotor1 26 //for pwm_0
</code></pre>
<ul>
<li>Es necesario inicializar la librería</li>
<li>Hay que configurar el pin como un pin pwm de salida</li>
<li>Para dar un valor de pwm a la salida correspondiente basta con usar el comando</li>
</ul>
<p><strong>Establece el rango de valores de PWM sirven para girar en un sentido u otro. Con este rango podrás escoger un valor adecuado para usarlo en el futuro control del robot.</strong></p>
<h3 id="referencias-utiles">Referencias útiles</h3>
<ul>
<li><a href="https://www.digikey.es/en/maker/blogs/2021/how-to-control-servo-motors-with-a-raspberry-pi}{Control de servomotor usando Pyhton 1">Control de servomotor usando Python 1</a></li>
<li><a href="https://www.learnrobotics.org/blog/raspberry-pi-servo-motor/}{Control de servomotor usando Pyhton 2">Control de servomotor usando Python 2</a></li>
<li><a href="http://wiringpi.com/reference/raspberry-pi-specifics/">Referencia de WiringPi</a></li>
<li><a href="https://learn.adafruit.com/adafruits-raspberry-pi-lesson-8-using-a-servo-motor/software"> Utilidad gpio de Adafruit</a></li>
</ul>
<h2 id="parte-2">Parte 2</h2>
<p>La finalidad de esta práctica es aplicar una señal de PWM para
controlar los actuadores (servomotores de rotación continua) de un robot móvil sencillo.
Una vez que se mueven adecuadamente los dos motores del robot de tipo diferencial
construido, se realizarán varios movimientos para mostrar que se es capaz de controlar
adecuadamente el robot.</p>
<p>El robot utilizará dos servos de rotación contínua. Aseguraos de que están alineados adecuadamente y las ruedas están fijadas para que el robot pueda moverse en línea recta. Si el robot tiene una deriva alta, su control será más complejo e impedirá un correcto funcionamiento en futuras prácticas en las que se utilizará.</p>
<ol>
<li>Colocad sobre la plataforma el circuito anterior y la Rasp Pi para mover los motores a la vez. </li>
<li>Si el diseño y sujeción de los motores es el adecuado debe ser capaz de moverse en línea recta sin desviarse. Como mínimo debería recorrer un tramo de unos 2 m con una desviación máxima de un 10% hacia cualquiera de los dos lados.</li>
</ol>
<h3 id="control-en-lazo-abierto">Control en lazo abierto</h3>
<p>Una vez que se ha comprobado que sabe crear un programa utilizando la librería wiringPi, se ha configurado y calibrado los servos de las ruedas del robot y movido el robot de forma básica para verificar que la posición de los motores es la adecuada, el objetivo será crear un programa que mueva el robot una distancia y ángulo deseados. Como el robot no tiene realimentación de la posición cualquier error, deslizamiento o desviación no se detectará.</p>
<p>Para mover el robot una distancia deseada, mediremos la velocidad con que se desplaza el robot (velocidad de las ruedas) y moveremos el robot (siempre a la misma velocidad) durante el tiempo que corresponda para la distancia deseada. Es decir:</p>
<ol>
<li>
<p>Poned las ruedas a girar y registrad el tiempo que tarda en dar 10 vueltas. Ese tiempo será T_i</p>
</li>
<li>
<p>Para obtener la velocidad de cada rueda por segundo bastará con realizar v_i=T_i/10 vueltas por segundo.</p>
</li>
<li>
<p>Es necesario medir el radio de las ruedas para poder calcular la longitud de su circunferencia y así saber la distancia que recorre el robot en una vuelta.</p>
</li>
<li>
<p>Con estos datos ya se puede pasar una distancia recorrida por una rueda  a número de vueltas. Con la velocidad de la rueda que ya se ha calculado se puede saber el tiempo que ha de estar girando la rueda.</p>
</li>
<li>
<p>Este tiempo es que se debe esperar antes de parar los motores para que el robot mueva las ruedas la distancia deseada.</p>
</li>
</ol>
<p>Con los cálculos anteriores puede obtener el tiempo para que cada rueda gire la distancia  deseada. Esta distancia se obtendrá de las ecuaciones y  del modelo de un robot diferencial, donde la distancia a desplazarse (o el ángulo que queremos que gire) es la proporcionada por el usuario.</p>
<h3 id="movimiento-en-linea-recta">Movimiento en línea recta.</h3>
<p>Programad  el robot para que se mueva una distancia determinada a partir del tiempo que está en funcionamiento los motores (control en lazo abierto). Probadlo con la distancia del apartado anterior y ved si es capaz de parar a los 2 m.</p>
<h3 id="giro-en-lazo-abierto">Giro en lazo abierto</h3>
<p>Programad el robot para que gire el número de ángulos determinado. Probadlo con 90 grados.</p>
<h3 id="movimiento-complejo-del-robot">Movimiento complejo del robot</h3>
<p>A continuación realizaremos, utilizando las ecuaciones anteriores, un movimiento algo más complejo donde se combinen simultáneamente movimientos rectos y giros. El movimiento que el robot realizará será un rectángulo.</p>
<h3 id="movimientos-complejos">Movimientos complejos</h3>
<p>El robot debería quedar en la misma posición que al principio. Estimar el error cometido. ¿Está dentro de una bola de error de radio 10 cm?</p>
<h2 id="sensores">Sensores</h2>
<h2 id="1-objetivos">1. Objetivos</h2>
<ol>
<li>Lectura de sensores digitales con la RaspberryPi. </li>
<li>Lectura de sensores analógicos con la RaspberryPi. </li>
<li>Integración de sensores en el robot </li>
</ol>
<p>La finalidad de esta práctica es que el alumno utilice distintos sensores típicos en un robot móvil. Se utilizarán:</p>
<ul>
<li><strong>Interruptor</strong>: señal binaria (todo o nada) </li>
<li><strong>LDR</strong>: señal de voltaje variable (analógica, requiere conversor A/D) </li>
<li><strong>Sensor de ultrasonidos</strong>: señal procesada, salida digital</li>
</ul>
<blockquote>
<p><strong>Nota:</strong> Antes de ejecutar un programa verifica con tu profesor que las conexiones están realizadas correctamente.</p>
</blockquote>
<hr />
<h3 id="2-desarrollo-de-la-practica">2. Desarrollo de la práctica</h3>
<h4 id="21-lectura-de-sensores-digitales">2.1 Lectura de sensores digitales</h4>
<h5 id="211-botones">2.1.1 Botones</h5>
<p>Un sensor muy utilizado en los robots son los sensores de contacto. Estos pueden ser de distintos tipos siendo los más utilizados los de botón y los de palanca. Con ellos se reconoce la presencia de un objeto ubicado en la línea de recorrido de un dispositivo. También se pueden emplear (los botones) típicamente como interfaz con el usuario. Su simplicidad de construcción y uso los hace muy empleados en robótica.</p>
<p>En esta práctica se van a usar los tres botones que están integrados en la placa Bee 2.0. </p>
<p><img alt="Botones en la placa Bee" src="figs/Bee2BotonesLEDs.png" /></p>
<p>Los botones integrados en la placa Bee 2.0 tienen tres patillas: 
- GND 
- 3.3 V (a través de resistencia de 10kΩ) 
- Pin del conector J4 </p>
<p>Los LEDs están conectados a GND y al conector J4 a través de una resistencia de 220Ω.</p>
<p><img alt="Esquemático de la conexión leds y botones en la placa Bee" src="figs/ConexionBotonesLEDs.png" /></p>
<p>Para poder usar los botones simplemente tendremos que unir con un cable la patilla libre del
botón (aquella que está conectada con uno de los pines del conector J4 a una de las entradas
digitales de la RaspberryPi (por ejemplo la entrada BCM0)</p>
<p><strong>Tarea 1:</strong> 
Conecta un botón y un LED a pines de entrada/salida digital de la RaspberryPi. </p>
<p>Programa: encender LED si el botón está pulsado, apagar si no.</p>
<p><strong>Funciones WiringPi:</strong></p>
<pre><code>c
digitalRead(pinToRead);
digitalWrite(pinToWrite, value); // value = 1 (alto), 0 (bajo)
</code></pre>
<p>Configura los pines como <code>INPUT</code> o <code>OUTPUT</code>.</p>
<hr />
<h5 id="212-sensor-de-infrarrojos-cny70">2.1.2 Sensor de infrarrojos CNY70</h5>
<p>El CNY70 es un sensor óptico reflexivo de infrarrojos de corto alcance (de 0, 3 a 10 mm.) basado en un diodo emisor de luz infrarroja y un receptor formado por un fototransistor, ambos apuntando en la misma dirección, y cuyo funcionamiento se basa en la capacidad de reflexión del objeto, y la detección del rayo reflectado por el receptor (sensor óptico de proximidad).</p>
<p><img alt="Sensor CNY70" src="figs/CNY70.png" /></p>
<p>Al tener un alcance tan corto, no se suele utilizar para detectar obstáculos, sino como sensor de
proximidad, componente de lectura para un encoder, como elemento para detección y seguimiento
de líneas u otras aplicaciones similares. Podemos usar el CNY70 de dos formas:</p>
<ol>
<li>
<p>Como un sensor digital que nos proporciona un 0 o un 1 en caso de que haya objeto o en para
distancias de entre [0, 10] mm.</p>
</li>
<li>
<p>Como un sensor analógico, midiendo la señal que proporciona el sensor dependiendo de la
situación que se desee.</p>
</li>
</ol>
<p>Vamos a emplearlo en primer lugar como sensor de proximidad, lo que quiere decir que será un
sensor digital que nos informará si hay objeto o no únicamente.
Para poder usar este sensor hay que tener en cuenta dos cosas:</p>
<ul>
<li>Polarizar LED emisor con resistencia a GND </li>
<li>Usa divisor de tensión si trabajas con Raspberry Pi (3.3V)</li>
</ul>
<p><img alt="Conexión del sensor CNY70" src="figs/ConexionCNY70.png" /></p>
<p><strong>Tarea 2:</strong> 
Conecta sensor a entrada digital. 
Crea un <code>for</code> con <code>delay</code> (500 o 1000 ms) y muestra en pantalla la lectura.</p>
<p><strong>Tarea 3:</strong> 
Prueba el rango de detección del sensor.</p>
<p><strong>Tarea 4:</strong> 
Usa objetos de diferentes colores. ¿Detecta todos? ¿Por qué?</p>
<hr />
<h4 id="22-sensores-analogicos">2.2 Sensores analógicos</h4>
<p>Existen sensores que proporcionan una señal analógica (normalmente una señal de voltaje) que es
proporcional a la medida que queremos leer. Este es el caso de muchos sensores de temperatura,
de presión, de humedad, de luz, etc.</p>
<p>Las RaspberryPi 3 no tiene entradas analógicas, de manera que necesitaremos usar un conversor
AD para pasar la señal analógica a la digital. La placa Bee v2.0 tiene integrado un conversor AD, el MCP3008 que permite conectarle una señal analógica y transformarla en una digital que la
Raspberry puede leer.</p>
<hr />
<h4 id="221-ldr-light-dependent-resistor">2.2.1 LDR (Light-Dependent Resistor)</h4>
<p>Un LDR (Light-Dependent Resistor) es un material que varía su valor de resistencia eléctrica dependiendo de la cantidad de luz que incide sobre él. Se le llama, también, fotorresistor o fotorresistencia. El valor de resistencia eléctrica de un LDR es bajo cuando hay luz incidiendo en él (en algunos casos puede descender a tan bajo como 50Ω ) y muy alto cuando está a oscuras (puede ser de varios M Ω).</p>
<p>Los LDR se fabrican con un cristal semiconductor fotosensible como el sulfuro de cadmio (CdS).
Estas celdas son sensibles a un rango amplio de frecuencias lumínicas, desde la luz infrarroja,
pasando por la luz visible, y hasta la ultravioleta.</p>
<p>La variación de valor resistivo de un LDR tiene cierto retardo, que es diferente si se pasa de
oscuro a iluminado o de iluminado a oscuro. Por esta razón un LDR no se puede utilizar en algunas aplicaciones, en especial en aquellas en que la señal luminosa varía con rapidez. El tiempo de respuesta típico de un LDR está en el orden de una décima de segundo. La lentitud relativa del cambio es una ventaja en algunos casos, porque así se filtran variaciones rápidas de iluminación que podrían hacer inestable un sensor (por ejemplo, cuando está iluminado por un tubo fluorescente alimentado por corriente alterna), En otras aplicaciones (como la detección de luminosidad para saber si es de día o es de noche) la lentitud de la detección no es importante.</p>
<p>Para ver cómo cambia la resistencia con la luz, podemos hacer un circuito como el de la figura, donde el punto de lectura del voltaje se realiza en (1). Estos tipos de sensores son muy dependientes de la iluminación ambiente, por lo que es necesario protegerlos de la luz o realizar una calibración para tener en cuenta la iluminación actual que sería previa a su utilización, periódicamente, o cuando cambien las condiciones de trabajo.</p>
<p><img alt="LDR" src="figs/LDR.png" /></p>
<p>Para conectarlo a la Raspberry, utilizaremos como alimentación los 3.3 voltios del GPIO para
Vdc. En cuanto a la lectura del voltaje en el punto (1), dado que es una señal analógica, necesitaremos un conversor A/D. Debido a que la Raspberry Pi no dispone de ninguno, en nuestro caso, utilizaremos el integrado MCP3008.</p>
<p>El MCP3008 es un convertidor de analógico a digital, de 8 canales de 10 bits (conversor AD
o ADC). Es barato, fácil de conectar y no requiere ningún componente adicional. Se utiliza el
protocolo de bus SPI que está soportado por el GPIO de la Raspberry Pi y por tanto puede utilizarse también con la librería WiringPi.</p>
<p>Como puede verse en la figura los pines del lado derecho del MCP3008 son las entradas
analógicas (los 8 canales analógicos), AGND y DGND son la tierra analógica y digital, VDD la
alimentación del integrado y VREF el voltaje de referencia de la entrada analógica. Los pines 10-14 (CS,Din,Dout,Clk) corresponden a los pines del protocolo serie SPI por donde se lee la conversión del voltaje. Para conocer el voltaje en un canal se utilizará la fórmula:</p>
<p><strong>Fórmula:</strong></p>
<pre><code class="language-math">V_{canal} = (LecturaSPI / 1024) * Vref
</code></pre>
<p><img alt="Conversor" src="figs/Bee2-conversor.png" /></p>
<p>La placa Bee v2.0 tiene integrado el conversor MCP3008, figura 8. Para emplearlo hay que:</p>
<ul>
<li>
<p>Unir con un jumper los pines MOSI, MISO, SCLK y CE0 ADC del conector J2 con los B10, B9
B11 y B8 del mismo conector.</p>
</li>
<li>
<p>Unir con un jumper los dos pines del conector J11</p>
</li>
<li>
<p>Unir con un jumper los pines Vcc y 3.3 del conector J18</p>
</li>
<li>Unir con un jumper los pines Vdd y 3.3 del conector J14</li>
</ul>
<p>Una vez hecho esto, ya se puede conectar la salida analógica del sensor (con la resistencia R
adecuada, que puede usarse de la red de polarización) a una de las entradas del conversor A/D</p>
<p><strong>Cargar drivers SPI:</strong></p>
<pre><code>bash
gpio load spi
</code></pre>
<p><strong>Código base (conversor.c):</strong> 
<a href="https://osoyoo.com/2017/06/29/raspberry-pi-mcp3008/">https://osoyoo.com/2017/06/29/raspberry-pi-mcp3008/</a></p>
<hr />
<p><strong>Tarea 5:</strong> 
Lee y muestra el voltaje del LDR.</p>
<p><strong>Tarea 6:</strong> 
Observa efecto de luz ambiente. ¿Cómo afecta a la medida? 
¿Cómo usarlo para encender una bombilla si baja la luz?</p>
<p><strong>Tarea 7:</strong> 
Comprueba variación con distintas fuentes de luz.</p>
<p><strong>Tarea 8:</strong> 
¿Cómo construirías un robot que siga una fuente de luz (como una linterna)?</p>
<hr />
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../control_servomotores/" class="btn btn-neutral float-left" title="Control de servomotores con PWM"><span class="icon icon-circle-arrow-left"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../control_servomotores/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
