{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Placa de expansi\u00f3n BEE Descripci\u00f3n general La BEE es una placa de expansi\u00f3n, dise\u00f1ada inicialmente para la primera versi\u00f3n de la Raspberry Pi , pero que pude ser utilizada con cualquiera de las versiones de este computador de una sola placa . Este complemento convierte a la Raspberry Pi en una suerte de entrenador econ\u00f3mico para estudiar distintas tem\u00e1ticas de varias titulaciones universitarias del \u00e1mbito de las TIC y la Electr\u00f3nica. Este equipo se ha utilizado con gran \u00e9xito para montar los puestos de laboratorio para varias asignaturas de distintas titulaciones del Departamento de Arquitectura de Computadores y Autom\u00e1tica de la Universidad Complutense de Madrid, limitando tanto el precio que el Departamento ha podido montar un puesto para cada estudiante, permitiendo que puedan llevarse a casa el material durante el curso para completar sus pr\u00e1cticas y/o profundizar en las materias implicadas. El uso de este material fue crucial para que los estudiantes pudi\u00e9sen realizar sus pr\u00e1cticas durante la pandemia de covid de 2019 y 2020. La placa BEE incorpora una serie de perif\u00e9ricos que son f\u00e1cilmente conectables a los pines GPIO de la raspberry pi. En lugar de proporcionar una conexi\u00f3n fija entre los perif\u00e9ricos y los GPIOS de del microcontrolador, es el usuario el que debe conectar cada uno de los perif\u00e9ricos a los pines deseados usando cables de puente dupont hembra-hembra o jumpers . Los pines de la raspberry pi se han dejado disponibles en distintas tiras de pines sobre la propia placa de expansi\u00f3n. En algunos casos se han colocado junto a los circuitos de algun perif\u00e9rico, debido a que la funcionalidad adicional de estos pines est\u00e1 relacionada con dicho perif\u00e9rico. Por ejemplo, los pines que proporcionan conexiones a los controladores hardware de PWM se han colocado junto al circuito del zumbador. Para esos casos la conexi\u00f3n entre el perif\u00e9rico y la raspberry pi puede hacerse de forma c\u00f3moda y sencilla usando jumpers. En todo momento se ha evitado que un pin pueda ser conectado a m\u00e1s de un dispositivo externo, para evitar cortocircuitos provocados por los estudiantes menos cuidadosos. Se han desarrollado hasta el momento dos versiones de la placa BEE. La primera versi\u00f3n (v1) es m\u00e1s peque\u00f1a y econ\u00f3mica, y contiene un conjunto m\u00e1s reducido de dispositivos pensados inicialmente para dar servicio a los laboratorios de un par de asignaturas del Grado de Ingenier\u00eda Electr\u00f3nica de Comunicaciones del Master de Nuevas Tecnolog\u00edas Electr\u00f3nicas y fot\u00f3nicas de la Facultad de CC. F\u00edsicas de la Universidad Complutense de Madrid. La segunda versi\u00f3n (v2) extiende el conjunto de dispositivos incluidos para ampliar el espectro de asignaturas que pueden sacar provecho de esta econ\u00f3mica y vers\u00e1til placa de expansi\u00f3n. Esta segunda versi\u00f3n ha empezado a utilizarse tambi\u00e9n en la Facultad de Inform\u00e1tica de la Universidad Complutense de Madrid en asignaturas de Rob\u00f3tica y Arquitectura Interna de Linux y Android. En ambas versiones, los pines etiquetados como Bx en la placa BEE, tanto en el esquem\u00e1tico como en la serigraf\u00eda sobre la propia pcb, se corresponden con los pines BCMx de la documentaci\u00f3n de Broadcom, tambi\u00e9n denotados como GPIOx en algunos sitios web, como por ejemplo en https://pinout.xyz/ . Los detalles de estos dos modelos se presentan en las pr\u00f3ximas secciones. BEE v1 La primera versi\u00f3n de la BEE incluye el siguiente conjunto b\u00e1sico de dispositivos: Un MCP3008. Se trata de un conversor anal\u00f3gico digital (ADC) de 10 bits con 8 canales. Su interfaz digital SPI puede ser conectada mediante 5 jumpers a los pines SPI de la Raspberry Pi por el canal CE0. Sockets para la conexi\u00f3n r\u00e1pida de sensores anal\u00f3gicos, que pueden ser conectados a las entradas de los canales del ADC mediante jumpers . Estos sensores pueden ser polarizados haciendo uso de la red de resistencias montada en la placa, escogi\u00e9ndose una alimentaci\u00f3n de 3.3 V o 5 V mediante un jumper . Un MCP4911. Se trata de un conversor digital anal\u00f3gico (DAC) de 10 bits, que tambi\u00e9n puede ser conectado al controlador SPI usando los mismos 5 jumpers , quedando conectado al canal CE1. 3 circuitos simples de pulsador, que pueden ser conectados a pines digitales de entrada del microcontrolador para recibir acciones de usuario. 3 circuitos simples de led polarizado, que pueden ser conectados a un pin GPIO del microntorlador para controlar el estado del led por software. Un conector para cables FTDI-232-R con conexi\u00f3n directa a los pines del puerto serie de la raspberry pi. Facilita la comunicaci\u00f3n serie desde un PC con la raspberry pi. Un conector para JTAG est\u00e1ndar de 20 pines, conectado a los pines de depuraci\u00f3n en circuito de la raspberry pi. 1 Zumbador piezoel\u00e9ctrico que puede ser conectado con jumpers a algunos de los pines pwm de la Raspberry PI. Estos dispositivos est\u00e1n incluidos para dar soporte al desarrollo de pr\u00e1cticas de las siguientes asignaturas del departamento de Arquitectura de Computadores y Autom\u00e1tica de la Universidad Complutense de Madrid: Estructura de Computadores: en la que se realizan pr\u00e1cticas de programaci\u00f3n de entrada salida bare-metal , usando pines digitales de entrada y salida, conectados a leds y pulsadores, manejo de puerto serie y conexi\u00f3n a dispositivos por SPI o I2C. Rob\u00f3tica: se utilizan sensores anal\u00f3gicos y digitales, ADC, DAC y controladores PWM. Rob\u00f3tica y Mecatr\u00f3nica: igual que en rob\u00f3tica, se usan sensores anal\u00f3gicos y digitales, ADC, DAC, motores, etc. Programaci\u00f3n de Nodos Sensores para Internet de las Cosas: se utilizan tambi\u00e9n sensores anal\u00f3gicos, temporizadores, controladores PWM, etc. Las siguientes im\u00e1genes muestran un modelo 3D de la BEE v1, una foto aislada de un montaje real de la placa y su conexi\u00f3n a la Raspberry Pi en el montaje utilizado el laboratorio del Grado de Ingenier\u00eda Electr\u00f3nica de Comunicaciones de la Universidad Complutense de Madrid: Como vemos, la BEE se conecta a la Raspberry Pi a trav\u00e9s de la tira de 2x20 pines J1, mediante un cable plano. La totalidad de los pines de la Raspberry quedan entonces accesibles al usuario a trav\u00e9s de otras tiras de pines. Los pines quedan distribuidos seg\u00fan su uso entre varias tiras de pines adicionales, algunas de ellas pr\u00f3ximas a los circuitos de perif\u00e9ricos que generalmente necesitar\u00e1n de dichos pines para su manejo y control. En estos casos la conexi\u00f3n entre el perif\u00e9rico y la raspberry pi se puede hacer de forma c\u00f3moda y sencilla utilizando jumpers. La siguiente figura muestra la disposici\u00f3n de las tiras de pines en la BEE v1, marcando en rojo las tiras que exponen los pines de la raspberry pi (etiquetados como Bx en la serigraf\u00eda). Como \u00fanica excepci\u00f3n, los pines B4, B22-B25 y B27, que deben usarse en el caso de realizar una depuraci\u00f3n en circuito con el controlador JTAG, est\u00e1n disponibles en la tira etiquetada en azul como JTAG. La siguiente figura muestra el esquem\u00e1tico de la primera versi\u00f3n de la placa BEE: Cada uno de los bloques de perif\u00e9ricos se explica y documenta m\u00e1s abajo, en las secciones correspondientes a cada uno de ellos. BEE v2 La segunda versi\u00f3n de la placa extiende los dispositivos incluidos para dar soporte a un mayor n\u00famero de asignaturas del Departamento de Arquitectura de Computadores y Autom\u00e1tica de la UCM, como por ejemplo Arquitectura Interna Linux y Android, d\u00f3nde se programan drivers para varios tipos de dispositivos en estos sistemas. Asimismo se incorpora una red de polarizaci\u00f3n mucho m\u00e1s vers\u00e1til, con el objetivo de facilitar la polarizaci\u00f3n de sensores anal\u00f3gicos que se quieran conectar a las entradas del ADC, proporcionando las resistencias de polarizaci\u00f3n m\u00e1s habituales, con posibilidad de combinarlas en serie o en paralelo, y microinterruptores para polarizar el conjunto a Gnd o Vcc. Concretamente, en esta versi\u00f3n de la placa se han a\u00f1adido a los dispositivos incluidos en la versi\u00f3n 1 la siguiente lista de perif\u00e9ricos: Un desplazador con buffer conectado a un display de 7 segmentos (con punto decimal), permite escribir en el display 7 segmentos desde la raspberry-pi usando pines gen\u00e9ricos de entrada y salida. Un led RGB polarizado, que puede ser operado desde la raspberry pi con pines gen\u00e9ricos de entrada salida. Una red de polarizaci\u00f3n de sensores, con micro interruptores y resistencias habituales para una polarizaci\u00f3n de sensores anal\u00f3gicos que quieran conectarse a las entradas del ADC. La siguiente imagen muestra un modelo 3D de la segunda iteraci\u00f3n de la placa: La siguiente figura muestra el esquem\u00e1tico de la primera versi\u00f3n de la placa BEE: Los bloques de perif\u00e9ricos se explican y documentan en las siguientes secciones. Alimentaci\u00f3n de perif\u00e9ricos Los perif\u00e9ricos con interfaz anal\u00f3gica (ADC y DAC) tienen una l\u00ednea de alimentaci\u00f3n separada del resto de componentes, Vdd, que puede ser conectada tanto a 3.3 V como a 5 V colocando un jumper en la tira de pines J14: Por ejemplo, si se van a manejar se\u00f1ales entre 0 y 3.3 V, nos interesar\u00e1 conectar Vdd a 3.3 V para usar los 10 bits del ADC para discretizar el rango de 0 a 3.3V, teniendo as\u00ed mayor precisi\u00f3n que si lo aliment\u00e1semos a 5 V. Del mismo modo, la tira J18 permite escoger 3.3 V o 5 V para la se\u00f1al Vcc, disponible para la polarizaci\u00f3n de sensores anal\u00f3gicos. Interruptores y leds La siguiente figura muestra el esquem\u00e1tico de este sencillo bloque de perif\u00e9ricos, que es com\u00fan para las dos versiones de la placa. Por un lado tenemos tres leds (D1-D3) con el c\u00e1todo conectado a GND. El \u00e1nodo de cada uno de ellos se conecta a una resistencia de polarizaci\u00f3n de 220 Ohmios, que tiene el otro terminal accesible en uno de los pines de la tira J4. Podemos as\u00ed usar un cable de puente dupont para conectar este terminal a un GPIO de la raspberry pi para controla por software el estado del led: si ponemos el pin a 1 (Vdd) pasar\u00e1 por el led una corriente de unos 7 mA ((3.3 - 1.8)/220 = 7 mA) y el led se encender\u00e1. Por otro lado, tenemos tres pulsadores de bot\u00f3n (SW1-SW3), con un terminal conectado a GND y el otro conectado a una resistencia que a su vez conecta a la alimentaci\u00f3n (3.3 V). El punto entre la resistencia y el pulsador se conecta a uno de los pines de la tira J4. Podemos conectar estos a un GPIO de la raspberry pi haciendo uso de nuevo de un cable dupont hembra-hembra. Si dicho GPIO se configura como entrada podremos usarlo para ver si el pulsador est\u00e1 pulsado (el valor le\u00eddo ser\u00e1 0) o sin pulsar (el valor le\u00eddo ser\u00e1 1). Siempre habr\u00e1 que tener en cuenta que en los cambios de estado se producir\u00e1n rebotes, debido principalmente a las oscilaciones mec\u00e1nicas del muelle incluido en el pulsador. Estos rebotes pueden ser filtrados con ayuda del controlador GPIO de la raspberry pi, y si es necesario, por software. Led RGB Este perif\u00e9rico s\u00f3lo est\u00e1 disponible en la BEE v2, su circuito se muestra a continuaci\u00f3n: Se trata de un led rgb , conectado en c\u00e1todo com\u00fan a tierra, mientras que los terminales de los 3 \u00e1nodos se conectan cada uno a una resistencia, cuyo otro terminal se expone a trav\u00e9s de la tira de pines J21. Podemos usar cables de puente dupont para conectar estos terminales a pines GPIO de la raspberry pi con el fin de controlar la intensidad de los canales Rojo Verde y Azul del led desde el microcontrolador (habitualmente generando se\u00f1ales PWM). Zumbador (Buzzer) Las dos versiones montan el mismo zumbador piezoel\u00e9ctrico ( datasheet ), pero el circuito completo cambia lig\u00e9ramente de una verisi\u00f3n a la otra. La siguiente figura muestra el esquem\u00e1tico del circuito en la versi\u00f3n 1 de la placa BEE. Como vemos, los terminales del zumbador se conectan a los dos pines centrales de una tira de pines 2x3 (J3), estando el resto de pines de la tira conectados a tierra (2) o a los GPIOS 18 (1), 13 (5) y 12 (6) de la raspberry pi. Como indica la web pinout.xyz , estos pines adicionales pueden configurarse con las funciones PWM0, PWM1 y PWM0 respectivamente, pudiendo as\u00ed polarizar el zumbador utilizando jumpers , como se explica m\u00e1s abajo. Este circuito se modific\u00f3 en la versi\u00f3n 2 de la placa, como muestra la siguiente figura. En este caso los terminales del zumbador se han conectado dir\u00e9ctamente a tierra y al terminal central de una tira de pines 1x3 (J3). Los pines restantes de esta tira se han conectado a los GPIOs 12 (PWM0) y 13 (PWM1) de la raspberry pi. En ambos versiones puede usarse un jumper para conectar el zumbador al pin 12 (PWM0) o el 13 (PWM1), y probar as\u00ed el uso del zumbador con se\u00f1ales PWM generadas con los cotroladores internos del microcontrolador. En la versi\u00f3n 1 de la placa deberemos usar otro jumper para conectar el otro extremo a tierra. Conversor Anal\u00f3gico Digital (ADC) En ambas versiones de la placa se monta un conversor anal\u00f3gico digital MCP3008 , con las siguientes caracter\u00edsticas: 10 bits de resoluci\u00f3n 8 canales de entrada Interfaz SPI Entrada independiente para el voltaje de referencia Los esquem\u00e1ticos de la conexi\u00f3n del ADC en las dos versiones de la placa se muestran y explican a continuaci\u00f3n. S\u00f3lo difieren en la conexi\u00f3n de las entradas anal\u00f3gicas, debido a la modificaci\u00f3n que se realiz\u00f3 en la red de polarizaci\u00f3n de sensores. En ambos casos, se debe conectar un voltaje de referencia al ADC antes de usarlo. Si no se dispone de un voltaje de precisi\u00f3n, la placa proporciona una forma sencilla de conectar la entrada Vref a la alimentaci\u00f3n Vdd del ADC. En la primera versi\u00f3n de la placa las entradas anal\u00f3gicas del ADC se conectan a una tira de pines 2x8 (J8), que por el otro lado est\u00e1 conectada a un socket 2x8 (J7), por el lado en el que se conectan unas resistencias de pull down de 220, 10 k, 15 k y 47 k ohmios. Por el otro lado del socket J7 los pines se conectan a la alimentaci\u00f3n anal\u00f3gica (Vcc). De esta forma, podemos conectar un sensor anal\u00f3gico de dos patas en el socket J7, quedando uno de sus terminales conectado a la tira J8 y a una resistencia de pull-down, y el otro a Vcc. Podemos entonces utilizar un jumper en J8 para conectar la salida del sensor a la entrada anal\u00f3gica correspondiente del ADC. Aunque este circuito permite conectar f\u00e1cilmente muchos sensores anal\u00f3gicos al ADC, tenemos ciertas limitaciones: S\u00f3lo podemos usar configuraciones que requieran una resistencia de pull-down. S\u00f3lo podemos escoger 4 valores para la resistencia de pull-down. Para salvar estas limitaciones se modific\u00f3 este circuito en la segunda versi\u00f3n de la placa. Se redefini\u00f3 la red de polarizaci\u00f3n para facilitar la conexi\u00f3n serie o paralelo de las resistencias incluidas, as\u00ed como su conexi\u00f3n como conjuto de pull-down o pull-up. Adem\u00e1s, el nuevo circuito de polarizaci\u00f3n introduce dos potenci\u00f3metros que nos permiten obtener resistencias de polarizaci\u00f3n m\u00e1s especiales. El esqum\u00e1tico se muestra a continuaci\u00f3n: Este circuito est\u00e1 pensado para conectar f\u00e1cilmente al ADC sensores anal\u00f3gicos de dos terminales, en los que uno de ellos debe ir conectado directamente a GND o Vcc, y el otro a una resistencia de pull up o pull down. La salida del sensor se toma entonces del terminal conectado a la resistencia. En estos casos, el sensor se conecta al socket J7, escogiendo la posici\u00f3n que lleve a la resistencia que necesitamos, y usando los micro interruptores de U3 y U4 para conectar a GND o VCC tanto el sensor como la resistencia seleccionada. La salida del sensor estar\u00e1 entonces disponible en la tira de pines J15, y podemos usar un cable dupont hembra-hembra para conectarla a la entrada del ADC deseada, disponible en J8. Si ninguna de las resistencias que hay en el circuito es la resistencia que necesitamos, tenemos dos opciones: Conectar dos (o m\u00e1s) de las resistencias disponibles en serie o paralelo para obtener la resistencia deseada. Para ello podemos usar las tiras de pines J15 y J20, y en alg\u00fan caso un cable dupont. Usar los potenci\u00f3metros incluidos en la red de polarizaci\u00f3n, utilizando un destornillador peque\u00f1o para ajustarlo y un mult\u00edmetro para medir su valor. En ambas placas el interfaz digital del ADC est\u00e1 conectado a la tira de pines J2, que permite conectar con jumpers el ADC (y/o el DAC) a la raspberry pi, usando los GPIOs que corresponden al controlador SPI (el software debe configurar dichos gpios para esta funcionalidad). La siguiente figura muestra el esquem\u00e1tico de este conector: Conversor Digital Anal\u00f3gico (DAC) La placa BEE incorpora tambi\u00e9n un MCP4911 , un Conversor Digital Anal\u00f3gico (DAC) de 10 bits, que puede ser conectado tambi\u00e9n al controlador SPI a trav\u00e9s de la tira de pines J2 usando jumpers. El DAC queda conectado entonces al canal CE1. El esquem\u00e1tico es id\u00e9ntico en ambas versiones de la placa: Como pasaba con el ADC, debemos conectar un voltaje de referencia al DAC. Podemos colocar un jumper en J10 para conectar la entrada Vref a la tensi\u00f3n de alimentaci\u00f3n del DAC (VDD) si no tenemos una referencia de mayor precisi\u00f3n. Asimismo, el DAC dispone de una entrada LDAC, que debe ponerse a 0 V para cargar un nuevo valor en el registro de salida del DAC (consultar el Datasheet del componente). La placa BEE conecta esta entrada a la tira J9, de modo que puede usarse un jumper para conectarlo a 0 permanentemente o utilizar otro GPIO para activarlo por software cuando sea apropiado. El voltaje de salida del DAC est\u00e1 disponible en uno de los pines de la tira J12, estando el otro pin de la tira conectado a GND. Esto facilita la conexi\u00f3n de cualquier dispositivo que deba ser alimentado con la tensi\u00f3n generada con el DAC. Finalmente, como sucede con el ADC, el interfaz digital del DAC se puede conectar mediante jumpers a los GPIOs del controlador SPI de la raspberry pi utilizando el conector J2 (el software debe configurar dichos GPIOs para esta funcionalidad). Driver de display 7 segmentos Este perif\u00e9rico s\u00f3lo est\u00e1 disponible en la versi\u00f3n 2 de la placa BEE, su circuito es el siguiente: Como vemos, se compone principalmente de dos componentes: Un registro de desplazamiento 74AHC_AHCT595 Un display de 7 segmentos (m\u00e1s un punto decimal). El 74AHC595 utiliza doble buffer. Tiene un registro de desplazamiento que permite cargar en 8 ciclos de la se\u00f1al SRCLK un valor de 8 bits enviado en serie por la entrada serie (SER), y un registro de salida, que mantiene inalterado un valor de 8 bits mientras se carga un nuevo valor en el registro de desplazamiento. El valor almacenado en el registro de salida (QA-QH) se conecta a las entradas del display 7 segmentos (A-G, DP) a trav\u00e9s de 8 resistencias de 220 ohmios para limitar la corriente. El display mostrar\u00e1 el digito codificado en estos 8 bits (cada bit indica si se debe encender o no uno de los segmentos). El display es activo en alta, es decir, que un 1 en la entrada A indica que debe encenderse el segmento A (ve el s\u00edmbolo del esquem\u00e1tico), mientras que un 0 en dicha entrada indicar\u00eda que debe apagarse dicho segmento. Como la entrada de habilitaci\u00f3n de la salida (nOE) est\u00e1 conectada a GND, la salida est\u00e1 permanentemente habilitada. La se\u00f1al nSRCLR (nMR en el datasheet) permite resetear los biestables del registro de desplazamiento. Est\u00e1 conectada permanentemente a 1 (no se pueden resetear). El resto de se\u00f1ales (SER, SRCLK y RCLK) se conectan a la tira de pines J6, y podemos usar cables de puente dupont para conectarlos a los pines GPIO que queramos. El funcionamiento del dispositivo es como sigue. Los bits se van cargando en serie en el registro de desplazamiento. Cuando generamos un pulso en la se\u00f1al SRCLK, el valor en la entrada serie SER se carge en el biestable 0, el biestable 1 cargar\u00e1 el valor que ten\u00eda antes el biestable 0, el biestable 2 el valor que ten\u00eda antes el 1 y as\u00ed sucesivamente. La salida QH' nos permite conectar en serie otro 74H595 para almacenar valores de m\u00e1s de 8 bits. Cuando tengamos el valor completo cargado (8 bits), podemos generar un pulso en la se\u00f1al RCLK para cargar los biestables del registro de salida con el contenido almacenado en el registro de desplazamiento. Esto nos permite ir cargando un nuevo valor sin alterar lo que se est\u00e1 mostrando en el display 7 segmentos, mostrando de golpe el nuevo valor cuando se hayan cargado los 8 nuevos bits. Conector UART Se trata de una tira de pines (J13) con la configuraci\u00f3n adecuada para que podamos conectar un cable FTDI-232-R y usar el puerto serie de la mini-uart que incorpora la raspberry pi, ideal para proporcionar un terminal serie a cualquier aplicaci\u00f3n que corra en el microcontrolador. Conector JTAG Se trata de una tira de pines compatible un conector JTAG de 20 pines. La raspberry pi incorpora un controlado JTAG de depuraci\u00f3n en circuito. Se puede usar este controlador si se configura correctamente la funcionalidad de los pines BCM4, BCM22-25 y BCM27, que est\u00e1n rutados a las posiciones adecuadas de la tira de pines J5. Para usar el depurador debemos conectar un dongle JTAG de depuraci\u00f3n a J5, y usar un software como OpenOCD para establecer una sesi\u00f3n de depuraci\u00f3n.","title":"Placa de expansi\u00f3n BEE"},{"location":"#placa-de-expansion-bee","text":"","title":"Placa de expansi\u00f3n BEE"},{"location":"#descripcion-general","text":"La BEE es una placa de expansi\u00f3n, dise\u00f1ada inicialmente para la primera versi\u00f3n de la Raspberry Pi , pero que pude ser utilizada con cualquiera de las versiones de este computador de una sola placa . Este complemento convierte a la Raspberry Pi en una suerte de entrenador econ\u00f3mico para estudiar distintas tem\u00e1ticas de varias titulaciones universitarias del \u00e1mbito de las TIC y la Electr\u00f3nica. Este equipo se ha utilizado con gran \u00e9xito para montar los puestos de laboratorio para varias asignaturas de distintas titulaciones del Departamento de Arquitectura de Computadores y Autom\u00e1tica de la Universidad Complutense de Madrid, limitando tanto el precio que el Departamento ha podido montar un puesto para cada estudiante, permitiendo que puedan llevarse a casa el material durante el curso para completar sus pr\u00e1cticas y/o profundizar en las materias implicadas. El uso de este material fue crucial para que los estudiantes pudi\u00e9sen realizar sus pr\u00e1cticas durante la pandemia de covid de 2019 y 2020. La placa BEE incorpora una serie de perif\u00e9ricos que son f\u00e1cilmente conectables a los pines GPIO de la raspberry pi. En lugar de proporcionar una conexi\u00f3n fija entre los perif\u00e9ricos y los GPIOS de del microcontrolador, es el usuario el que debe conectar cada uno de los perif\u00e9ricos a los pines deseados usando cables de puente dupont hembra-hembra o jumpers . Los pines de la raspberry pi se han dejado disponibles en distintas tiras de pines sobre la propia placa de expansi\u00f3n. En algunos casos se han colocado junto a los circuitos de algun perif\u00e9rico, debido a que la funcionalidad adicional de estos pines est\u00e1 relacionada con dicho perif\u00e9rico. Por ejemplo, los pines que proporcionan conexiones a los controladores hardware de PWM se han colocado junto al circuito del zumbador. Para esos casos la conexi\u00f3n entre el perif\u00e9rico y la raspberry pi puede hacerse de forma c\u00f3moda y sencilla usando jumpers. En todo momento se ha evitado que un pin pueda ser conectado a m\u00e1s de un dispositivo externo, para evitar cortocircuitos provocados por los estudiantes menos cuidadosos. Se han desarrollado hasta el momento dos versiones de la placa BEE. La primera versi\u00f3n (v1) es m\u00e1s peque\u00f1a y econ\u00f3mica, y contiene un conjunto m\u00e1s reducido de dispositivos pensados inicialmente para dar servicio a los laboratorios de un par de asignaturas del Grado de Ingenier\u00eda Electr\u00f3nica de Comunicaciones del Master de Nuevas Tecnolog\u00edas Electr\u00f3nicas y fot\u00f3nicas de la Facultad de CC. F\u00edsicas de la Universidad Complutense de Madrid. La segunda versi\u00f3n (v2) extiende el conjunto de dispositivos incluidos para ampliar el espectro de asignaturas que pueden sacar provecho de esta econ\u00f3mica y vers\u00e1til placa de expansi\u00f3n. Esta segunda versi\u00f3n ha empezado a utilizarse tambi\u00e9n en la Facultad de Inform\u00e1tica de la Universidad Complutense de Madrid en asignaturas de Rob\u00f3tica y Arquitectura Interna de Linux y Android. En ambas versiones, los pines etiquetados como Bx en la placa BEE, tanto en el esquem\u00e1tico como en la serigraf\u00eda sobre la propia pcb, se corresponden con los pines BCMx de la documentaci\u00f3n de Broadcom, tambi\u00e9n denotados como GPIOx en algunos sitios web, como por ejemplo en https://pinout.xyz/ . Los detalles de estos dos modelos se presentan en las pr\u00f3ximas secciones.","title":"Descripci\u00f3n general"},{"location":"#bee-v1","text":"La primera versi\u00f3n de la BEE incluye el siguiente conjunto b\u00e1sico de dispositivos: Un MCP3008. Se trata de un conversor anal\u00f3gico digital (ADC) de 10 bits con 8 canales. Su interfaz digital SPI puede ser conectada mediante 5 jumpers a los pines SPI de la Raspberry Pi por el canal CE0. Sockets para la conexi\u00f3n r\u00e1pida de sensores anal\u00f3gicos, que pueden ser conectados a las entradas de los canales del ADC mediante jumpers . Estos sensores pueden ser polarizados haciendo uso de la red de resistencias montada en la placa, escogi\u00e9ndose una alimentaci\u00f3n de 3.3 V o 5 V mediante un jumper . Un MCP4911. Se trata de un conversor digital anal\u00f3gico (DAC) de 10 bits, que tambi\u00e9n puede ser conectado al controlador SPI usando los mismos 5 jumpers , quedando conectado al canal CE1. 3 circuitos simples de pulsador, que pueden ser conectados a pines digitales de entrada del microcontrolador para recibir acciones de usuario. 3 circuitos simples de led polarizado, que pueden ser conectados a un pin GPIO del microntorlador para controlar el estado del led por software. Un conector para cables FTDI-232-R con conexi\u00f3n directa a los pines del puerto serie de la raspberry pi. Facilita la comunicaci\u00f3n serie desde un PC con la raspberry pi. Un conector para JTAG est\u00e1ndar de 20 pines, conectado a los pines de depuraci\u00f3n en circuito de la raspberry pi. 1 Zumbador piezoel\u00e9ctrico que puede ser conectado con jumpers a algunos de los pines pwm de la Raspberry PI. Estos dispositivos est\u00e1n incluidos para dar soporte al desarrollo de pr\u00e1cticas de las siguientes asignaturas del departamento de Arquitectura de Computadores y Autom\u00e1tica de la Universidad Complutense de Madrid: Estructura de Computadores: en la que se realizan pr\u00e1cticas de programaci\u00f3n de entrada salida bare-metal , usando pines digitales de entrada y salida, conectados a leds y pulsadores, manejo de puerto serie y conexi\u00f3n a dispositivos por SPI o I2C. Rob\u00f3tica: se utilizan sensores anal\u00f3gicos y digitales, ADC, DAC y controladores PWM. Rob\u00f3tica y Mecatr\u00f3nica: igual que en rob\u00f3tica, se usan sensores anal\u00f3gicos y digitales, ADC, DAC, motores, etc. Programaci\u00f3n de Nodos Sensores para Internet de las Cosas: se utilizan tambi\u00e9n sensores anal\u00f3gicos, temporizadores, controladores PWM, etc. Las siguientes im\u00e1genes muestran un modelo 3D de la BEE v1, una foto aislada de un montaje real de la placa y su conexi\u00f3n a la Raspberry Pi en el montaje utilizado el laboratorio del Grado de Ingenier\u00eda Electr\u00f3nica de Comunicaciones de la Universidad Complutense de Madrid: Como vemos, la BEE se conecta a la Raspberry Pi a trav\u00e9s de la tira de 2x20 pines J1, mediante un cable plano. La totalidad de los pines de la Raspberry quedan entonces accesibles al usuario a trav\u00e9s de otras tiras de pines. Los pines quedan distribuidos seg\u00fan su uso entre varias tiras de pines adicionales, algunas de ellas pr\u00f3ximas a los circuitos de perif\u00e9ricos que generalmente necesitar\u00e1n de dichos pines para su manejo y control. En estos casos la conexi\u00f3n entre el perif\u00e9rico y la raspberry pi se puede hacer de forma c\u00f3moda y sencilla utilizando jumpers. La siguiente figura muestra la disposici\u00f3n de las tiras de pines en la BEE v1, marcando en rojo las tiras que exponen los pines de la raspberry pi (etiquetados como Bx en la serigraf\u00eda). Como \u00fanica excepci\u00f3n, los pines B4, B22-B25 y B27, que deben usarse en el caso de realizar una depuraci\u00f3n en circuito con el controlador JTAG, est\u00e1n disponibles en la tira etiquetada en azul como JTAG. La siguiente figura muestra el esquem\u00e1tico de la primera versi\u00f3n de la placa BEE: Cada uno de los bloques de perif\u00e9ricos se explica y documenta m\u00e1s abajo, en las secciones correspondientes a cada uno de ellos.","title":"BEE v1"},{"location":"#bee-v2","text":"La segunda versi\u00f3n de la placa extiende los dispositivos incluidos para dar soporte a un mayor n\u00famero de asignaturas del Departamento de Arquitectura de Computadores y Autom\u00e1tica de la UCM, como por ejemplo Arquitectura Interna Linux y Android, d\u00f3nde se programan drivers para varios tipos de dispositivos en estos sistemas. Asimismo se incorpora una red de polarizaci\u00f3n mucho m\u00e1s vers\u00e1til, con el objetivo de facilitar la polarizaci\u00f3n de sensores anal\u00f3gicos que se quieran conectar a las entradas del ADC, proporcionando las resistencias de polarizaci\u00f3n m\u00e1s habituales, con posibilidad de combinarlas en serie o en paralelo, y microinterruptores para polarizar el conjunto a Gnd o Vcc. Concretamente, en esta versi\u00f3n de la placa se han a\u00f1adido a los dispositivos incluidos en la versi\u00f3n 1 la siguiente lista de perif\u00e9ricos: Un desplazador con buffer conectado a un display de 7 segmentos (con punto decimal), permite escribir en el display 7 segmentos desde la raspberry-pi usando pines gen\u00e9ricos de entrada y salida. Un led RGB polarizado, que puede ser operado desde la raspberry pi con pines gen\u00e9ricos de entrada salida. Una red de polarizaci\u00f3n de sensores, con micro interruptores y resistencias habituales para una polarizaci\u00f3n de sensores anal\u00f3gicos que quieran conectarse a las entradas del ADC. La siguiente imagen muestra un modelo 3D de la segunda iteraci\u00f3n de la placa: La siguiente figura muestra el esquem\u00e1tico de la primera versi\u00f3n de la placa BEE: Los bloques de perif\u00e9ricos se explican y documentan en las siguientes secciones.","title":"BEE v2"},{"location":"#alimentacion-de-perifericos","text":"Los perif\u00e9ricos con interfaz anal\u00f3gica (ADC y DAC) tienen una l\u00ednea de alimentaci\u00f3n separada del resto de componentes, Vdd, que puede ser conectada tanto a 3.3 V como a 5 V colocando un jumper en la tira de pines J14: Por ejemplo, si se van a manejar se\u00f1ales entre 0 y 3.3 V, nos interesar\u00e1 conectar Vdd a 3.3 V para usar los 10 bits del ADC para discretizar el rango de 0 a 3.3V, teniendo as\u00ed mayor precisi\u00f3n que si lo aliment\u00e1semos a 5 V. Del mismo modo, la tira J18 permite escoger 3.3 V o 5 V para la se\u00f1al Vcc, disponible para la polarizaci\u00f3n de sensores anal\u00f3gicos.","title":"Alimentaci\u00f3n de perif\u00e9ricos"},{"location":"#interruptores-y-leds","text":"La siguiente figura muestra el esquem\u00e1tico de este sencillo bloque de perif\u00e9ricos, que es com\u00fan para las dos versiones de la placa. Por un lado tenemos tres leds (D1-D3) con el c\u00e1todo conectado a GND. El \u00e1nodo de cada uno de ellos se conecta a una resistencia de polarizaci\u00f3n de 220 Ohmios, que tiene el otro terminal accesible en uno de los pines de la tira J4. Podemos as\u00ed usar un cable de puente dupont para conectar este terminal a un GPIO de la raspberry pi para controla por software el estado del led: si ponemos el pin a 1 (Vdd) pasar\u00e1 por el led una corriente de unos 7 mA ((3.3 - 1.8)/220 = 7 mA) y el led se encender\u00e1. Por otro lado, tenemos tres pulsadores de bot\u00f3n (SW1-SW3), con un terminal conectado a GND y el otro conectado a una resistencia que a su vez conecta a la alimentaci\u00f3n (3.3 V). El punto entre la resistencia y el pulsador se conecta a uno de los pines de la tira J4. Podemos conectar estos a un GPIO de la raspberry pi haciendo uso de nuevo de un cable dupont hembra-hembra. Si dicho GPIO se configura como entrada podremos usarlo para ver si el pulsador est\u00e1 pulsado (el valor le\u00eddo ser\u00e1 0) o sin pulsar (el valor le\u00eddo ser\u00e1 1). Siempre habr\u00e1 que tener en cuenta que en los cambios de estado se producir\u00e1n rebotes, debido principalmente a las oscilaciones mec\u00e1nicas del muelle incluido en el pulsador. Estos rebotes pueden ser filtrados con ayuda del controlador GPIO de la raspberry pi, y si es necesario, por software.","title":"Interruptores y leds"},{"location":"#led-rgb","text":"Este perif\u00e9rico s\u00f3lo est\u00e1 disponible en la BEE v2, su circuito se muestra a continuaci\u00f3n: Se trata de un led rgb , conectado en c\u00e1todo com\u00fan a tierra, mientras que los terminales de los 3 \u00e1nodos se conectan cada uno a una resistencia, cuyo otro terminal se expone a trav\u00e9s de la tira de pines J21. Podemos usar cables de puente dupont para conectar estos terminales a pines GPIO de la raspberry pi con el fin de controlar la intensidad de los canales Rojo Verde y Azul del led desde el microcontrolador (habitualmente generando se\u00f1ales PWM).","title":"Led RGB"},{"location":"#zumbador-buzzer","text":"Las dos versiones montan el mismo zumbador piezoel\u00e9ctrico ( datasheet ), pero el circuito completo cambia lig\u00e9ramente de una verisi\u00f3n a la otra. La siguiente figura muestra el esquem\u00e1tico del circuito en la versi\u00f3n 1 de la placa BEE. Como vemos, los terminales del zumbador se conectan a los dos pines centrales de una tira de pines 2x3 (J3), estando el resto de pines de la tira conectados a tierra (2) o a los GPIOS 18 (1), 13 (5) y 12 (6) de la raspberry pi. Como indica la web pinout.xyz , estos pines adicionales pueden configurarse con las funciones PWM0, PWM1 y PWM0 respectivamente, pudiendo as\u00ed polarizar el zumbador utilizando jumpers , como se explica m\u00e1s abajo. Este circuito se modific\u00f3 en la versi\u00f3n 2 de la placa, como muestra la siguiente figura. En este caso los terminales del zumbador se han conectado dir\u00e9ctamente a tierra y al terminal central de una tira de pines 1x3 (J3). Los pines restantes de esta tira se han conectado a los GPIOs 12 (PWM0) y 13 (PWM1) de la raspberry pi. En ambos versiones puede usarse un jumper para conectar el zumbador al pin 12 (PWM0) o el 13 (PWM1), y probar as\u00ed el uso del zumbador con se\u00f1ales PWM generadas con los cotroladores internos del microcontrolador. En la versi\u00f3n 1 de la placa deberemos usar otro jumper para conectar el otro extremo a tierra.","title":"Zumbador (Buzzer)"},{"location":"#conversor-analogico-digital-adc","text":"En ambas versiones de la placa se monta un conversor anal\u00f3gico digital MCP3008 , con las siguientes caracter\u00edsticas: 10 bits de resoluci\u00f3n 8 canales de entrada Interfaz SPI Entrada independiente para el voltaje de referencia Los esquem\u00e1ticos de la conexi\u00f3n del ADC en las dos versiones de la placa se muestran y explican a continuaci\u00f3n. S\u00f3lo difieren en la conexi\u00f3n de las entradas anal\u00f3gicas, debido a la modificaci\u00f3n que se realiz\u00f3 en la red de polarizaci\u00f3n de sensores. En ambos casos, se debe conectar un voltaje de referencia al ADC antes de usarlo. Si no se dispone de un voltaje de precisi\u00f3n, la placa proporciona una forma sencilla de conectar la entrada Vref a la alimentaci\u00f3n Vdd del ADC. En la primera versi\u00f3n de la placa las entradas anal\u00f3gicas del ADC se conectan a una tira de pines 2x8 (J8), que por el otro lado est\u00e1 conectada a un socket 2x8 (J7), por el lado en el que se conectan unas resistencias de pull down de 220, 10 k, 15 k y 47 k ohmios. Por el otro lado del socket J7 los pines se conectan a la alimentaci\u00f3n anal\u00f3gica (Vcc). De esta forma, podemos conectar un sensor anal\u00f3gico de dos patas en el socket J7, quedando uno de sus terminales conectado a la tira J8 y a una resistencia de pull-down, y el otro a Vcc. Podemos entonces utilizar un jumper en J8 para conectar la salida del sensor a la entrada anal\u00f3gica correspondiente del ADC. Aunque este circuito permite conectar f\u00e1cilmente muchos sensores anal\u00f3gicos al ADC, tenemos ciertas limitaciones: S\u00f3lo podemos usar configuraciones que requieran una resistencia de pull-down. S\u00f3lo podemos escoger 4 valores para la resistencia de pull-down. Para salvar estas limitaciones se modific\u00f3 este circuito en la segunda versi\u00f3n de la placa. Se redefini\u00f3 la red de polarizaci\u00f3n para facilitar la conexi\u00f3n serie o paralelo de las resistencias incluidas, as\u00ed como su conexi\u00f3n como conjuto de pull-down o pull-up. Adem\u00e1s, el nuevo circuito de polarizaci\u00f3n introduce dos potenci\u00f3metros que nos permiten obtener resistencias de polarizaci\u00f3n m\u00e1s especiales. El esqum\u00e1tico se muestra a continuaci\u00f3n: Este circuito est\u00e1 pensado para conectar f\u00e1cilmente al ADC sensores anal\u00f3gicos de dos terminales, en los que uno de ellos debe ir conectado directamente a GND o Vcc, y el otro a una resistencia de pull up o pull down. La salida del sensor se toma entonces del terminal conectado a la resistencia. En estos casos, el sensor se conecta al socket J7, escogiendo la posici\u00f3n que lleve a la resistencia que necesitamos, y usando los micro interruptores de U3 y U4 para conectar a GND o VCC tanto el sensor como la resistencia seleccionada. La salida del sensor estar\u00e1 entonces disponible en la tira de pines J15, y podemos usar un cable dupont hembra-hembra para conectarla a la entrada del ADC deseada, disponible en J8. Si ninguna de las resistencias que hay en el circuito es la resistencia que necesitamos, tenemos dos opciones: Conectar dos (o m\u00e1s) de las resistencias disponibles en serie o paralelo para obtener la resistencia deseada. Para ello podemos usar las tiras de pines J15 y J20, y en alg\u00fan caso un cable dupont. Usar los potenci\u00f3metros incluidos en la red de polarizaci\u00f3n, utilizando un destornillador peque\u00f1o para ajustarlo y un mult\u00edmetro para medir su valor. En ambas placas el interfaz digital del ADC est\u00e1 conectado a la tira de pines J2, que permite conectar con jumpers el ADC (y/o el DAC) a la raspberry pi, usando los GPIOs que corresponden al controlador SPI (el software debe configurar dichos gpios para esta funcionalidad). La siguiente figura muestra el esquem\u00e1tico de este conector:","title":"Conversor Anal\u00f3gico Digital (ADC)"},{"location":"#conversor-digital-analogico-dac","text":"La placa BEE incorpora tambi\u00e9n un MCP4911 , un Conversor Digital Anal\u00f3gico (DAC) de 10 bits, que puede ser conectado tambi\u00e9n al controlador SPI a trav\u00e9s de la tira de pines J2 usando jumpers. El DAC queda conectado entonces al canal CE1. El esquem\u00e1tico es id\u00e9ntico en ambas versiones de la placa: Como pasaba con el ADC, debemos conectar un voltaje de referencia al DAC. Podemos colocar un jumper en J10 para conectar la entrada Vref a la tensi\u00f3n de alimentaci\u00f3n del DAC (VDD) si no tenemos una referencia de mayor precisi\u00f3n. Asimismo, el DAC dispone de una entrada LDAC, que debe ponerse a 0 V para cargar un nuevo valor en el registro de salida del DAC (consultar el Datasheet del componente). La placa BEE conecta esta entrada a la tira J9, de modo que puede usarse un jumper para conectarlo a 0 permanentemente o utilizar otro GPIO para activarlo por software cuando sea apropiado. El voltaje de salida del DAC est\u00e1 disponible en uno de los pines de la tira J12, estando el otro pin de la tira conectado a GND. Esto facilita la conexi\u00f3n de cualquier dispositivo que deba ser alimentado con la tensi\u00f3n generada con el DAC. Finalmente, como sucede con el ADC, el interfaz digital del DAC se puede conectar mediante jumpers a los GPIOs del controlador SPI de la raspberry pi utilizando el conector J2 (el software debe configurar dichos GPIOs para esta funcionalidad).","title":"Conversor Digital Anal\u00f3gico (DAC)"},{"location":"#driver-de-display-7-segmentos","text":"Este perif\u00e9rico s\u00f3lo est\u00e1 disponible en la versi\u00f3n 2 de la placa BEE, su circuito es el siguiente: Como vemos, se compone principalmente de dos componentes: Un registro de desplazamiento 74AHC_AHCT595 Un display de 7 segmentos (m\u00e1s un punto decimal). El 74AHC595 utiliza doble buffer. Tiene un registro de desplazamiento que permite cargar en 8 ciclos de la se\u00f1al SRCLK un valor de 8 bits enviado en serie por la entrada serie (SER), y un registro de salida, que mantiene inalterado un valor de 8 bits mientras se carga un nuevo valor en el registro de desplazamiento. El valor almacenado en el registro de salida (QA-QH) se conecta a las entradas del display 7 segmentos (A-G, DP) a trav\u00e9s de 8 resistencias de 220 ohmios para limitar la corriente. El display mostrar\u00e1 el digito codificado en estos 8 bits (cada bit indica si se debe encender o no uno de los segmentos). El display es activo en alta, es decir, que un 1 en la entrada A indica que debe encenderse el segmento A (ve el s\u00edmbolo del esquem\u00e1tico), mientras que un 0 en dicha entrada indicar\u00eda que debe apagarse dicho segmento. Como la entrada de habilitaci\u00f3n de la salida (nOE) est\u00e1 conectada a GND, la salida est\u00e1 permanentemente habilitada. La se\u00f1al nSRCLR (nMR en el datasheet) permite resetear los biestables del registro de desplazamiento. Est\u00e1 conectada permanentemente a 1 (no se pueden resetear). El resto de se\u00f1ales (SER, SRCLK y RCLK) se conectan a la tira de pines J6, y podemos usar cables de puente dupont para conectarlos a los pines GPIO que queramos. El funcionamiento del dispositivo es como sigue. Los bits se van cargando en serie en el registro de desplazamiento. Cuando generamos un pulso en la se\u00f1al SRCLK, el valor en la entrada serie SER se carge en el biestable 0, el biestable 1 cargar\u00e1 el valor que ten\u00eda antes el biestable 0, el biestable 2 el valor que ten\u00eda antes el 1 y as\u00ed sucesivamente. La salida QH' nos permite conectar en serie otro 74H595 para almacenar valores de m\u00e1s de 8 bits. Cuando tengamos el valor completo cargado (8 bits), podemos generar un pulso en la se\u00f1al RCLK para cargar los biestables del registro de salida con el contenido almacenado en el registro de desplazamiento. Esto nos permite ir cargando un nuevo valor sin alterar lo que se est\u00e1 mostrando en el display 7 segmentos, mostrando de golpe el nuevo valor cuando se hayan cargado los 8 nuevos bits.","title":"Driver de display 7 segmentos"},{"location":"#conector-uart","text":"Se trata de una tira de pines (J13) con la configuraci\u00f3n adecuada para que podamos conectar un cable FTDI-232-R y usar el puerto serie de la mini-uart que incorpora la raspberry pi, ideal para proporcionar un terminal serie a cualquier aplicaci\u00f3n que corra en el microcontrolador.","title":"Conector UART"},{"location":"#conector-jtag","text":"Se trata de una tira de pines compatible un conector JTAG de 20 pines. La raspberry pi incorpora un controlado JTAG de depuraci\u00f3n en circuito. Se puede usar este controlador si se configura correctamente la funcionalidad de los pines BCM4, BCM22-25 y BCM27, que est\u00e1n rutados a las posiciones adecuadas de la tira de pines J5. Para usar el depurador debemos conectar un dongle JTAG de depuraci\u00f3n a J5, y usar un software como OpenOCD para establecer una sesi\u00f3n de depuraci\u00f3n.","title":"Conector JTAG"},{"location":"control_servomotores/","text":"Control de servomotores con PWM En esta pr\u00e1ctica vamos a aprender como controlar un servomotor usando el generador de PWM de la Raspberry Pi, la placa BEE y la librer\u00eda wiringpi. Esta pr\u00e1ctica es parte de la asignatura de Rob\u00f3tica y Mecatr\u00f3nica del M\u00e1ster en Nuevas Tecnolog\u00edas Electr\u00f3nicas y Fot\u00f3nicas de la Universidad Complutense de Madrid. Es parte de un proyecto donde los alumnos crean desde cero su propia plataforma rob\u00f3tica m\u00f3vil. Servomotores Para la elecci\u00f3n de los servomotores se elegir\u00e1n dos servomotores del tipo Parallax Continous Rotation Servo. Estos servomotores tienen una velocidad m\u00e1xima de 50rpm son bidireccionales y de sencilla implementaci\u00f3n. La informaci\u00f3n proporcionada por el fabricante se puede consultar en la hoja de referencia disponible online ( Aqui ). ejemplos-practicas.md Se\u00f1al PWM Existen dos posibilidades de generar una se\u00f1al PWM usando la Raspberry Pi. La primera consiste en utilizar implementaciones software de librer\u00edas como WiringPi en donde el sistema operativo de la raspberry se utiliza para generar pulsos PWM. Este m\u00e9todo es propenso a errores de precisi\u00f3n debido a que el proceso debe compartir recursos con el resto de procesos de la Raspberry Pi. La segunda se basa en utilizar la implementaci\u00f3n hardware de la se\u00f1al PWM de la que dispone la Raspberry Pi. Este m\u00e9todo consiste en el uso de un reloj externo espec\u00edfico para la generaci\u00f3n de esta se\u00f1al. Al no depender del sistema operativo este m\u00e9todo suele ser mucho m\u00e1s preciso y el que se recomienda usar para el control de motores. En esta pr\u00e1ctica explicaremos la implementaci\u00f3n de la se\u00f1al usando el PWM hardware. PWM hardware Lo primero que hay que saber para trabajar con la se\u00f1al de PWM, es que el reloj disponible en la Raspberry Pi funciona a una frecuencia constante de 19.2 Mhz. Nuestro primero objetivo es adaptar esta frecuencia a la frecuencia de trabajo de nuestros servos. En nuestro caso, echando un vistazo al dataseet de los motores, vemos que el fabricante recomienda un periodo entre pulsos de 20ms. Esto equivale a una frecuencia de trabajo aproximada de 50Hz. Para definir esta frecuencia en la Raspberry Pi disponemos de dos par\u00e1metros: el divisor y el rango. El divisor nos permite escalar la frecuencia de trabajo del reloj. El rango nos define la resoluci\u00f3n de cada periodo de PWM y por lo tanto tambi\u00e9n la frecuencia m\u00e1xima que podremos conseguir. Configuraci\u00f3n de la Frecuencia PWM Para ajustar la frecuencia de la se\u00f1al PWM, utilizamos dos par\u00e1metros: Divisor ( D ) : Reduce la frecuencia del reloj de 19.2 MHz. Rango ( R ) : Define la resoluci\u00f3n del ciclo de trabajo y afecta la frecuencia resultante. La ecuaci\u00f3n para calcular la frecuencia PWM es: f_PWM = 19.2 MHz / (D \u00d7 R) Ejemplo para obtener 50 Hz : Divisor ( D ) = 1920 Rango ( R ) = 200 C\u00e1lculo: f_PWM = 19.2 MHz / (192 \u00d7 2000) = 50 Hz C\u00f3digo Para implementar la se\u00f1al PWM con la frecuencia indicada en el apartado anterior se puede utilizar el siguiente c\u00f3digo base. Este c\u00f3digo utiliza la biblioteca WiringPi para generar se\u00f1ales PWM y controlar la intensidad de giro de dos motores conectados a la Raspberry Pi. C\u00f3digo en C: #include <wiringPi.h> #include <stdio.h> #include <stdlib.h> // Definici\u00f3n de pines PWM seg\u00fan WiringPi const int PWM_pin_izda = 1; // Rueda izquierda (GPIO1 rasPi, BCM18/PWM0 en BEE) const int PWM_pin_dcha = 23; // Rueda derecha (GPIO23 raspi, BCM13/PWM1 en BEE) int main(void) { int intensidad; int rango = 200; // Rango del PWM (valor m\u00e1ximo de duty cycle) int divisor = 1920; // Factor de divisi\u00f3n del reloj PWM // Inicializaci\u00f3n de WiringPi if (wiringPiSetup() == -1) exit(1); // Configuraci\u00f3n del pin de salida PWM pinMode(PWM_pin_dcha, PWM_OUTPUT); pinMode(PWM_pin_izda, PWM_OUTPUT); // Configuraci\u00f3n del PWM por hardware pwmSetRange(rango); pwmSetClock(divisor); pwmSetMode(PWM_MODE_MS); while (1) { // Secuencia de movimiento con diferentes valores de PWM pwmWrite(PWM_pin_dcha, 13); pwmWrite(PWM_pin_izda, 17); printf(\"Moviendo a 17\\n\"); getchar(); pwmWrite(PWM_pin_dcha, 8); pwmWrite(PWM_pin_izda, 80); printf(\"Moviendo a 80\\n\"); getchar(); pwmWrite(PWM_pin_dcha, 6); pwmWrite(PWM_pin_izda, 130); printf(\"Moviendo a 130\\n\"); getchar(); pwmWrite(PWM_pin_dcha, 1); pwmWrite(PWM_pin_izda, 190); printf(\"Moviendo a 190\\n\"); getchar(); // Detener motores pwmWrite(PWM_pin_dcha, 0); pwmWrite(PWM_pin_izda, 0); getchar(); // Variaci\u00f3n gradual de la intensidad de PWM for (intensidad = 0; intensidad < rango; ++intensidad) { pwmWrite(PWM_pin_dcha, intensidad); delay(100); printf(\"Intensidad: %d\\n\", intensidad); } delay(1); for (intensidad = rango; intensidad >= 0; --intensidad) { pwmWrite(PWM_pin_dcha, intensidad); delay(100); printf(\"Intensidad: %d\\n\", intensidad); } delay(1); } } En este c\u00f3digo se realizan los siguientes pasos: 1. Se configura WiringPi para utilizar PWM por hardware. 2. Se definen los pines PWM para controlar dos ruedas. 3. Se establece un rango de 200 y un divisor de reloj de 1920. 4. En el bucle principal, se generan diferentes valores de PWM para simular movimientos de los motores cambiando cada valor con una pulsaci\u00f3n de teclado. 5. Luego, se realiza una variaci\u00f3n gradual de la intensidad de la se\u00f1al PWM. Conexiones con la placa BEE Una vez tenemos implementado el c\u00f3digo lo \u00fanico que nos quedar\u00eda ser\u00eda realizar las conexiones correspondientes entre la placa BEE y los servomotores para probar el movimiento de los mismos. La Raspberry Pi dispone de dos salidas PWM hardware correspondientes con los pines GPIO 1 y GPIO 23. Estos pines se corresponden en la placa BEE con los pines BCM18/PWM0 (rojo en la imagen de abajo) y BCM13/PWM1 (verde en la imagen de abajo) correspondientemente. A estos pines deberemos conectar el cable de control (cable blanco) de cada motor. Siguiendo lo especificado en el c\u00f3digo el motor izquierdo deber\u00e1 conectarse al PWM0 y el derecho al PWM1. Una vez hecho esto solo nos quedar\u00eda alimentar los servomotores a 5V siguiendo lo especificado por el fabricante. Para ello podemos usar una placa entrenador y una fuente de alimentaci\u00f3n externa (por ejemplo una power bank). De esta forma podemos crear una v\u00eda de alimentaci\u00f3n en en el entrenador en donde conectaremos nuestros motores. Por \u00faltimo, seguiremos el mismo procedimiento para las tierras. En este caso tendremos que asegurarnos que las tierras de ambos motores y la tierra de la placa BEE (conector azul en la imagen, entre otros) est\u00e1n conectadas al mismo punto para tener una referencia com\u00fan.","title":"Control de servomotores con PWM"},{"location":"control_servomotores/#control-de-servomotores-con-pwm","text":"En esta pr\u00e1ctica vamos a aprender como controlar un servomotor usando el generador de PWM de la Raspberry Pi, la placa BEE y la librer\u00eda wiringpi. Esta pr\u00e1ctica es parte de la asignatura de Rob\u00f3tica y Mecatr\u00f3nica del M\u00e1ster en Nuevas Tecnolog\u00edas Electr\u00f3nicas y Fot\u00f3nicas de la Universidad Complutense de Madrid. Es parte de un proyecto donde los alumnos crean desde cero su propia plataforma rob\u00f3tica m\u00f3vil.","title":"Control de servomotores con PWM"},{"location":"control_servomotores/#servomotores","text":"Para la elecci\u00f3n de los servomotores se elegir\u00e1n dos servomotores del tipo Parallax Continous Rotation Servo. Estos servomotores tienen una velocidad m\u00e1xima de 50rpm son bidireccionales y de sencilla implementaci\u00f3n. La informaci\u00f3n proporcionada por el fabricante se puede consultar en la hoja de referencia disponible online ( Aqui ). ejemplos-practicas.md","title":"Servomotores"},{"location":"control_servomotores/#senal-pwm","text":"Existen dos posibilidades de generar una se\u00f1al PWM usando la Raspberry Pi. La primera consiste en utilizar implementaciones software de librer\u00edas como WiringPi en donde el sistema operativo de la raspberry se utiliza para generar pulsos PWM. Este m\u00e9todo es propenso a errores de precisi\u00f3n debido a que el proceso debe compartir recursos con el resto de procesos de la Raspberry Pi. La segunda se basa en utilizar la implementaci\u00f3n hardware de la se\u00f1al PWM de la que dispone la Raspberry Pi. Este m\u00e9todo consiste en el uso de un reloj externo espec\u00edfico para la generaci\u00f3n de esta se\u00f1al. Al no depender del sistema operativo este m\u00e9todo suele ser mucho m\u00e1s preciso y el que se recomienda usar para el control de motores. En esta pr\u00e1ctica explicaremos la implementaci\u00f3n de la se\u00f1al usando el PWM hardware.","title":"Se\u00f1al PWM"},{"location":"control_servomotores/#pwm-hardware","text":"Lo primero que hay que saber para trabajar con la se\u00f1al de PWM, es que el reloj disponible en la Raspberry Pi funciona a una frecuencia constante de 19.2 Mhz. Nuestro primero objetivo es adaptar esta frecuencia a la frecuencia de trabajo de nuestros servos. En nuestro caso, echando un vistazo al dataseet de los motores, vemos que el fabricante recomienda un periodo entre pulsos de 20ms. Esto equivale a una frecuencia de trabajo aproximada de 50Hz. Para definir esta frecuencia en la Raspberry Pi disponemos de dos par\u00e1metros: el divisor y el rango. El divisor nos permite escalar la frecuencia de trabajo del reloj. El rango nos define la resoluci\u00f3n de cada periodo de PWM y por lo tanto tambi\u00e9n la frecuencia m\u00e1xima que podremos conseguir.","title":"PWM hardware"},{"location":"control_servomotores/#configuracion-de-la-frecuencia-pwm","text":"Para ajustar la frecuencia de la se\u00f1al PWM, utilizamos dos par\u00e1metros: Divisor ( D ) : Reduce la frecuencia del reloj de 19.2 MHz. Rango ( R ) : Define la resoluci\u00f3n del ciclo de trabajo y afecta la frecuencia resultante. La ecuaci\u00f3n para calcular la frecuencia PWM es: f_PWM = 19.2 MHz / (D \u00d7 R) Ejemplo para obtener 50 Hz : Divisor ( D ) = 1920 Rango ( R ) = 200 C\u00e1lculo: f_PWM = 19.2 MHz / (192 \u00d7 2000) = 50 Hz","title":"Configuraci\u00f3n de la Frecuencia PWM"},{"location":"control_servomotores/#codigo","text":"Para implementar la se\u00f1al PWM con la frecuencia indicada en el apartado anterior se puede utilizar el siguiente c\u00f3digo base. Este c\u00f3digo utiliza la biblioteca WiringPi para generar se\u00f1ales PWM y controlar la intensidad de giro de dos motores conectados a la Raspberry Pi.","title":"C\u00f3digo"},{"location":"control_servomotores/#codigo-en-c","text":"#include <wiringPi.h> #include <stdio.h> #include <stdlib.h> // Definici\u00f3n de pines PWM seg\u00fan WiringPi const int PWM_pin_izda = 1; // Rueda izquierda (GPIO1 rasPi, BCM18/PWM0 en BEE) const int PWM_pin_dcha = 23; // Rueda derecha (GPIO23 raspi, BCM13/PWM1 en BEE) int main(void) { int intensidad; int rango = 200; // Rango del PWM (valor m\u00e1ximo de duty cycle) int divisor = 1920; // Factor de divisi\u00f3n del reloj PWM // Inicializaci\u00f3n de WiringPi if (wiringPiSetup() == -1) exit(1); // Configuraci\u00f3n del pin de salida PWM pinMode(PWM_pin_dcha, PWM_OUTPUT); pinMode(PWM_pin_izda, PWM_OUTPUT); // Configuraci\u00f3n del PWM por hardware pwmSetRange(rango); pwmSetClock(divisor); pwmSetMode(PWM_MODE_MS); while (1) { // Secuencia de movimiento con diferentes valores de PWM pwmWrite(PWM_pin_dcha, 13); pwmWrite(PWM_pin_izda, 17); printf(\"Moviendo a 17\\n\"); getchar(); pwmWrite(PWM_pin_dcha, 8); pwmWrite(PWM_pin_izda, 80); printf(\"Moviendo a 80\\n\"); getchar(); pwmWrite(PWM_pin_dcha, 6); pwmWrite(PWM_pin_izda, 130); printf(\"Moviendo a 130\\n\"); getchar(); pwmWrite(PWM_pin_dcha, 1); pwmWrite(PWM_pin_izda, 190); printf(\"Moviendo a 190\\n\"); getchar(); // Detener motores pwmWrite(PWM_pin_dcha, 0); pwmWrite(PWM_pin_izda, 0); getchar(); // Variaci\u00f3n gradual de la intensidad de PWM for (intensidad = 0; intensidad < rango; ++intensidad) { pwmWrite(PWM_pin_dcha, intensidad); delay(100); printf(\"Intensidad: %d\\n\", intensidad); } delay(1); for (intensidad = rango; intensidad >= 0; --intensidad) { pwmWrite(PWM_pin_dcha, intensidad); delay(100); printf(\"Intensidad: %d\\n\", intensidad); } delay(1); } } En este c\u00f3digo se realizan los siguientes pasos: 1. Se configura WiringPi para utilizar PWM por hardware. 2. Se definen los pines PWM para controlar dos ruedas. 3. Se establece un rango de 200 y un divisor de reloj de 1920. 4. En el bucle principal, se generan diferentes valores de PWM para simular movimientos de los motores cambiando cada valor con una pulsaci\u00f3n de teclado. 5. Luego, se realiza una variaci\u00f3n gradual de la intensidad de la se\u00f1al PWM.","title":"C\u00f3digo en C:"},{"location":"control_servomotores/#conexiones-con-la-placa-bee","text":"Una vez tenemos implementado el c\u00f3digo lo \u00fanico que nos quedar\u00eda ser\u00eda realizar las conexiones correspondientes entre la placa BEE y los servomotores para probar el movimiento de los mismos. La Raspberry Pi dispone de dos salidas PWM hardware correspondientes con los pines GPIO 1 y GPIO 23. Estos pines se corresponden en la placa BEE con los pines BCM18/PWM0 (rojo en la imagen de abajo) y BCM13/PWM1 (verde en la imagen de abajo) correspondientemente. A estos pines deberemos conectar el cable de control (cable blanco) de cada motor. Siguiendo lo especificado en el c\u00f3digo el motor izquierdo deber\u00e1 conectarse al PWM0 y el derecho al PWM1. Una vez hecho esto solo nos quedar\u00eda alimentar los servomotores a 5V siguiendo lo especificado por el fabricante. Para ello podemos usar una placa entrenador y una fuente de alimentaci\u00f3n externa (por ejemplo una power bank). De esta forma podemos crear una v\u00eda de alimentaci\u00f3n en en el entrenador en donde conectaremos nuestros motores. Por \u00faltimo, seguiremos el mismo procedimiento para las tierras. En este caso tendremos que asegurarnos que las tierras de ambos motores y la tierra de la placa BEE (conector azul en la imagen, entre otros) est\u00e1n conectadas al mismo punto para tener una referencia com\u00fan.","title":"Conexiones con la placa BEE"},{"location":"gpio_linux/","text":"Control GPIO en Linux En esta pr\u00e1ctica utilizaremos los drivers que proporciona linux para controlar el GPIO. Puedes hacer esta pr\u00e1ctica si tienes una raspberry-pi con Raspbian, consiguiendo manejar dispositivos sencillos, como los pulsadores y los leds que incorpora la placa BEE, desde un programa de usuario escrito en C. Introducci\u00f3n Linux expone los controladores del GPIO como dispositivos orientados a caracteres /dev/gpiochip# . Usar estos dispositivos ofrece las siguientes ventajas: Portabilidad: el c\u00f3digo es pr\u00e1cticamente independiente del hardware, a excepci\u00f3n de los GPIOS/pines que hay que usar No requiere privilegios de root Ofrece un mecanismo para tratar eventos hw desde el espacio de usuario Mantiene la sem\u00e1ntica UNIX tradicional de todo es un fichero Como con cualquier otro dispositivo, podemos trabajar con el gpio como si fuese un fichero, utilizando las llamadas al sistema open() , read() , write() , ioctl() , close() . En esta pr\u00e1ctica usaremos la versi\u00f3n 2 del ABI, la 1 se considera obsoleta ( deprecated ). La fuente m\u00e1s fiable de referencia/documentaci\u00f3n es el propio fichero de cabecera /usr/include/linux/gpio.h . Utilidades de l\u00ednea de comandos La librer\u00eda libgpiod nos ofrece unos programas de ejemplo que podemos utilizar como utilidades de l\u00ednea de comandos para interactuar con los controladores de GPIO. Para disponer de estas herramientas debemos instalar algunos paquetes de raspbian: sudo apt install gpiod libgpiod-dev libgpiod-doc Una vez instalados estos paquetes tendremos disponibles las utilidades descritas en las siguientes secciones. gpiodetect Esta utilidad nos da una lista de los dispositivos de caracteres para control del gpio disponibles en nuestra plataforma: pi@raspberrypi:~ $ gpiodetect gpiochip0 [pinctrl-bcm2835] (54 lines) gpiochip1 [brcmvirt-gpio] (2 lines) gpiochip2 [raspberrypi-exp-gpio] (8 lines) pi@raspberrypi:~ $ gpioinfo Esta utilidad lista los pines controlados por uno de los controladores: pi@raspberrypi:~ $ gpioinfo gpiochip0 gpiochip0 - 54 lines: line 0: unnamed unused input active-high line 1: unnamed unused input active-high line 2: unnamed unused input active-high line 3: unnamed unused input active-high ... pi@raspberrypi:~ $ gpiofind Utilidad que nos da el n\u00famero de l\u00ednea de gpio para l\u00edneas identificadas con un nombre en el device-tree gpioset Utilidad que permite asignar un valor a un conjunto de l\u00edneas del gpio mientras ejecuta el comando. Con -m modo podemos configurar lo que hace el comando tras dar el valor a las l\u00edneas. Los posibles modos son: wait: espera a que el usuario pulse enter exit: termina inmediatamente time: duerme por el periodo de tiempo especificado con el flag -s o el flag -u signal: espera hasta recibir SIGINT o SIGTERM Por ejemplo, para encender 3 leds conectados a los pines 20, 21 y 26, hasta que el usuario pulse enter: pi@raspberrypi:~ $ gpioset -m wait 0 20=1 21=1 26=1 pi@raspberrypi:~ $ El siguiente script es un ejemplo de uso de gpioset que hace oscilar una luz entre tres leds. #!/bin/bash ini=0x01 dir=0 while true do bit26=$(( (ini & 0x4) >> 2 )) bit21=$(( (ini & 0x2) >> 1 )) bit20=$((ini & 0x1)) gpioset -m time -s 1 0 26=$bit26 21=$bit21 20=$bit20 if [ $dir -eq 0 ]; then ini=$(((ini << 1) & 0x7)) else ini=$(((ini >> 1) & 0x7)) fi if [ $ini -eq 0 ]; then dir=$(((dir + 1) & 1)) ini=0x2 fi done gpioget Esta utilidad nos da el estado actual de las l\u00edneas solicitadas en el chip de control indicado en la linea de comandos gpiomon Esta utilidad nos permite monitorizar el estado de unos pines. Usa la llamada al sistema poll , con las siguientes opciones: -n NUM: termina despu\u00e9s de \\texttt{NUM} eventos -s: no imprime informaci\u00f3n de evento -r: procesa s\u00f3lo eventos de flanco de subida -f: procesa s\u00f3lo eventos de flanco de bajada -F FMT: especifica el formato de salida (consulta la p\u00e1gina de manual) Por ejemplo, para monitorizar tres pulsadores conectados a las l\u00edneas 19, 6 y 5: pi@raspberrypi:~ $ gpiomon -f 0 19 6 5 event: FALLING EDGE offset: 19 timestamp: [ 2740.887807571] event: FALLING EDGE offset: 6 timestamp: [ 2742.291116096] event: FALLING EDGE offset: 5 timestamp: [ 2744.609921761] ^Cpi@raspberrypi:~ $ Driver GPIO Vamos a ver c\u00f3mo podemos manejar los pines del GPIO desde un programa de usuario escrito en C utilizando el driver de GPIO proporcionado por Linux. Para ello debemos comprender qu\u00e9 son las operaciones ioctl en el est\u00e1ndar POSIX, que ser\u00e1n vitales para la comunicaci\u00f3n con el driver. Luego iremos viendo como podemos utilizar estas operaciones para interactuar con el controlador GPIO. Operaciones ioctl En los sistemas POSIX las operaciones sobre un dispositivo que no sean read o write se realizan con la llamada al sistema ioctl , cuyo prototipo es: int ioctl(int fd, unsigned long request, void *argp); d\u00f3nde: fd : descriptor de fichero devuelto por open request : petici\u00f3n de operaci\u00f3n, dependiente del dispositivo. argp : direcci\u00f3n a un buffer que depende del tipo de operaci\u00f3n. No hay un est\u00e1ndar para los c\u00f3digos de las peticiones, pero un convenio que es ampliamente usado es el siguiente: Dos bits para indicar la direcci\u00f3n: 00 (nada), 01 (lectura), 10 (escritura) y 11 (lectura y escritura). 14 bits que indican el tama\u00f1o del dato pasado como argumento 8 bits de tipo de operaci\u00f3n 8 bits de n\u00famero de operaci\u00f3n El sistema define unas macros para ayudar a la codificaci\u00f3n de estas peticiones: _IOR(type, nr, arg), _IOW(type, nr, arg), _IOWR(type, nr, arg) e _IO(type, nr). Obtener informaci\u00f3n del controlador GPIO Para obtener informaci\u00f3n del controlador podemos utilizar la petici\u00f3n ioctl GPIO_GET_CHIP_INFO, que requiere como par\u00e1metro adicional la direcci\u00f3n de una estructura del siguiente tipo: struct gpiochip_info { char name[32]; /* Nombre del controlador en el kernel */ char label[32]; /* Nombre funcional, de producto */ __u32 lines; /* n\u00famero de l\u00edneas que maneja */ }; Un ejemplo de uso ser\u00eda el siguiente: int fd; struct gpiochip_info info; fd = open(\"/dev/gpiochip0\", O_RDONLY); ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &info); close(fd); printf(\"label: %s\\n\", info.label); printf(\"name: %s\\n\", info.name); printf(\"number of lines: %u\\n\", info.lines); Examinar el ejemplo gpio_info y comprobar su funcionamiento. Pines de entrada y salida El driver de GPIO nos permite definir l\u00edneas de pines , que representan grupos de pines con un nombre de usuario (por ejemplo sevenseg), y que comparten la misma configuraci\u00f3n. Una vez creada la l\u00ednea se obtiene un descriptor de fichero que la representa, con el que podremos manejar este grupo de pines. Para crear una de estas l\u00edneas de pines , una vez abierto el dispositivo, debemos hacer una petici\u00f3n ioctl de tipo line_request : ioctl(fd, GPIO_V2_GET_LINE_IOCTL, &req); d\u00f3nde req es un struct gpio_v2_line_request : struct gpio_v2_line_request { __u32 offsets[GPIO_V2_LINES_MAX]; //pines a manejar (in) char consumer[GPIO_MAX_NAME_SIZE]; //nombre por usuario (in) struct gpio_v2_line_config config; //configuraci\u00f3n (in) __u32 num_lines; //num pines en offsets (in) __u32 event_buffer_size; //para eventos (in) __u32 padding[5]; //no usado __s32 fd; //fd de salida (out) }; El campo offsets debe contener los n\u00fameros de los pines que pertenecen a la l\u00ednea, indicando el n\u00famero total de pines de la l\u00ednea en num_lines . La configuraci\u00f3n de los pines de la l\u00ednea se indica en el campo config . A la salida, el campo fd es un nuevo descriptor de fichero que podemos usar para operar sobre los pines (leer/escribir). El campo config del es del tipo: struct gpio_v2_line_config { __aligned_u64 flags; // flags por defecto para los pines __u32 num_attrs; // n\u00famero de atributos en attrs __u32 padding[5]; // no usado struct gpio_v2_line_config_attribute attrs[GPIO_V2_LINE_NUM_ATTRS_MAX]; // array de atributos }; El campo flags de esta estructura es una m\u00e1scara de bits que permite seleccionar la configuraci\u00f3n de los pines de la l\u00ednea, combinando con una or las siguientes macros: GPIO_V2_LINE_FLAG_USED GPIO_V2_LINE_FLAG_ACTIVE_LOW GPIO_V2_LINE_FLAG_INPUT GPIO_V2_LINE_FLAG_OUTPUT GPIO_V2_LINE_FLAG_EDGE_RISING GPIO_V2_LINE_FLAG_EDGE_FALLING GPIO_V2_LINE_FLAG_OPEN_DRAIN GPIO_V2_LINE_FLAG_OPEN_SOURCE GPIO_V2_LINE_FLAG_BIAS_PULL_UP GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN GPIO_V2_LINE_FLAG_BIAS_DISABLED","title":"Control GPIO en Linux"},{"location":"gpio_linux/#control-gpio-en-linux","text":"En esta pr\u00e1ctica utilizaremos los drivers que proporciona linux para controlar el GPIO. Puedes hacer esta pr\u00e1ctica si tienes una raspberry-pi con Raspbian, consiguiendo manejar dispositivos sencillos, como los pulsadores y los leds que incorpora la placa BEE, desde un programa de usuario escrito en C.","title":"Control GPIO en Linux"},{"location":"gpio_linux/#introduccion","text":"Linux expone los controladores del GPIO como dispositivos orientados a caracteres /dev/gpiochip# . Usar estos dispositivos ofrece las siguientes ventajas: Portabilidad: el c\u00f3digo es pr\u00e1cticamente independiente del hardware, a excepci\u00f3n de los GPIOS/pines que hay que usar No requiere privilegios de root Ofrece un mecanismo para tratar eventos hw desde el espacio de usuario Mantiene la sem\u00e1ntica UNIX tradicional de todo es un fichero Como con cualquier otro dispositivo, podemos trabajar con el gpio como si fuese un fichero, utilizando las llamadas al sistema open() , read() , write() , ioctl() , close() . En esta pr\u00e1ctica usaremos la versi\u00f3n 2 del ABI, la 1 se considera obsoleta ( deprecated ). La fuente m\u00e1s fiable de referencia/documentaci\u00f3n es el propio fichero de cabecera /usr/include/linux/gpio.h .","title":"Introducci\u00f3n"},{"location":"gpio_linux/#utilidades-de-linea-de-comandos","text":"La librer\u00eda libgpiod nos ofrece unos programas de ejemplo que podemos utilizar como utilidades de l\u00ednea de comandos para interactuar con los controladores de GPIO. Para disponer de estas herramientas debemos instalar algunos paquetes de raspbian: sudo apt install gpiod libgpiod-dev libgpiod-doc Una vez instalados estos paquetes tendremos disponibles las utilidades descritas en las siguientes secciones.","title":"Utilidades de l\u00ednea de comandos"},{"location":"gpio_linux/#gpiodetect","text":"Esta utilidad nos da una lista de los dispositivos de caracteres para control del gpio disponibles en nuestra plataforma: pi@raspberrypi:~ $ gpiodetect gpiochip0 [pinctrl-bcm2835] (54 lines) gpiochip1 [brcmvirt-gpio] (2 lines) gpiochip2 [raspberrypi-exp-gpio] (8 lines) pi@raspberrypi:~ $","title":"gpiodetect"},{"location":"gpio_linux/#gpioinfo","text":"Esta utilidad lista los pines controlados por uno de los controladores: pi@raspberrypi:~ $ gpioinfo gpiochip0 gpiochip0 - 54 lines: line 0: unnamed unused input active-high line 1: unnamed unused input active-high line 2: unnamed unused input active-high line 3: unnamed unused input active-high ... pi@raspberrypi:~ $","title":"gpioinfo"},{"location":"gpio_linux/#gpiofind","text":"Utilidad que nos da el n\u00famero de l\u00ednea de gpio para l\u00edneas identificadas con un nombre en el device-tree","title":"gpiofind"},{"location":"gpio_linux/#gpioset","text":"Utilidad que permite asignar un valor a un conjunto de l\u00edneas del gpio mientras ejecuta el comando. Con -m modo podemos configurar lo que hace el comando tras dar el valor a las l\u00edneas. Los posibles modos son: wait: espera a que el usuario pulse enter exit: termina inmediatamente time: duerme por el periodo de tiempo especificado con el flag -s o el flag -u signal: espera hasta recibir SIGINT o SIGTERM Por ejemplo, para encender 3 leds conectados a los pines 20, 21 y 26, hasta que el usuario pulse enter: pi@raspberrypi:~ $ gpioset -m wait 0 20=1 21=1 26=1 pi@raspberrypi:~ $ El siguiente script es un ejemplo de uso de gpioset que hace oscilar una luz entre tres leds. #!/bin/bash ini=0x01 dir=0 while true do bit26=$(( (ini & 0x4) >> 2 )) bit21=$(( (ini & 0x2) >> 1 )) bit20=$((ini & 0x1)) gpioset -m time -s 1 0 26=$bit26 21=$bit21 20=$bit20 if [ $dir -eq 0 ]; then ini=$(((ini << 1) & 0x7)) else ini=$(((ini >> 1) & 0x7)) fi if [ $ini -eq 0 ]; then dir=$(((dir + 1) & 1)) ini=0x2 fi done","title":"gpioset"},{"location":"gpio_linux/#gpioget","text":"Esta utilidad nos da el estado actual de las l\u00edneas solicitadas en el chip de control indicado en la linea de comandos","title":"gpioget"},{"location":"gpio_linux/#gpiomon","text":"Esta utilidad nos permite monitorizar el estado de unos pines. Usa la llamada al sistema poll , con las siguientes opciones: -n NUM: termina despu\u00e9s de \\texttt{NUM} eventos -s: no imprime informaci\u00f3n de evento -r: procesa s\u00f3lo eventos de flanco de subida -f: procesa s\u00f3lo eventos de flanco de bajada -F FMT: especifica el formato de salida (consulta la p\u00e1gina de manual) Por ejemplo, para monitorizar tres pulsadores conectados a las l\u00edneas 19, 6 y 5: pi@raspberrypi:~ $ gpiomon -f 0 19 6 5 event: FALLING EDGE offset: 19 timestamp: [ 2740.887807571] event: FALLING EDGE offset: 6 timestamp: [ 2742.291116096] event: FALLING EDGE offset: 5 timestamp: [ 2744.609921761] ^Cpi@raspberrypi:~ $","title":"gpiomon"},{"location":"gpio_linux/#driver-gpio","text":"Vamos a ver c\u00f3mo podemos manejar los pines del GPIO desde un programa de usuario escrito en C utilizando el driver de GPIO proporcionado por Linux. Para ello debemos comprender qu\u00e9 son las operaciones ioctl en el est\u00e1ndar POSIX, que ser\u00e1n vitales para la comunicaci\u00f3n con el driver. Luego iremos viendo como podemos utilizar estas operaciones para interactuar con el controlador GPIO.","title":"Driver GPIO"},{"location":"gpio_linux/#operaciones-ioctl","text":"En los sistemas POSIX las operaciones sobre un dispositivo que no sean read o write se realizan con la llamada al sistema ioctl , cuyo prototipo es: int ioctl(int fd, unsigned long request, void *argp); d\u00f3nde: fd : descriptor de fichero devuelto por open request : petici\u00f3n de operaci\u00f3n, dependiente del dispositivo. argp : direcci\u00f3n a un buffer que depende del tipo de operaci\u00f3n. No hay un est\u00e1ndar para los c\u00f3digos de las peticiones, pero un convenio que es ampliamente usado es el siguiente: Dos bits para indicar la direcci\u00f3n: 00 (nada), 01 (lectura), 10 (escritura) y 11 (lectura y escritura). 14 bits que indican el tama\u00f1o del dato pasado como argumento 8 bits de tipo de operaci\u00f3n 8 bits de n\u00famero de operaci\u00f3n El sistema define unas macros para ayudar a la codificaci\u00f3n de estas peticiones: _IOR(type, nr, arg), _IOW(type, nr, arg), _IOWR(type, nr, arg) e _IO(type, nr).","title":"Operaciones ioctl"},{"location":"gpio_linux/#obtener-informacion-del-controlador-gpio","text":"Para obtener informaci\u00f3n del controlador podemos utilizar la petici\u00f3n ioctl GPIO_GET_CHIP_INFO, que requiere como par\u00e1metro adicional la direcci\u00f3n de una estructura del siguiente tipo: struct gpiochip_info { char name[32]; /* Nombre del controlador en el kernel */ char label[32]; /* Nombre funcional, de producto */ __u32 lines; /* n\u00famero de l\u00edneas que maneja */ }; Un ejemplo de uso ser\u00eda el siguiente: int fd; struct gpiochip_info info; fd = open(\"/dev/gpiochip0\", O_RDONLY); ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &info); close(fd); printf(\"label: %s\\n\", info.label); printf(\"name: %s\\n\", info.name); printf(\"number of lines: %u\\n\", info.lines); Examinar el ejemplo gpio_info y comprobar su funcionamiento.","title":"Obtener informaci\u00f3n del controlador GPIO"},{"location":"gpio_linux/#pines-de-entrada-y-salida","text":"El driver de GPIO nos permite definir l\u00edneas de pines , que representan grupos de pines con un nombre de usuario (por ejemplo sevenseg), y que comparten la misma configuraci\u00f3n. Una vez creada la l\u00ednea se obtiene un descriptor de fichero que la representa, con el que podremos manejar este grupo de pines. Para crear una de estas l\u00edneas de pines , una vez abierto el dispositivo, debemos hacer una petici\u00f3n ioctl de tipo line_request : ioctl(fd, GPIO_V2_GET_LINE_IOCTL, &req); d\u00f3nde req es un struct gpio_v2_line_request : struct gpio_v2_line_request { __u32 offsets[GPIO_V2_LINES_MAX]; //pines a manejar (in) char consumer[GPIO_MAX_NAME_SIZE]; //nombre por usuario (in) struct gpio_v2_line_config config; //configuraci\u00f3n (in) __u32 num_lines; //num pines en offsets (in) __u32 event_buffer_size; //para eventos (in) __u32 padding[5]; //no usado __s32 fd; //fd de salida (out) }; El campo offsets debe contener los n\u00fameros de los pines que pertenecen a la l\u00ednea, indicando el n\u00famero total de pines de la l\u00ednea en num_lines . La configuraci\u00f3n de los pines de la l\u00ednea se indica en el campo config . A la salida, el campo fd es un nuevo descriptor de fichero que podemos usar para operar sobre los pines (leer/escribir). El campo config del es del tipo: struct gpio_v2_line_config { __aligned_u64 flags; // flags por defecto para los pines __u32 num_attrs; // n\u00famero de atributos en attrs __u32 padding[5]; // no usado struct gpio_v2_line_config_attribute attrs[GPIO_V2_LINE_NUM_ATTRS_MAX]; // array de atributos }; El campo flags de esta estructura es una m\u00e1scara de bits que permite seleccionar la configuraci\u00f3n de los pines de la l\u00ednea, combinando con una or las siguientes macros: GPIO_V2_LINE_FLAG_USED GPIO_V2_LINE_FLAG_ACTIVE_LOW GPIO_V2_LINE_FLAG_INPUT GPIO_V2_LINE_FLAG_OUTPUT GPIO_V2_LINE_FLAG_EDGE_RISING GPIO_V2_LINE_FLAG_EDGE_FALLING GPIO_V2_LINE_FLAG_OPEN_DRAIN GPIO_V2_LINE_FLAG_OPEN_SOURCE GPIO_V2_LINE_FLAG_BIAS_PULL_UP GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN GPIO_V2_LINE_FLAG_BIAS_DISABLED","title":"Pines de entrada y salida"}]}